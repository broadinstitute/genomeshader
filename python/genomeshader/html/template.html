<!doctype html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Genomeshader Prototype (SVG scaffolding)</title>

  <!--__GENOMESHADER_BOOTSTRAP__-->

  <style>
    :root {
      --sidebar-w: 240px;
      --tracks-h: 280px;   /* ideogram + genes + repeats + ruler */
      --flow-h: 500px;     /* sankey placeholder */
      --reads-h: 220px;    /* IGV-style reads area placeholder */

      --bg: #0b0d10;
      --panel: #11151b;
      --panel2: rgba(255,255,255,0.03);

      --border: rgba(255,255,255,0.10);
      --border2: rgba(255,255,255,0.08);

      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --muted2: rgba(255,255,255,0.45);

      --grid: rgba(255,255,255,0.12);
      --grid2: rgba(255,255,255,0.07);

      --accent: #ff4d4d;

      --blue: rgba(120,180,255,0.9);
      --blueFill: rgba(120,180,255,0.18);

      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --hudBg: rgba(0,0,0,0.35);
    }

    html[data-theme="light"] {
      --bg: #f7f8fb;
      --panel: #ffffff;
      --panel2: rgba(0,0,0,0.03);

      --border: rgba(0,0,0,0.12);
      --border2: rgba(0,0,0,0.10);

      --text: rgba(0,0,0,0.90);
      --muted: rgba(0,0,0,0.62);
      --muted2: rgba(0,0,0,0.45);

      --grid: rgba(0,0,0,0.12);
      --grid2: rgba(0,0,0,0.07);

      --accent: #d81b1b;

      --blue: rgba(18, 110, 255, 0.85);
      --blueFill: rgba(18, 110, 255, 0.14);

      --shadow: 0 10px 30px rgba(0,0,0,0.12);
      --hudBg: rgba(255,255,255,0.78);
    }

    @media (prefers-color-scheme: light) {
      html[data-theme="auto"] {
        --bg: #f7f8fb;
        --panel: #ffffff;
        --panel2: rgba(0,0,0,0.03);

        --border: rgba(0,0,0,0.12);
        --border2: rgba(0,0,0,0.10);

        --text: rgba(0,0,0,0.90);
        --muted: rgba(0,0,0,0.62);
        --muted2: rgba(0,0,0,0.45);

        --grid: rgba(0,0,0,0.12);
        --grid2: rgba(0,0,0,0.07);

        --accent: #d81b1b;

        --blue: rgba(18, 110, 255, 0.85);
        --blueFill: rgba(18, 110, 255, 0.14);

        --shadow: 0 10px 30px rgba(0,0,0,0.12);
        --hudBg: rgba(255,255,255,0.78);
      }
    }
    @media (prefers-color-scheme: dark) {
      html[data-theme="auto"] {
        --bg: #0b0d10;
        --panel: #11151b;
        --panel2: rgba(255,255,255,0.03);

        --border: rgba(255,255,255,0.10);
        --border2: rgba(255,255,255,0.08);

        --text: rgba(255,255,255,0.92);
        --muted: rgba(255,255,255,0.65);
        --muted2: rgba(255,255,255,0.45);

        --grid: rgba(255,255,255,0.12);
        --grid2: rgba(255,255,255,0.07);

        --accent: #ff4d4d;

        --blue: rgba(120,180,255,0.9);
        --blueFill: rgba(120,180,255,0.18);

        --shadow: 0 10px 30px rgba(0,0,0,0.35);
        --hudBg: rgba(0,0,0,0.35);
      }
    }

    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui; }
    * { box-sizing: border-box; }

    .app {
      display: grid;
      grid-template-columns: var(--sidebar-w) 1fr;
      height: 100%;
      overflow: hidden;
      transition: grid-template-columns 0.2s ease;
    }
    .app.sidebar-collapsed {
      grid-template-columns: 12px 1fr;
    }
    .app.sidebar-collapsed .sidebar {
      min-width: 12px;
    }

    .sidebar {
      position: relative;
      background: var(--panel);
      border-right: 1px solid var(--border2);
      padding: 12px;
      overflow: visible;
      padding-bottom: 56px; /* space for gear button */
      transition: opacity 0.2s ease;
    }
    .sidebar::after {
      content: "";
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease, width 0.2s ease, box-shadow 0.2s ease;
      z-index: 10;
    }
    .sidebar:hover::after {
      background: var(--blue);
      width: 6px;
      box-shadow: 0 0 8px rgba(120, 180, 255, 0.4);
    }
    .app.sidebar-collapsed .sidebar {
      padding: 0;
      overflow: visible;
    }
    .app.sidebar-collapsed .sidebar > * {
      opacity: 0;
      pointer-events: none;
    }
    .app.sidebar-collapsed .sidebar::after {
      pointer-events: auto;
      opacity: 1 !important;
      right: 0;
      width: 12px;
      background: rgba(127, 127, 127, 0.08);
      border-right: 1px solid var(--border2);
    }
    .app.sidebar-collapsed .sidebar:hover::after {
      width: 14px;
      background: var(--blue);
      border-right: none;
      box-shadow: 0 0 12px rgba(120, 180, 255, 0.5);
    }

    .sidebarHeader {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      margin-bottom: 10px;
      gap: 8px;
    }
    
    .sidebarToggle {
      width: 24px;
      height: 24px;
      border: 1px solid var(--border2);
      background: var(--panel2);
      color: var(--text);
      border-radius: 6px;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      padding: 0;
      flex-shrink: 0;
      transition: all 0.15s ease;
    }
    .sidebarToggle:hover {
      background: var(--panel);
      border-color: var(--border);
    }
    .sidebarToggle:active {
      transform: scale(0.95);
    }
    
    .sidebarHeader h3 {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
      font-weight: 650;
      letter-spacing: 0.02em;
    }

    .group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 9px 10px;
      margin: 7px 0;
      border-radius: 10px;
      background: var(--panel2);
      cursor: pointer;
      user-select: none;
      border: 1px solid transparent;
    }
    .group:hover { border-color: var(--border2); }
    .pill { font-size: 12px; padding: 2px 8px; border-radius: 999px; background: rgba(127,127,127,0.16); color: var(--muted); }

    /* Gear button bottom-left (requested) */
    .gearBtn {
      position: absolute;
      left: 12px;
      bottom: 12px;
      border: 1px solid var(--border2);
      background: var(--panel2);
      color: var(--text);
      width: 36px;
      height: 36px;
      border-radius: 12px;
      cursor: pointer;
      user-select: none;
      display: grid;
      place-items: center;
      font-size: 18px;
      line-height: 1;
    }
    .gearBtn:hover { filter: brightness(1.06); }
    .gearBtn:active { transform: translateY(1px); }

    /* Context menu */
    .menu {
      position: absolute;
      min-width: 220px;
      padding: 8px;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      z-index: 50;
      display: none;
    }
    .menu.open { display: block; }
    .menuTitle {
      font-size: 11px;
      color: var(--muted2);
      padding: 6px 8px 4px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }
    .menuItem {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 10px;
      border-radius: 10px;
      cursor: pointer;
      user-select: none;
      color: var(--text);
      font-size: 13px;
    }
    .menuItem:hover { background: var(--panel2); }
    .menuRight { color: var(--muted); font-size: 12px; }

    .main {
      position: relative;
      overflow: hidden;
      touch-action: none; /* we own pan/zoom gestures on right pane */
    }

    .tracks {
      position: absolute;
      left: 0; top: 0; right: 0;
      height: var(--tracks-h);
      border-bottom: 1px solid var(--border);
      background: linear-gradient(to bottom, rgba(127,127,127,0.08), rgba(127,127,127,0.00));
    }
    #trackControls {
      position: absolute;
      inset: 0;
      z-index: 20;
      pointer-events: none;
    }

    .flow {
      position: absolute;
      left: 0; right: 0;
      background: rgba(127,127,127,0.04);
    }

    .reads {
      position: absolute;
      left: 0; right: 0;
      background: rgba(127,127,127,0.02);
    }

    /* Vertical mode: tracks laid out side-by-side */
    .main.vertical .tracks {
      display: flex;
      flex-direction: row;
      height: 100%;
      width: 100%;
      left: 0;
      top: 0;
      right: auto;
      bottom: 0;
      border-bottom: none;
      border-right: 1px solid var(--border);
    }

    .main.vertical .flow,
    .main.vertical .reads {
      position: absolute;
      top: 0;
      bottom: 0;
      height: 100%;
    }

    canvas.canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    canvas.webgpu-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      pointer-events: auto;
      z-index: 1; /* Above SVG, below controls */
    }

    svg.overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    /* Locus indicator lower-right */
    .hud {
      position: absolute;
      right: 10px;
      bottom: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      background: var(--hudBg);
      border: 1px solid var(--border2);
      font-size: 12px;
      color: var(--muted);
      backdrop-filter: blur(6px);
      pointer-events: none;
      white-space: nowrap;
      box-shadow: var(--shadow);
    }

    /* Tooltip */
    .tooltip {
      position: fixed;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--panel);
      border: 1px solid var(--border);
      font-size: 12px;
      color: var(--text);
      pointer-events: none;
      z-index: 1000;
      white-space: pre-line;
      box-shadow: var(--shadow);
      display: none;
      line-height: 1.4;
    }
    .tooltip.visible {
      display: block;
    }

    /* SVG text classes */
    .svg-label { fill: var(--muted); font-size: 12px; font-weight: 600; }
    .svg-small { fill: var(--muted2); font-size: 10px; }
    .svg-chr   { fill: var(--text); font-size: 12px; font-weight: 650; }

    .svg-geneName { fill: rgba(180,220,255,0.92); font-size: 11px; font-weight: 650; }
    html[data-theme="light"] .svg-geneName { fill: rgba(18, 110, 255, 0.92); }
    @media (prefers-color-scheme: light) {
      html[data-theme="auto"] .svg-geneName { fill: rgba(18, 110, 255, 0.92); }
    }
    @media (prefers-color-scheme: dark) {
      html[data-theme="auto"] .svg-geneName { fill: rgba(180,220,255,0.92); }
    }

    .svg-trackHint { fill: var(--muted2); font-size: 11px; }

    /* Track controls */
    .track-controls {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      height: 24px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 12px;
      background: rgba(127,127,127,0.03);
      border-bottom: 1px solid var(--border2);
      z-index: 10;
      cursor: move;
    }
    .main.vertical .track-controls {
      top: auto;
    }
    .track-controls:hover { background: rgba(127,127,127,0.06); }

    .track-collapse-btn {
      width: 18px;
      height: 18px;
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      padding: 0;
      border-radius: 4px;
      flex-shrink: 0;
    }
    .track-collapse-btn:hover { background: var(--panel2); color: var(--text); }
    .track-collapse-btn:active { transform: scale(0.95); }

    .track-label {
      flex: 1;
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
      user-select: none;
      pointer-events: none;
    }

    /* Vertical mode: track controls at bottom, vertically oriented */
    .main.vertical .track-control-container {
      position: absolute;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      align-items: flex-start;
    }
    .main.vertical .track-controls {
      width: 24px;
      height: 100%;
      flex-direction: column;
      padding: 0;
      border-bottom: none;
      border-right: 1px solid var(--border2);
      position: relative;
      left: 0;
      right: auto;
      transform: none;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      margin-bottom: 0;
    }
    .main.vertical .track-label {
      order: 1;
      white-space: nowrap;
      writing-mode: horizontal-tb;
      margin: 0;
      position: absolute;
      bottom: 0;
      left: 50%;
      transform-origin: left center;
      flex-shrink: 0;
      /* Default transform to prevent flash of unstyled content */
      transform: rotate(-90deg) translateX(12px) translateY(0.0px);
    }
    .main.vertical .track-collapse-btn {
      align-self: center;
      order: 2;
      margin-top: 0;
      margin-bottom: 0;
    }

    .track-resize-handle {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 6px;
      cursor: ns-resize;
      z-index: 15;
      background: transparent;
      pointer-events: auto;
    }
    .track-resize-handle:hover {
      background: var(--accent);
      opacity: 0.3;
    }
    .track-resize-handle:active {
      background: var(--accent);
      opacity: 0.6;
    }
    .main.vertical .track-resize-handle {
      left: auto;
      right: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      height: 100%;
      cursor: ew-resize;
    }

    .track-content {
      position: absolute;
      left: 0;
      right: 0;
      top: 24px;
      bottom: 0;
      overflow: hidden;
    }

    .track-control-container {
      pointer-events: none;
    }
    .track-control-container .track-controls,
    .track-control-container .track-resize-handle {
      pointer-events: auto;
    }

  </style>
</head>

<body>
  <div class="app">
    <div class="sidebar" id="sidebar">
      <div class="sidebarHeader">
        <h3>Participant groups</h3>
      </div>

      <div class="group"><span>AFR</span><span class="pill">2634</span></div>
      <div class="group"><span>AMR</span><span class="pill">603</span></div>
      <div class="group"><span>EAS</span><span class="pill">1095</span></div>
      <div class="group"><span>EUR</span><span class="pill">5340</span></div>
      <div class="group"><span>SAS</span><span class="pill">328</span></div>

      <button class="gearBtn" id="menuBtn" title="Settings" aria-label="Settings">⚙︎</button>

      <div class="menu" id="ctxMenu" role="menu" aria-hidden="true">
        <div class="menuTitle">Display</div>
        <div class="menuItem" id="themeItem" role="menuitem">
          <span>Theme</span>
          <span class="menuRight" id="themeLabel">Auto</span>
        </div>

        <div class="menuItem" id="orientationItem" role="menuitem">
          <span>Orientation</span>
          <span class="menuRight" id="orientationLabel">Horizontal</span>
        </div>

        <div class="menuItem" id="variantLayoutModeItem" role="menuitem">
          <span>Variant Layout</span>
          <span class="menuRight" id="variantLayoutModeLabel">Equidistant</span>
        </div>

        <div class="menuTitle">Grouping</div>
        <div class="menuItem" role="menuitem">
          <span>Variable</span>
          <span class="menuRight">Super-pop</span>
        </div>
      </div>
    </div>

    <div class="main" id="main">
      <div class="tracks" id="tracksContainer">
        <svg id="tracksSvg" width="100%" height="100%"></svg>
        <canvas id="tracksWebGPU" class="webgpu-canvas" width="100%" height="100%"></canvas>
        <div id="trackControls"></div>
      </div>

      <div class="flow" id="flow">
        <canvas class="canvas" id="flowCanvas"></canvas>
        <svg class="overlay" id="flowOverlay"></svg>
      </div>

      <div class="reads" id="reads">
        <canvas class="canvas" id="readsCanvas"></canvas>
        <svg class="overlay" id="readsOverlay"></svg>
      </div>

      <div class="hud" id="hud"></div>
      <div class="tooltip" id="tooltip"></div>
    </div>
  </div>

<script type="module">
  // -----------------------------
  // WebGPU Classes (inlined to avoid module import issues with blob URLs)
  // -----------------------------
  class WebGPUCore {
    constructor() {
      this.device = null;
      this.context = null;
      this.canvas = null;
      this.format = null;
      this.projectionMatrix = null;
      this.screenSize = null;
      this.projectionBuffer = null;
    }

    async init(canvas) {
      if (!navigator.gpu) {
        throw new Error('WebGPU is not supported in this browser');
      }

      this.canvas = canvas;
      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) {
        throw new Error('Failed to get WebGPU adapter');
      }

      this.device = await adapter.requestDevice();
      this.format = navigator.gpu.getPreferredCanvasFormat();
      
      this.context = canvas.getContext('webgpu');
      if (!this.context) {
        throw new Error('Failed to get WebGPU context');
      }

      const devicePixelRatio = window.devicePixelRatio || 1;
      const width = canvas.clientWidth * devicePixelRatio;
      const height = canvas.clientHeight * devicePixelRatio;

      this.context.configure({
        device: this.device,
        format: this.format,
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
        alphaMode: 'premultiplied',
      });

      // Create projection matrix buffer (orthographic 2D projection)
      this.projectionMatrix = new Float32Array([
        2.0 / width, 0, 0, 0,
        0, -2.0 / height, 0, 0,
        0, 0, 1, 0,
        -1, 1, 0, 1
      ]);
      
      // Pad vec2 to vec4 for 16-byte alignment (vec2 = 8 bytes, needs padding to 16)
      this.screenSize = new Float32Array([width, height, 0, 0]);

      this.projectionBuffer = this.device.createBuffer({
        size: (16 + 4) * 4, // mat4x4 (16 floats) + vec4 padded (4 floats) = 20 floats * 4 bytes = 80 bytes
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      });

      // Write projection matrix and screen size to buffer
      this.device.queue.writeBuffer(this.projectionBuffer, 0, this.projectionMatrix);
      this.device.queue.writeBuffer(this.projectionBuffer, 16 * 4, this.screenSize);

      // Handle resize
      window.addEventListener('resize', () => this.handleResize());
    }

    handleResize() {
      if (!this.canvas || !this.context) return;

      const devicePixelRatio = window.devicePixelRatio || 1;
      const width = this.canvas.clientWidth * devicePixelRatio;
      const height = this.canvas.clientHeight * devicePixelRatio;

      // Update canvas size
      this.canvas.width = width;
      this.canvas.height = height;

      // Update projection matrix
      this.projectionMatrix[0] = 2.0 / width;
      this.projectionMatrix[5] = -2.0 / height;
      this.projectionMatrix[12] = -1;
      this.projectionMatrix[13] = 1;
      
      // Update screen size (vec4 padded)
      this.screenSize[0] = width;
      this.screenSize[1] = height;
      this.screenSize[2] = 0;
      this.screenSize[3] = 0;

      this.device.queue.writeBuffer(this.projectionBuffer, 0, this.projectionMatrix);
      this.device.queue.writeBuffer(this.projectionBuffer, 16 * 4, this.screenSize);
    }

    getCurrentTexture() {
      return this.context.getCurrentTexture();
    }

    createCommandEncoder() {
      return this.device.createCommandEncoder();
    }

    submit(commands) {
      this.device.queue.submit(commands);
    }
  }

  class InstancedRenderer {
    constructor(webgpuCore) {
      this.core = webgpuCore;
      this.device = webgpuCore.device;
      
      // Rectangle rendering
      this.rectPipeline = null;
      this.rectInstances = [];
      this.rectBuffer = null;
      this.rectVertexBuffer = null;
      
      // Triangle rendering
      this.trianglePipeline = null;
      this.triangleInstances = [];
      this.triangleBuffer = null;
      this.triangleVertexBuffer = null;
      
      // Line rendering
      this.linePipeline = null;
      this.lineInstances = [];
      this.lineBuffer = null;
      
      this.init();
    }

    init() {
      this.createRectPipeline();
      this.createTrianglePipeline();
      this.createLinePipeline();
      this.createGeometryBuffers();
    }

    // Convert hex color to normalized RGBA
    hexToRgba(hex, alpha = 1.0) {
      if (typeof hex === 'string') {
        if (hex.startsWith('#')) {
          hex = hex.slice(1);
        }
        const r = parseInt(hex.slice(0, 2), 16) / 255;
        const g = parseInt(hex.slice(2, 4), 16) / 255;
        const b = parseInt(hex.slice(4, 6), 16) / 255;
        return [r, g, b, alpha];
      } else {
        // Assume it's a number (0xRRGGBB)
        const r = ((hex >> 16) & 0xFF) / 255;
        const g = ((hex >> 8) & 0xFF) / 255;
        const b = (hex & 0xFF) / 255;
        return [r, g, b, alpha];
      }
    }

    createRectPipeline() {
      const vertexShader = `
        struct Uniforms {
          projection: mat4x4<f32>,
          screenSize: vec2<f32>,
          _padding: vec2<f32>, // Padding for 16-byte alignment
        }
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        struct VertexOutput {
          @builtin(position) position: vec4<f32>,
          @location(1) @interpolate(flat) instanceMin: vec2<f32>,
          @location(2) @interpolate(flat) instanceMax: vec2<f32>,
          @location(3) @interpolate(flat) color: vec4<f32>,
        }

        @vertex
        fn vs_main(
          @builtin(vertex_index) vertexIndex: u32,
          @builtin(instance_index) instanceIndex: u32,
          @location(0) position: vec2<f32>,
          @location(1) size: vec2<f32>,
          @location(2) color: vec4<f32>
        ) -> VertexOutput {
          // Quad vertices: (-0.5, -0.5), (0.5, -0.5), (-0.5, 0.5), (0.5, 0.5)
          var quadPos = vec2<f32>(0.0);
          if (vertexIndex == 0u) {
            quadPos = vec2<f32>(-0.5, -0.5);
          } else if (vertexIndex == 1u) {
            quadPos = vec2<f32>(0.5, -0.5);
          } else if (vertexIndex == 2u) {
            quadPos = vec2<f32>(-0.5, 0.5);
          } else {
            quadPos = vec2<f32>(0.5, 0.5);
          }
          
          var worldPos = position + quadPos * size;
          var halfSize = size * 0.5;
          var output: VertexOutput;
          output.position = uniforms.projection * vec4<f32>(worldPos, 0.0, 1.0);
          output.instanceMin = position - halfSize;
          output.instanceMax = position + halfSize;
          output.color = color;
          return output;
        }
      `;

      const fragmentShader = `
        struct Uniforms {
          projection: mat4x4<f32>,
          screenSize: vec2<f32>,
          _padding: vec2<f32>, // Padding for 16-byte alignment
        }
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        @fragment
        fn fs_main(
          @builtin(position) fragCoord: vec4<f32>,
          @location(1) @interpolate(flat) instanceMin: vec2<f32>,
          @location(2) @interpolate(flat) instanceMax: vec2<f32>,
          @location(3) @interpolate(flat) color: vec4<f32>
        ) -> @location(0) vec4<f32> {
          // fragCoord.xy is in framebuffer pixel coordinates (not NDC)
          // This directly matches our world coordinates since we use an orthographic projection
          let worldPos = fragCoord.xy;
          
          // Get rectangle dimensions and center
          let size = instanceMax - instanceMin;
          let center = (instanceMin + instanceMax) * 0.5;
          let halfSize = size * 0.5;
          let minDim = min(size.x, size.y);
          
          // For very small rectangles (< 6px), don't apply rounding
          if (minDim < 6.0) {
            // Still need premultiplied alpha for correct blending
            return vec4<f32>(color.rgb * color.a, color.a);
          }
          
          // Apply rounded corners with radius 6 pixels
          let radius = 6.0;
          let actualRadius = min(radius, minDim * 0.5);
          
          // Proper rounded rectangle SDF
          // Calculate position relative to center
          let p = abs(worldPos - center);
          // Shrink the half-size by radius to get the inner rectangle
          let q = p - halfSize + actualRadius;
          // Distance to rounded rectangle: negative inside, positive outside
          let d = length(max(q, vec2<f32>(0.0))) + min(max(q.x, q.y), 0.0) - actualRadius;
          
          // Smooth edge with anti-aliasing (d < 0 means inside)
          let alpha = 1.0 - smoothstep(-0.5, 0.5, d);
          
          // Output premultiplied alpha for correct blending
          let finalAlpha = color.a * alpha;
          return vec4<f32>(color.rgb * finalAlpha, finalAlpha);
        }
      `;

      const vertexModule = this.device.createShaderModule({ code: vertexShader });
      const fragmentModule = this.device.createShaderModule({ code: fragmentShader });

      this.rectPipeline = this.device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: vertexModule,
          entryPoint: 'vs_main',
          buffers: [
            {
              arrayStride: 8 * 4, // position(8) + size(8) + color(16) = 32 bytes
              stepMode: 'instance',
              attributes: [
                { shaderLocation: 0, offset: 0, format: 'float32x2' }, // position
                { shaderLocation: 1, offset: 8, format: 'float32x2' }, // size
                { shaderLocation: 2, offset: 16, format: 'float32x4' }, // color
              ],
            },
          ],
        },
        fragment: {
          module: fragmentModule,
          entryPoint: 'fs_main',
          targets: [{
            format: this.core.format,
            blend: {
              color: {
                srcFactor: 'one',
                dstFactor: 'one-minus-src-alpha',
                operation: 'add',
              },
              alpha: {
                srcFactor: 'one',
                dstFactor: 'one-minus-src-alpha',
                operation: 'add',
              },
            },
          }],
        },
        primitive: {
          topology: 'triangle-strip',
        },
      });
    }

    createTrianglePipeline() {
      const vertexShader = `
        struct Uniforms {
          projection: mat4x4<f32>,
        }
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        struct VertexOutput {
          @builtin(position) position: vec4<f32>,
          @location(3) @interpolate(flat) color: vec4<f32>,
        }

        @vertex
        fn vs_main(
          @builtin(vertex_index) vertexIndex: u32,
          @builtin(instance_index) instanceIndex: u32,
          @location(0) v0: vec2<f32>,
          @location(1) v1: vec2<f32>,
          @location(2) v2: vec2<f32>,
          @location(3) color: vec4<f32>
        ) -> VertexOutput {
          var pos: vec2<f32>;
          if (vertexIndex == 0u) {
            pos = v0;
          } else if (vertexIndex == 1u) {
            pos = v1;
          } else {
            pos = v2;
          }
          var output: VertexOutput;
          output.position = uniforms.projection * vec4<f32>(pos, 0.0, 1.0);
          output.color = color;
          return output;
        }
      `;

      const fragmentShader = `
        @fragment
        fn fs_main(
          @location(3) @interpolate(flat) color: vec4<f32>
        ) -> @location(0) vec4<f32> {
          return color;
        }
      `;

      const vertexModule = this.device.createShaderModule({ code: vertexShader });
      const fragmentModule = this.device.createShaderModule({ code: fragmentShader });

      this.trianglePipeline = this.device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: vertexModule,
          entryPoint: 'vs_main',
          buffers: [
            {
              arrayStride: 10 * 4, // v0(8) + v1(8) + v2(8) + color(16) = 40 bytes = 10 floats
              stepMode: 'instance',
              attributes: [
                { shaderLocation: 0, offset: 0, format: 'float32x2' }, // v0
                { shaderLocation: 1, offset: 8, format: 'float32x2' }, // v1
                { shaderLocation: 2, offset: 16, format: 'float32x2' }, // v2
                { shaderLocation: 3, offset: 24, format: 'float32x4' }, // color
              ],
            },
          ],
        },
        fragment: {
          module: fragmentModule,
          entryPoint: 'fs_main',
          targets: [{ format: this.core.format }],
        },
        primitive: {
          topology: 'triangle-list',
        },
      });
    }

    createLinePipeline() {
      const vertexShader = `
        struct Uniforms {
          projection: mat4x4<f32>,
        }
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        struct VertexOutput {
          @builtin(position) position: vec4<f32>,
          @location(2) @interpolate(flat) color: vec4<f32>,
        }

        @vertex
        fn vs_main(
          @builtin(vertex_index) vertexIndex: u32,
          @builtin(instance_index) instanceIndex: u32,
          @location(0) start: vec2<f32>,
          @location(1) end: vec2<f32>,
          @location(2) color: vec4<f32>
        ) -> VertexOutput {
          var pos: vec2<f32>;
          if (vertexIndex == 0u) {
            pos = start;
          } else {
            pos = end;
          }
          var output: VertexOutput;
          output.position = uniforms.projection * vec4<f32>(pos, 0.0, 1.0);
          output.color = color;
          return output;
        }
      `;

      const fragmentShader = `
        @fragment
        fn fs_main(
          @location(2) @interpolate(flat) color: vec4<f32>
        ) -> @location(0) vec4<f32> {
          return color;
        }
      `;

      const vertexModule = this.device.createShaderModule({ code: vertexShader });
      const fragmentModule = this.device.createShaderModule({ code: fragmentShader });

      this.linePipeline = this.device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: vertexModule,
          entryPoint: 'vs_main',
          buffers: [
            {
              arrayStride: 8 * 4, // start(8) + end(8) + color(16) = 32 bytes
              stepMode: 'instance',
              attributes: [
                { shaderLocation: 0, offset: 0, format: 'float32x2' }, // start
                { shaderLocation: 1, offset: 8, format: 'float32x2' }, // end
                { shaderLocation: 2, offset: 16, format: 'float32x4' }, // color
              ],
            },
          ],
        },
        fragment: {
          module: fragmentModule,
          entryPoint: 'fs_main',
          targets: [{ format: this.core.format }],
        },
        primitive: {
          topology: 'line-list',
        },
      });
    }

    createGeometryBuffers() {
      // Rectangle uses triangle-strip, no vertex buffer needed (generated in shader)
      // Triangle uses triangle-list, no vertex buffer needed (generated in shader)
      // Line uses line-list, no vertex buffer needed (generated in shader)
    }

    // Add rectangle instance
    // color can be: hex string (e.g., "#FF0000"), hex number, or rgba array [r, g, b, a]
    addRect(x, y, width, height, color, alpha = 1.0) {
      let rgba;
      if (Array.isArray(color) && color.length >= 3) {
        // Already an rgba array
        rgba = color.length === 4 ? color : [...color, alpha];
      } else {
        // Convert hex to rgba
        rgba = this.hexToRgba(color, alpha);
      }
      this.rectInstances.push({
        position: [x + width / 2, y + height / 2], // center position
        size: [width, height],
        color: rgba,
      });
    }

    // Add triangle instance
    addTriangle(x0, y0, x1, y1, x2, y2, color, alpha = 1.0) {
      const rgba = this.hexToRgba(color, alpha);
      this.triangleInstances.push({
        v0: [x0, y0],
        v1: [x1, y1],
        v2: [x2, y2],
        color: rgba,
      });
    }

    // Add line instance
    addLine(x0, y0, x1, y1, color, alpha = 1.0) {
      const rgba = this.hexToRgba(color, alpha);
      this.lineInstances.push({
        start: [x0, y0],
        end: [x1, y1],
        color: rgba,
      });
    }

    // Clear all instances
    clear() {
      this.rectInstances = [];
      this.triangleInstances = [];
      this.lineInstances = [];
    }

    // Render all instances
    render(encoder, renderPass) {
      // Create uniform bind group (same layout for all pipelines)
      const uniformBindGroupLayout = this.rectPipeline.getBindGroupLayout(0);
      const uniformBindGroup = this.device.createBindGroup({
        layout: uniformBindGroupLayout,
        entries: [
          {
            binding: 0,
            resource: {
              buffer: this.core.projectionBuffer,
            },
          },
        ],
      });

      // Render rectangles
      if (this.rectInstances.length > 0) {
        const instanceData = new Float32Array(this.rectInstances.length * 8);
        for (let i = 0; i < this.rectInstances.length; i++) {
          const inst = this.rectInstances[i];
          const offset = i * 8;
          instanceData[offset + 0] = inst.position[0];
          instanceData[offset + 1] = inst.position[1];
          instanceData[offset + 2] = inst.size[0];
          instanceData[offset + 3] = inst.size[1];
          instanceData[offset + 4] = inst.color[0];
          instanceData[offset + 5] = inst.color[1];
          instanceData[offset + 6] = inst.color[2];
          instanceData[offset + 7] = inst.color[3];
        }

        if (!this.rectBuffer || this.rectBuffer.size < instanceData.byteLength) {
          if (this.rectBuffer) this.rectBuffer.destroy();
          this.rectBuffer = this.device.createBuffer({
            size: instanceData.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          });
        }

        this.device.queue.writeBuffer(this.rectBuffer, 0, instanceData);

        renderPass.setPipeline(this.rectPipeline);
        renderPass.setBindGroup(0, uniformBindGroup);
        renderPass.setVertexBuffer(0, this.rectBuffer);
        renderPass.draw(4, this.rectInstances.length); // 4 vertices per quad
      }

      // Render triangles
      if (this.triangleInstances.length > 0) {
        // v0(2) + v1(2) + v2(2) + color(4) = 10 floats per instance
        const instanceData = new Float32Array(this.triangleInstances.length * 10);
        for (let i = 0; i < this.triangleInstances.length; i++) {
          const inst = this.triangleInstances[i];
          const offset = i * 10;
          instanceData[offset + 0] = inst.v0[0];
          instanceData[offset + 1] = inst.v0[1];
          instanceData[offset + 2] = inst.v1[0];
          instanceData[offset + 3] = inst.v1[1];
          instanceData[offset + 4] = inst.v2[0];
          instanceData[offset + 5] = inst.v2[1];
          instanceData[offset + 6] = inst.color[0];
          instanceData[offset + 7] = inst.color[1];
          instanceData[offset + 8] = inst.color[2];
          instanceData[offset + 9] = inst.color[3];
        }

        if (!this.triangleBuffer || this.triangleBuffer.size < instanceData.byteLength) {
          if (this.triangleBuffer) this.triangleBuffer.destroy();
          this.triangleBuffer = this.device.createBuffer({
            size: instanceData.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          });
        }

        this.device.queue.writeBuffer(this.triangleBuffer, 0, instanceData);

        const triangleUniformBindGroup = this.device.createBindGroup({
          layout: this.trianglePipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: this.core.projectionBuffer,
              },
            },
          ],
        });
        
        renderPass.setPipeline(this.trianglePipeline);
        renderPass.setBindGroup(0, triangleUniformBindGroup);
        renderPass.setVertexBuffer(0, this.triangleBuffer);
        renderPass.draw(3, this.triangleInstances.length); // 3 vertices per triangle
      }

      // Render lines
      if (this.lineInstances.length > 0) {
        const instanceData = new Float32Array(this.lineInstances.length * 8);
        for (let i = 0; i < this.lineInstances.length; i++) {
          const inst = this.lineInstances[i];
          const offset = i * 8;
          instanceData[offset + 0] = inst.start[0];
          instanceData[offset + 1] = inst.start[1];
          instanceData[offset + 2] = inst.end[0];
          instanceData[offset + 3] = inst.end[1];
          instanceData[offset + 4] = inst.color[0];
          instanceData[offset + 5] = inst.color[1];
          instanceData[offset + 6] = inst.color[2];
          instanceData[offset + 7] = inst.color[3];
        }

        if (!this.lineBuffer || this.lineBuffer.size < instanceData.byteLength) {
          if (this.lineBuffer) this.lineBuffer.destroy();
          this.lineBuffer = this.device.createBuffer({
            size: instanceData.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          });
        }

        this.device.queue.writeBuffer(this.lineBuffer, 0, instanceData);

        const lineUniformBindGroup = this.device.createBindGroup({
          layout: this.linePipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: this.core.projectionBuffer,
              },
            },
          ],
        });
        
        renderPass.setPipeline(this.linePipeline);
        renderPass.setBindGroup(0, lineUniformBindGroup);
        renderPass.setVertexBuffer(0, this.lineBuffer);
        renderPass.draw(2, this.lineInstances.length); // 2 vertices per line
      }
    }

    // Get rendering statistics
    getStats() {
      return {
        rectangles: this.rectInstances.length,
        triangles: this.triangleInstances.length,
        lines: this.lineInstances.length,
        totalPolygons: this.rectInstances.length + this.triangleInstances.length + this.lineInstances.length,
      };
    }
  }

  // -----------------------------
  // Genomeshader bootstrap
  // -----------------------------
  // Store lazy loading status to display in HUD
  window._genomeshaderLazyStatus = null;
  
  function showError(message) {
    window._genomeshaderLazyStatus = { type: 'error', message };
    updateHUDWithStatus();
    console.error(message);
  }
  
  function showInfo(message) {
    window._genomeshaderLazyStatus = { type: 'info', message };
    updateHUDWithStatus();
    console.log(message);
  }
  
  function updateHUDWithStatus() {
    const hudEl = document.getElementById('hud');
    if (!hudEl || !window._genomeshaderLazyStatus) return;
    
    const status = window._genomeshaderLazyStatus;
    const statusColor = status.type === 'error' ? 'var(--accent)' : 'var(--text)';
    const statusBorder = status.type === 'error' ? 'var(--accent)' : 'var(--border)';
    
    // Get current locus text if state is available
    // Note: state is defined later in the script, so we'll update HUD with locus later
    // For now, just show the status message
    hudEl.innerHTML = `<span style="color: ${statusColor}; font-weight: 500;">${status.message}</span>`;
  }
  
  // True lazy loading via postMessage
  const manifestUrl = window.GENOMESHADER_MANIFEST_URL;
  
  if (!manifestUrl) {
    showError('Missing GENOMESHADER_MANIFEST_URL');
  } else {
    console.log('Manifest URL:', manifestUrl);
    
    // Request manifest via postMessage to opener (Jupyter notebook window)
    // The opener can fetch from localhost, avoiding CORS issues
    let requestId = 0;
    const pendingRequests = new Map();
    
    function requestData(url) {
      return new Promise((resolve, reject) => {
        const id = `req_${Date.now()}_${++requestId}`;
        pendingRequests.set(id, { resolve, reject });
        
        if (!window.opener) {
          reject(new Error('No window.opener - cannot request data'));
          return;
        }
        
        // Send request to opener
        window.opener.postMessage({
          type: 'genomeshader_fetch',
          requestId: id,
          url: url
        }, '*');
        
        // Set timeout
        setTimeout(() => {
          if (pendingRequests.has(id)) {
            pendingRequests.delete(id);
            reject(new Error('Request timeout'));
          }
        }, 30000); // 30 second timeout
      });
    }
    
    // Listen for responses from opener
    window.addEventListener('message', function(event) {
      // Only accept messages from opener
      if (event.source !== window.opener) {
        return;
      }
      
      const data = event.data;
      if (data && data.type === 'genomeshader_fetch_response') {
        const request = pendingRequests.get(data.requestId);
        if (request) {
          pendingRequests.delete(data.requestId);
          if (data.success) {
            request.resolve(data.data);
          } else {
            request.reject(new Error(data.error || 'Fetch failed'));
          }
        }
      }
    });
    
    // Request manifest
    requestData(manifestUrl)
      .then(manifest => {
        console.log('Loaded manifest via postMessage:', manifest);
        
        // Compute track URL
        const baseUrl = manifestUrl.slice(0, manifestUrl.lastIndexOf('/') + 1);
        const trackUrl = baseUrl + manifest.tracks.demo.url;
        console.log('Track URL:', trackUrl);
        
        // Request track file
        return requestData(trackUrl)
          .then(trackData => {
            console.log('Loaded track data via postMessage:', trackData);
            const recordCount = Array.isArray(trackData) ? trackData.length : 0;
            showInfo(`Run ID: ${manifest.run_id}<br>Loaded ${recordCount} records`);
          })
          .catch(error => {
            console.error('Track fetch error:', error);
            showError(`Failed to load track: ${error.message}`);
          });
      })
      .catch(error => {
        console.error('Manifest fetch error:', error);
        showError(`Failed to load manifest: ${error.message}`);
      });
  }

  // -----------------------------
  // Jupyter Comms Test - REMOVED
  // This test code has been removed as it was showing unwanted dialogs
  // -----------------------------

  // -----------------------------
  // Theme + menu
  // -----------------------------
  const app = document.querySelector(".app");
  const sidebar = document.getElementById("sidebar");
  const menuBtn = document.getElementById("menuBtn");
  const ctxMenu = document.getElementById("ctxMenu");
  const themeItem = document.getElementById("themeItem");
  const themeLabel = document.getElementById("themeLabel");
  const orientationItem = document.getElementById("orientationItem");
  const orientationLabel = document.getElementById("orientationLabel");

  // Sidebar collapse/expand
  function getSidebarCollapsed() {
    return localStorage.getItem("genomeshader.sidebarCollapsed") === "true";
  }
  function setSidebarCollapsed(collapsed) {
    localStorage.setItem("genomeshader.sidebarCollapsed", String(collapsed));
    updateSidebarState();
  }
  function updateSidebarState() {
    const collapsed = getSidebarCollapsed();
    if (collapsed) {
      app.classList.add("sidebar-collapsed");
    } else {
      app.classList.remove("sidebar-collapsed");
    }
  }
  
  // Make sidebar border clickable
  sidebar.addEventListener("click", (e) => {
    const collapsed = getSidebarCollapsed();
    const rect = sidebar.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    
    // Check if click is within 12px of the right edge (or anywhere if collapsed)
    if (collapsed) {
      // When collapsed, the entire 12px strip is clickable
      setSidebarCollapsed(false);
    } else if (clickX >= rect.width - 12) {
      // When open, only the right 12px edge is clickable
      setSidebarCollapsed(true);
    }
  });
  
  updateSidebarState();

  function getStoredTheme() {
    return localStorage.getItem("genomeshader.theme"); // "dark" | "light" | "auto" | null
  }
  function setTheme(theme) {
    document.documentElement.setAttribute("data-theme", theme);
    localStorage.setItem("genomeshader.theme", theme);
    updateThemeLabel();
  }
  function updateThemeLabel() {
    const t = document.documentElement.getAttribute("data-theme") || "auto";
    themeLabel.textContent = t === "auto" ? "Auto" : (t === "light" ? "Light" : "Dark");
  }
  function getStoredOrientation() {
    return localStorage.getItem("genomeshader.orientation"); // "horizontal" | "vertical" | null
  }
  function setOrientation(o) {
    localStorage.setItem("genomeshader.orientation", o);
    updateOrientationState();
  }
  function updateOrientationState() {
    const o = getStoredOrientation() ?? "horizontal";
    // Apply on the main pane so CSS can target all track contents
    main.classList.toggle("vertical", o === "vertical");
    orientationLabel.textContent = (o === "vertical") ? "Vertical" : "Horizontal";
  }
  function isVerticalMode() {
    return (getStoredOrientation() ?? "horizontal") === "vertical";
  }
  function getStoredVariantLayoutMode() {
    return localStorage.getItem("genomeshader.variantLayoutMode"); // "equidistant" | "genomic" | null
  }
  function setVariantLayoutMode(mode) {
    localStorage.setItem("genomeshader.variantLayoutMode", mode);
    state.variantLayoutMode = mode;
    updateVariantLayoutModeLabel();
  }
  function updateVariantLayoutModeLabel() {
    const mode = state.variantLayoutMode || "equidistant";
    const labelEl = document.getElementById("variantLayoutModeLabel");
    if (labelEl) {
      labelEl.textContent = mode === "equidistant" ? "Equidistant" : "Genomic";
    }
  }
  function getVariantLayoutMode() {
    return state.variantLayoutMode || "equidistant";
  }

  const stored = getStoredTheme();
  document.documentElement.setAttribute("data-theme", stored ?? "auto");
  updateThemeLabel();

  function openMenu() {
    // Anchor menu above the gear in the sidebar (now bottom-left)
    const r = menuBtn.getBoundingClientRect();
    const s = sidebar.getBoundingClientRect();
    const left = Math.max(8, r.left - s.left);
    const top  = Math.max(8, r.top  - s.top  - 160);
    ctxMenu.style.left = `${left}px`;
    ctxMenu.style.top  = `${top}px`;
    ctxMenu.classList.add("open");
    ctxMenu.setAttribute("aria-hidden", "false");
    // Update variant layout mode label when menu opens
    updateVariantLayoutModeLabel();
  }
  function closeMenu() {
    ctxMenu.classList.remove("open");
    ctxMenu.setAttribute("aria-hidden", "true");
  }
  function toggleMenu() {
    ctxMenu.classList.contains("open") ? closeMenu() : openMenu();
  }

  menuBtn.addEventListener("click", (e) => { e.stopPropagation(); toggleMenu(); });
  document.addEventListener("click", () => closeMenu());
  ctxMenu.addEventListener("click", (e) => e.stopPropagation());

  themeItem.addEventListener("click", () => {
    const cur = document.documentElement.getAttribute("data-theme") || "auto";
    const next = cur === "dark" ? "light" : (cur === "light" ? "auto" : "dark");
    setTheme(next);
    renderAll();
  });

  orientationItem.addEventListener("click", () => {
    const cur = getStoredOrientation() ?? "horizontal";
    const next = (cur === "horizontal") ? "vertical" : "horizontal";
    setOrientation(next);
    renderAll();
  });

  // Variant layout mode toggle in settings menu
  const variantLayoutModeItem = document.getElementById("variantLayoutModeItem");
  
  variantLayoutModeItem.addEventListener("click", () => {
    const cur = getVariantLayoutMode();
    const next = (cur === "equidistant") ? "genomic" : "equidistant";
    setVariantLayoutMode(next);
    renderAll();
  });

  const mq = window.matchMedia?.("(prefers-color-scheme: light)");
  mq?.addEventListener?.("change", () => {
    if ((document.documentElement.getAttribute("data-theme") || "auto") === "auto") {
      updateThemeLabel();
      renderAll();
    }
  });

  // -----------------------------
  // ViewState
  // -----------------------------
  const state = {
    contig: "chr1",
    startBp: 100_000,
    endBp:   100_900,
    pxPerBp: 1,

    firstVariantIndex: 0,
    K: 8,
    hoveredVariantIndex: null, // index of hovered variant, or null
    expandedInsertions: new Set(), // Set of variant IDs that have expanded insertions
    hoveredRepeatTooltip: null, // { text, x, y } or null

    // interaction
    dragging: false,
    lastX: 0,
    lastY: 0,

    // touch pinch
    pointers: new Map(),     // pointerId -> {x,y}
    pinchStartDist: null,
    pinchStartSpan: null,
    pinchAnchorBp: null,

    // track management
    tracks: [
      { id: "ideogram", label: "Chromosome", collapsed: false, height: 38, minHeight: 20 },
      { id: "genes", label: "Genes", collapsed: false, height: 110, minHeight: 30 },
      { id: "repeats", label: "RepeatMasker", collapsed: false, height: 50, minHeight: 30 },
      { id: "ruler", label: "Locus", collapsed: false, height: 68, minHeight: 40 },
      { id: "reference", label: "Reference", collapsed: false, height: 40, minHeight: 30 },
      { id: "flow", label: "Variants/Haplotypes", collapsed: false, height: 300, minHeight: 100 },
      { id: "reads", label: "Reads", collapsed: false, height: 220, minHeight: 50 }
    ],
    trackDragState: null,  // { trackId, startX, startY, offsetX, offsetY }
    trackResizeState: null, // { trackId, startX, startY, startHeight }
    
    // variant layout mode: "equidistant" or "genomic"
    variantLayoutMode: null // will be initialized from localStorage
  };

  // Initialize variant layout mode
  const storedVariantMode = getStoredVariantLayoutMode();
  state.variantLayoutMode = storedVariantMode ?? "equidistant";
  // Initialize label after DOM is ready
  setTimeout(() => updateVariantLayoutModeLabel(), 0);

  // Chromosome lengths for bounds checking
  const chrLengths = {
    "chr1": 248_956_422,
    "chr2": 242_193_529,
    "chr3": 198_295_559,
    "chr4": 190_214_555,
    "chr5": 181_538_259,
    "chr6": 170_805_979,
    "chr7": 159_345_973,
    "chr8": 145_138_636,
    "chr9": 138_394_717,
    "chr10": 133_797_422,
    "chr11": 135_086_622,
    "chr12": 133_275_309,
    "chr13": 114_364_328,
    "chr14": 107_043_718,
    "chr15": 101_991_189,
    "chr16": 90_338_345,
    "chr17": 83_257_441,
    "chr18": 80_373_285,
    "chr19": 58_617_616,
    "chr20": 64_444_167,
    "chr21": 46_709_983,
    "chr22": 50_818_468,
    "chrX": 156_040_895,
    "chrY": 57_227_415
  };

  // Helper function to get chromosome length for current contig
  function getChromosomeLength() {
    return chrLengths[state.contig] || 248_956_422;
  }

  // Helper function to clamp startBp and endBp to chromosome boundaries
  function clampToChromosomeBounds() {
    const chrLength = getChromosomeLength();
    const span = state.endBp - state.startBp;
    
    // Clamp startBp to [0, chrLength - span]
    state.startBp = Math.max(0, Math.min(state.startBp, chrLength - span));
    
    // Ensure endBp doesn't exceed chromosome length
    state.endBp = Math.min(state.startBp + span, chrLength);
    
    // If span is larger than chromosome, center it
    if (span > chrLength) {
      state.startBp = 0;
      state.endBp = chrLength;
    }
  }

  // Initialize state from GENOMESHADER_CONFIG if available
  let dataBounds = null;
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.region) {
    const region = window.GENOMESHADER_CONFIG.region;
    // Parse region string format: "chr1:100000-200000"
    const match = region.match(/^([^:]+):(\d+)-(\d+)$/);
    if (match) {
      state.contig = match[1];
      state.startBp = parseInt(match[2], 10);
      state.endBp = parseInt(match[3], 10);
    }
    
    // Store data bounds if available (where actual read data exists)
    if (window.GENOMESHADER_CONFIG.data_bounds) {
      dataBounds = {
        start: window.GENOMESHADER_CONFIG.data_bounds.start,
        end: window.GENOMESHADER_CONFIG.data_bounds.end
      };
    }
  }

  const main = document.getElementById("main");
  const tracksSvg = document.getElementById("tracksSvg");
  const flow = document.getElementById("flow");
  const reads = document.getElementById("reads");
  const flowCanvas = document.getElementById("flowCanvas");
  const readsCanvas = document.getElementById("readsCanvas");
  const hud = document.getElementById("hud");
  const tooltip = document.getElementById("tooltip");
  const tracksWebGPU = document.getElementById("tracksWebGPU");

  // Initialize WebGPU infrastructure
  let webgpuCore = null;
  let instancedRenderer = null;
  let webgpuSupported = false;
  let repeatHitTestData = []; // For tooltip hit testing

  async function initWebGPU() {
    if (!navigator.gpu) {
      console.warn("WebGPU not supported, falling back to SVG rendering");
      if (tracksWebGPU) tracksWebGPU.style.display = 'none';
      return false;
    }

    try {
      webgpuCore = new WebGPUCore();
      await webgpuCore.init(tracksWebGPU);
      instancedRenderer = new InstancedRenderer(webgpuCore);
      webgpuSupported = true;
      console.log("WebGPU initialized successfully");
      return true;
    } catch (error) {
      console.warn("Failed to initialize WebGPU:", error);
      if (tracksWebGPU) tracksWebGPU.style.display = 'none';
      return false;
    }
  }

  // Initialize WebGPU (async, but don't block rendering)
  initWebGPU().catch(err => {
    console.error("WebGPU initialization error:", err);
  });

  // Initialize orientation state after DOM elements are available
  updateOrientationState();

  function rectW(el) { return el.getBoundingClientRect().width; }
  function rectH(el) { return el.getBoundingClientRect().height; }

  function tracksWidthPx() { return tracksSvg.getBoundingClientRect().width; }
  function flowWidthPx()   { return rectW(flow); }
  function flowHeightPx()  { return rectH(flow); }
  function readsWidthPx()  { return rectW(reads); }
  function readsHeightPx() { return rectH(reads); }

  function cssVar(name) {
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }

  function updateDerived() {
    const span = state.endBp - state.startBp;
    if (isVerticalMode()) {
      const h = tracksHeightPx();
      state.pxPerBp = h / span;
    } else {
      const w = tracksWidthPx();
      state.pxPerBp = w / span;
    }
  }

  // Calculate total insertion gap width for expanded insertions (in pixels)
  function getTotalInsertionGapWidth() {
    let totalGap = 0;
    for (const variant of variants) {
      if (state.expandedInsertions.has(variant.id) && isInsertion(variant)) {
        const maxInsertLen = getMaxInsertionLength(variant);
        // Each inserted base gets 8px width
        totalGap += maxInsertLen * 8;
      }
    }
    return totalGap;
  }
  
  // IMPORTANT: canonical genome-x mapping for the right pane (tracks/canvases)
  // Accounts for expanded insertion gaps
  function xGenomeCanonical(bp, W) {
    const leftPad = 16, rightPad = 16;
    const innerW = W - leftPad - rightPad;
    const span = state.endBp - state.startBp;
    const totalGapPx = getTotalInsertionGapWidth();
    const totalGapBp = totalGapPx / state.pxPerBp;
    const effectiveSpan = span + totalGapBp;
    
    // Calculate x position, accounting for insertion gaps before this position
    let accumulatedGapPx = 0;
    for (const variant of variants) {
      if (variant.pos < bp && state.expandedInsertions.has(variant.id) && isInsertion(variant)) {
        const maxInsertLen = getMaxInsertionLength(variant);
        accumulatedGapPx += maxInsertLen * 8;
      }
    }
    
    const bpOffset = bp - state.startBp;
    const accumulatedGapBp = accumulatedGapPx / state.pxPerBp;
    const normalizedPos = (bpOffset + accumulatedGapBp) / effectiveSpan;
    
    return leftPad + normalizedPos * innerW;
  }
  
  function xGenome(bp) {
    return xGenomeCanonical(bp, tracksWidthPx());
  }
  
  function bpFromXGenome(xPx, W) {
    const leftPad = 16, rightPad = 16;
    const innerW = W - leftPad - rightPad;
    const span = state.endBp - state.startBp;
    const totalGapPx = getTotalInsertionGapWidth();
    const totalGapBp = totalGapPx / state.pxPerBp;
    const effectiveSpan = span + totalGapBp;
    const t = (xPx - leftPad) / innerW;
    
    // Reverse calculation accounting for gaps - iterative refinement
    let bpEstimate = state.startBp + t * effectiveSpan;
    for (let iter = 0; iter < 5; iter++) {
      let accumulatedGapPx = 0;
      for (const variant of variants) {
        if (variant.pos < bpEstimate && state.expandedInsertions.has(variant.id) && isInsertion(variant)) {
          const maxInsertLen = getMaxInsertionLength(variant);
          accumulatedGapPx += maxInsertLen * 8;
        }
      }
      const accumulatedGapBp = accumulatedGapPx / state.pxPerBp;
      bpEstimate = state.startBp + (t * effectiveSpan) - accumulatedGapBp;
    }
    
    return bpEstimate;
  }

  // Vertical mode coordinate mapping (genomic axis vertical: bottom=start, top=end)
  function yGenomeCanonical(bp, H) {
    const topPad = 16, bottomPad = 16;
    const innerH = H - topPad - bottomPad;
    const span = state.endBp - state.startBp;
    const totalGapPx = getTotalInsertionGapWidth();
    const totalGapBp = totalGapPx / state.pxPerBp;
    const effectiveSpan = span + totalGapBp;
    
    // Calculate y position, accounting for insertion gaps before this position
    let accumulatedGapPx = 0;
    for (const variant of variants) {
      if (variant.pos < bp && state.expandedInsertions.has(variant.id) && isInsertion(variant)) {
        const maxInsertLen = getMaxInsertionLength(variant);
        accumulatedGapPx += maxInsertLen * 8;
      }
    }
    
    const bpOffset = bp - state.startBp;
    const accumulatedGapBp = accumulatedGapPx / state.pxPerBp;
    const normalizedPos = (bpOffset + accumulatedGapBp) / effectiveSpan;
    
    // Invert: bottom (H - bottomPad) = start, top (topPad) = end
    return H - bottomPad - normalizedPos * innerH;
  }
  
  function yGenome(bp) {
    return yGenomeCanonical(bp, tracksHeightPx());
  }
  
  function tracksHeightPx() {
    return tracksSvg.getBoundingClientRect().height;
  }
  
  function bpFromYGenome(yPx, H) {
    const topPad = 16, bottomPad = 16;
    const innerH = H - topPad - bottomPad;
    const span = state.endBp - state.startBp;
    const totalGapPx = getTotalInsertionGapWidth();
    const totalGapBp = totalGapPx / state.pxPerBp;
    const effectiveSpan = span + totalGapBp;
    
    // Invert: yPx is from top, but we want position from bottom
    const normalizedPos = (H - bottomPad - yPx) / innerH;
    const t = Math.max(0, Math.min(1, normalizedPos));
    
    // Reverse calculation accounting for gaps - iterative refinement
    let bpEstimate = state.startBp + t * effectiveSpan;
    for (let iter = 0; iter < 5; iter++) {
      let accumulatedGapPx = 0;
      for (const variant of variants) {
        if (variant.pos < bpEstimate && state.expandedInsertions.has(variant.id) && isInsertion(variant)) {
          const maxInsertLen = getMaxInsertionLength(variant);
          accumulatedGapPx += maxInsertLen * 8;
        }
      }
      const accumulatedGapBp = accumulatedGapPx / state.pxPerBp;
      bpEstimate = state.startBp + (t * effectiveSpan) - accumulatedGapBp;
    }
    
    return bpEstimate;
  }

  function xColumn(i, totalColumns) {
    const W = flowWidthPx();
    const margin = 60;
    const innerW = Math.max(10, W - 2*margin);
    const numCols = totalColumns !== undefined ? totalColumns : state.K;
    if (numCols <= 1) return margin;
    return margin + (i / (numCols - 1)) * innerW;
  }
  function yColumn(i, totalColumns) {
    const H = flowHeightPx();
    const margin = 60;
    const innerH = Math.max(10, H - 2*margin);
    const numCols = totalColumns !== undefined ? totalColumns : state.K;
    if (numCols <= 1) return margin;
    // Invert: index 0 (earliest variant) should be at bottom (higher Y), 
    // last index (latest variant) should be at top (lower Y)
    return margin + innerH - (i / (numCols - 1)) * innerH;
  }

  // -----------------------------
  // Demo data
  // -----------------------------
  const variants = [
    { id: "v1", pos: 100_120, alleles: ["ref","a1"], refAllele: "A", altAlleles: ["A" + "ATCGATCGATCGATCGATCGATCGATCGAT"] }, // insertion example (30 bp inserted: ATCGATCGATCGATCGATCGATCGATCGAT)
    { id: "v2", pos: 100_240, alleles: ["ref","a1"] },
    { id: "v3", pos: 100_410, alleles: ["ref","a1","a2"] },
    { id: "v4", pos: 100_610, alleles: ["ref","a1"] },
    { id: "v5", pos: 100_720, alleles: ["ref","a1"] },
    { id: "v6", pos: 100_780, alleles: ["ref","a1"] },
    { id: "v7", pos: 100_860, alleles: ["ref","a1"] },
    { id: "v8", pos: 100_895, alleles: ["ref","a1"] },
    { id: "v9", pos: 100_930, alleles: ["ref","a1"] },
  ];
  
  // Helper to check if variant is an insertion
  function isInsertion(variant) {
    if (!variant.refAllele || !variant.altAlleles) return false;
    const refLen = variant.refAllele.length;
    return variant.altAlleles.some(alt => alt.length > refLen);
  }
  
  // Get the longest insertion allele length for a variant
  function getMaxInsertionLength(variant) {
    if (!variant.refAllele || !variant.altAlleles) return 0;
    const refLen = variant.refAllele.length;
    return Math.max(...variant.altAlleles.map(alt => Math.max(0, alt.length - refLen)));
  }

  // Genes: load from config or use empty array as fallback
  let transcripts = [];
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.transcripts_data) {
    const data = window.GENOMESHADER_CONFIG.transcripts_data;
    // Data should already be an array of transcript objects
    if (Array.isArray(data)) {
      transcripts = data;
      console.log(`Loaded ${transcripts.length} transcripts for genes track`);
    } else {
      console.warn("Transcripts data is not in expected array format:", data);
    }
  } else {
    console.warn("No transcripts_data found in GENOMESHADER_CONFIG:", window.GENOMESHADER_CONFIG);
  }

  // RepeatMasker: load from config or use empty array as fallback
  let repeats = [];
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.repeats_data) {
    const data = window.GENOMESHADER_CONFIG.repeats_data;
    // Data should already be an array of repeat objects with start, end, cls
    if (Array.isArray(data)) {
      repeats = data;
      console.log(`Loaded ${repeats.length} repeats for RepeatMasker track`);
    } else {
      console.warn("Repeats data is not in expected array format:", data);
    }
  } else {
    console.warn("No repeats_data found in GENOMESHADER_CONFIG:", window.GENOMESHADER_CONFIG);
  }

  // Reference sequence: load from config or use empty string as fallback
  let referenceSequence = "";
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.reference_data) {
    const data = window.GENOMESHADER_CONFIG.reference_data;
    // Data should be a string containing the DNA sequence
    if (typeof data === 'string') {
      referenceSequence = data;
      console.log(`Loaded reference sequence of length ${referenceSequence.length} bases`);
    } else {
      console.warn("Reference data is not in expected string format:", data);
    }
  } else {
    console.warn("No reference_data found in GENOMESHADER_CONFIG:", window.GENOMESHADER_CONFIG);
  }

  // -----------------------------
  // SVG helpers
  // -----------------------------
  const SVGNS = "http://www.w3.org/2000/svg";
  function clearSvg(svg) { while (svg.firstChild) svg.removeChild(svg.firstChild); }
  function el(tag, attrs = {}, text = null) {
    const n = document.createElementNS(SVGNS, tag);
    for (const [k,v] of Object.entries(attrs)) n.setAttribute(k, String(v));
    if (text !== null) n.textContent = text;
    return n;
  }

  // -----------------------------
  // "Nice" tick selection for ruler
  // -----------------------------
  function trimZeros(s) {
    return s.replace(/\.0+$/, "").replace(/(\.\d*[1-9])0+$/, "$1");
  }
  function formatBp(bp, spanBp = null) {
    // Determine precision based on span if provided
    let kbPrecision = 1;
    
    if (spanBp !== null) {
      if (spanBp < 100) {
        // Very zoomed in - show full base pair position with commas
        return `${Math.round(bp).toLocaleString()} bp`;
      } else if (spanBp < 1_000) {
        // Zoomed in - show more decimal places for kb
        kbPrecision = 2;
      } else if (spanBp < 10_000) {
        // Moderately zoomed - show 2 decimal places
        kbPrecision = 2;
      } else {
        // Normal zoom - show 1 decimal place
        kbPrecision = 1;
      }
    }
    
    if (bp >= 1_000_000) return `${trimZeros((bp / 1_000_000).toFixed(2))} Mb`;
    if (bp >= 1_000)     return `${trimZeros((bp / 1_000).toFixed(kbPrecision))} kb`;
    return `${bp} bp`;
  }
  function chooseNiceTickBp(spanBp, desiredTicks) {
    const target = spanBp / desiredTicks;
    const pow = Math.pow(10, Math.floor(Math.log10(target)));
    const candidates = [1,2,5,10].map(m => m*pow);
    let best = candidates[0], bestDiff = Infinity;
    for (const c of candidates) {
      const diff = Math.abs((spanBp / c) - desiredTicks);
      if (diff < bestDiff) { bestDiff = diff; best = c; }
    }
    return best;
  }

  // -----------------------------
  // Track layout calculation
  // -----------------------------
  function getTrackLayout() {
    const layout = [];
    const headerH = 24;
    const padding = 8;
    const isVertical = isVerticalMode();

    if (isVertical) {
      // Vertical mode: tracks side-by-side (left/width based)
      let currentX = 0;
      const mainHeight = rectH(main);
      
      for (const track of state.tracks) {
        const effectiveWidth = track.collapsed ? headerH : (headerH + track.height);
        layout.push({
          track,
          left: currentX,
          width: effectiveWidth,
          contentLeft: currentX + headerH,
          contentWidth: track.collapsed ? 0 : track.height,
          // Also include top/height for compatibility
          top: 0,
          height: mainHeight,
          contentTop: 0,
          contentHeight: mainHeight
        });
        currentX += effectiveWidth; // no gap between tracks
      }
    } else {
      // Horizontal mode: tracks stacked vertically (top/height based)
      let currentY = 0;
      
      for (const track of state.tracks) {
        const effectiveHeight = track.collapsed ? headerH : (headerH + track.height);
        layout.push({
          track,
          top: currentY,
          height: effectiveHeight,
          contentTop: currentY + headerH,
          contentHeight: track.collapsed ? 0 : track.height,
          // Also include left/width for compatibility
          left: 0,
          width: rectW(main),
          contentLeft: 0,
          contentWidth: rectW(main)
        });
        currentY += effectiveHeight; // no gap between tracks
      }
    }

    return layout;
  }

  function updateTracksHeight() {
    const layout = getTrackLayout();
    const isVertical = isVerticalMode();
    // Exclude flow and reads from tracks height/width since they're positioned separately
    const tracksLayout = layout.filter(l => l.track.id !== "flow" && l.track.id !== "reads");
    if (isVertical) {
      const totalW = tracksLayout.length > 0 
        ? tracksLayout[tracksLayout.length - 1].left + tracksLayout[tracksLayout.length - 1].width
        : 0;
      // In vertical mode, tracks are side-by-side, so we don't need to set --tracks-h
      // But we might want to set a width variable if needed
    } else {
      const totalH = tracksLayout.length > 0 
        ? tracksLayout[tracksLayout.length - 1].top + tracksLayout[tracksLayout.length - 1].height
        : 0;
      document.documentElement.style.setProperty('--tracks-h', `${totalH}px`);
    }
  }

  // -----------------------------
  // Tracks rendering (ideogram + genes + repeats + ruler)
  // -----------------------------
  function renderTracks() {
    clearSvg(tracksSvg);
    // Clear WebGPU renderer instances
    if (instancedRenderer) {
      instancedRenderer.clear();
    }
    repeatHitTestData = [];
    
    const isVertical = isVerticalMode();
    const W = isVertical ? tracksHeightPx() : tracksWidthPx();
    const H = isVertical ? tracksWidthPx() : tracksHeightPx();
    const layout = getTrackLayout();
    
    // Coordinate mapping functions based on orientation
    const genomePos = isVertical ? yGenome.bind(null) : xGenome.bind(null);
    const genomePosCanonical = isVertical 
      ? (bp) => yGenomeCanonical(bp, H)
      : (bp) => xGenomeCanonical(bp, W);
    
    // Find track positions (needed to exclude ideogram from shading)
    const ideogramLayout = layout.find(l => l.track.id === "ideogram");
    const genesLayout = layout.find(l => l.track.id === "genes");
    const repeatsLayout = layout.find(l => l.track.id === "repeats");
    const rulerLayout = layout.find(l => l.track.id === "ruler");
    const referenceLayout = layout.find(l => l.track.id === "reference");
    const flowLayout = layout.find(l => l.track.id === "flow");
    const readsLayout = layout.find(l => l.track.id === "reads");
    
    // Calculate ideogram track bounds to exclude from shading (including track controls header)
    let ideogramTrackStart = 0;
    let ideogramTrackEnd = 0;
    if (ideogramLayout && !ideogramLayout.track.collapsed) {
      if (isVertical) {
        // In vertical mode, ideogram is on the left side (x-axis)
        // Use left/width to include the track controls header area
        ideogramTrackStart = ideogramLayout.left;
        ideogramTrackEnd = ideogramLayout.left + ideogramLayout.width;
      } else {
        // In horizontal mode, ideogram is at the top (y-axis)
        // Use top/height to include the track controls header area
        ideogramTrackStart = ideogramLayout.top;
        ideogramTrackEnd = ideogramLayout.top + ideogramLayout.height;
      }
    }
    
    // Draw data bounds overlays across all tracks except ideogram (if data bounds exist and differ from view)
    if (dataBounds && (dataBounds.start > state.startBp || dataBounds.end < state.endBp)) {
      const dataStartPos = genomePos(dataBounds.start);
      const dataEndPos = genomePos(dataBounds.end);
      
      // Find the tracks container bounds
      const tracksContainer = document.getElementById("tracksContainer");
      if (tracksContainer) {
        const containerRect = tracksContainer.getBoundingClientRect();
        const svgRect = tracksSvg.getBoundingClientRect();
        
        // Helper function to draw out-of-bounds shading (darker)
        const drawOutOfBoundsRect = (x, y, width, height) => {
          tracksSvg.appendChild(el("rect", {
            x: x,
            y: y,
            width: width,
            height: height,
            fill: "rgba(127,127,127,0.15)", // Darker for out-of-bounds
            "pointer-events": "none",
            "class": "data-bounds-overlay"
          }));
        };
        
        // Helper function to draw in-bounds shading (lighter)
        const drawInBoundsRect = (x, y, width, height) => {
          tracksSvg.appendChild(el("rect", {
            x: x,
            y: y,
            width: width,
            height: height,
            fill: "rgba(255,255,255,0.02)", // Very light for in-bounds
            "pointer-events": "none",
            "class": "data-bounds-overlay"
          }));
        };
        
        if (isVertical) {
          // In vertical mode, Y axis is inverted: bottom (higher Y) = smaller bp, top (lower Y) = larger bp
          // dataStartPos = Y position of dataBounds.start (smaller bp → higher Y, near bottom)
          // dataEndPos = Y position of dataBounds.end (larger bp → lower Y, near top)
          // In-bounds region is between dataEndPos (top) and dataStartPos (bottom)
          const inBoundsY1 = Math.min(dataStartPos, dataEndPos);  // top of in-bounds (smaller Y)
          const inBoundsY2 = Math.max(dataStartPos, dataEndPos);  // bottom of in-bounds (larger Y)
          if (ideogramTrackEnd > 0) {
            // Left side of ideogram track
            if (ideogramTrackStart > 0 && inBoundsY2 > inBoundsY1) {
              drawInBoundsRect(0, inBoundsY1, ideogramTrackStart, inBoundsY2 - inBoundsY1);
            }
            // Right side of ideogram track
            if (ideogramTrackEnd < W && inBoundsY2 > inBoundsY1) {
              drawInBoundsRect(ideogramTrackEnd, inBoundsY1, W - ideogramTrackEnd, inBoundsY2 - inBoundsY1);
            }
          } else {
            // No ideogram track, draw full width
            if (inBoundsY2 > inBoundsY1) {
              drawInBoundsRect(0, inBoundsY1, W, inBoundsY2 - inBoundsY1);
            }
          }
          
          // Out-of-bounds region below data (smaller bp than dataBounds.start)
          // dataBounds.start > state.startBp means view extends to show bp < dataBounds.start
          // In vertical mode: smaller bp → higher Y → bottom of screen
          // So out-of-bounds is from dataStartPos to H (bottom)
          if (dataBounds.start > state.startBp) {
            const overlayY1 = Math.max(dataStartPos, 0);
            const overlayY2 = H;
            if (overlayY2 > overlayY1) {
              if (ideogramTrackEnd > 0) {
                // Left side of ideogram track
                if (ideogramTrackStart > 0) {
                  drawOutOfBoundsRect(0, overlayY1, ideogramTrackStart, overlayY2 - overlayY1);
                }
                // Right side of ideogram track
                if (ideogramTrackEnd < W) {
                  drawOutOfBoundsRect(ideogramTrackEnd, overlayY1, W - ideogramTrackEnd, overlayY2 - overlayY1);
                }
              } else {
                // No ideogram track, draw full width
                drawOutOfBoundsRect(0, overlayY1, W, overlayY2 - overlayY1);
              }
            }
          }
          
          // Out-of-bounds region above data (larger bp than dataBounds.end)
          // dataBounds.end < state.endBp means view extends to show bp > dataBounds.end
          // In vertical mode: larger bp → lower Y → top of screen
          // So out-of-bounds is from 0 to dataEndPos (top)
          if (dataBounds.end < state.endBp) {
            const overlayY1 = 0;
            const overlayY2 = Math.min(dataEndPos, H);
            if (overlayY2 > overlayY1) {
              if (ideogramTrackEnd > 0) {
                // Left side of ideogram track
                if (ideogramTrackStart > 0) {
                  drawOutOfBoundsRect(0, overlayY1, ideogramTrackStart, overlayY2 - overlayY1);
                }
                // Right side of ideogram track
                if (ideogramTrackEnd < W) {
                  drawOutOfBoundsRect(ideogramTrackEnd, overlayY1, W - ideogramTrackEnd, overlayY2 - overlayY1);
                }
              } else {
                // No ideogram track, draw full width
                drawOutOfBoundsRect(0, overlayY1, W, overlayY2 - overlayY1);
              }
            }
          }
        } else {
          // Horizontal mode - exclude ideogram track area
          // In-bounds region - light shading
          const inBoundsX1 = dataStartPos;
          const inBoundsX2 = dataEndPos;
          if (ideogramTrackEnd > 0) {
            // Top side of ideogram track
            if (ideogramTrackStart > 0 && inBoundsX2 > inBoundsX1) {
              drawInBoundsRect(inBoundsX1, 0, inBoundsX2 - inBoundsX1, ideogramTrackStart);
            }
            // Bottom side of ideogram track
            if (ideogramTrackEnd < H && inBoundsX2 > inBoundsX1) {
              drawInBoundsRect(inBoundsX1, ideogramTrackEnd, inBoundsX2 - inBoundsX1, H - ideogramTrackEnd);
            }
          } else {
            // No ideogram track, draw full height
            if (inBoundsX2 > inBoundsX1) {
              drawInBoundsRect(inBoundsX1, 0, inBoundsX2 - inBoundsX1, H);
            }
          }
          
          // Region before data start (out-of-bounds, darker)
          if (dataBounds.start > state.startBp) {
            const overlayX1 = 0;
            const overlayX2 = dataStartPos;
            if (ideogramTrackEnd > 0) {
              // Top side of ideogram track
              if (ideogramTrackStart > 0) {
                drawOutOfBoundsRect(overlayX1, 0, overlayX2 - overlayX1, ideogramTrackStart);
              }
              // Bottom side of ideogram track
              if (ideogramTrackEnd < H) {
                drawOutOfBoundsRect(overlayX1, ideogramTrackEnd, overlayX2 - overlayX1, H - ideogramTrackEnd);
              }
            } else {
              // No ideogram track, draw full height
              drawOutOfBoundsRect(overlayX1, 0, overlayX2 - overlayX1, H);
            }
          }
          
          // Region after data end (out-of-bounds, darker)
          if (dataBounds.end < state.endBp) {
            const overlayX1 = dataEndPos;
            const overlayX2 = W;
            if (ideogramTrackEnd > 0) {
              // Top side of ideogram track
              if (ideogramTrackStart > 0) {
                drawOutOfBoundsRect(overlayX1, 0, overlayX2 - overlayX1, ideogramTrackStart);
              }
              // Bottom side of ideogram track
              if (ideogramTrackEnd < H) {
                drawOutOfBoundsRect(overlayX1, ideogramTrackEnd, overlayX2 - overlayX1, H - ideogramTrackEnd);
              }
            } else {
              // No ideogram track, draw full height
              drawOutOfBoundsRect(overlayX1, 0, overlayX2 - overlayX1, H);
            }
          }
        }
      }
    }

    if (!ideogramLayout || !genesLayout || !repeatsLayout || !rulerLayout || !referenceLayout || !flowLayout || !readsLayout) return;

    // Ideogram layout
    if (!ideogramLayout.track.collapsed) {
      let ideogramX, ideogramY, ideogramW, ideogramH;
      if (isVertical) {
        ideogramX = ideogramLayout.contentLeft + 12;
        ideogramW = 16;
        // Leave space at bottom for chromosome label, start ideogram higher
        ideogramY = 16;
        // In vertical mode, ideogram spans the genomic axis (W dimension, which is SVG height)
        // Leave space at bottom (about 40px) for the chromosome label
        ideogramH = W - 32 - 40;
      } else {
        ideogramY = ideogramLayout.contentTop + 12;
        ideogramH = 16;
        ideogramX = 16;
        ideogramW = W - 32;
      }

      // --- Chromosome label
      if (isVertical) {
        // Position chromosome label at the bottom
        const labelY = W - 16;
        tracksSvg.appendChild(el("text", {
          x: ideogramX + ideogramW/2 + 1,
          y: labelY,
          class: "svg-chr",
          "text-anchor": "middle",
          "dominant-baseline": "middle",
          transform: "rotate(-90 " + (ideogramX + ideogramW/2) + " " + labelY + ")"
        }, state.contig));
      } else {
        tracksSvg.appendChild(el("text", {
          x: 16,
          y: ideogramY + ideogramH/2 + 1,
          class: "svg-chr",
          "dominant-baseline": "middle"
        }, state.contig));
      }

      // --- Ideogram (p/q arm rounded rects + cytobands clipped inside)
      const bandX = isVertical ? ideogramX : 70;
      const bandY = isVertical ? ideogramY : ideogramY;
      const bandW = isVertical ? ideogramW : (W - bandX - 16);
      // In vertical mode, bandH should use the full available height
      const bandH = isVertical ? ideogramH : ideogramH;

      // Use global chromosome lengths for mapping cytoband positions
      const chrLength = getChromosomeLength();
      
      // Get ideogram data from config (already parsed from JSON in Python)
      let ideogramData = [];
      if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.ideogram_data) {
        const data = window.GENOMESHADER_CONFIG.ideogram_data;
        // Data should already be an array, but ensure it is
        if (Array.isArray(data)) {
          ideogramData = data;
        } else {
          console.warn("Ideogram data is not in expected array format:", data);
        }
      }
      
      // Find centromere position to determine p/q arm split
      let centromereStart = null;
      let centromereEnd = null;
      for (const band of ideogramData) {
        if (band.gieStain === "acen") {
          if (centromereStart === null) {
            centromereStart = band.chromStart;
          }
          centromereEnd = band.chromEnd;
        }
      }
      
      // Calculate actual p/q arm proportions based on centromere position
      // If no centromere found, use approximate position (p-arm is typically ~48% of chromosome)
      const defaultPFrac = 0.48;
      const centromerePos = centromereStart !== null ? centromereStart : Math.floor(chrLength * defaultPFrac);
      const pFrac = centromerePos / chrLength;
      const qFrac = 1 - pFrac;

      let pX, pY, pW, pH, qX, qY, qW, qH;
      if (isVertical) {
        // In vertical mode, arms are vertical (p-arm bottom, q-arm top)
        pH = Math.max(10, Math.floor(bandH * pFrac));
        qH = Math.max(10, Math.floor(bandH * qFrac));
        pW = qW = bandW;
        pX = qX = bandX;
        pY = bandY + bandH - pH; // p-arm at bottom
        qY = bandY; // q-arm at top
      } else {
        // Horizontal mode: arms are horizontal
        pW = Math.max(10, Math.floor(bandW * pFrac));
        qW = Math.max(10, Math.floor(bandW * qFrac));
        pH = qH = bandH;
        pX = bandX;
        qX = bandX + pW;
        pY = qY = bandY;
      }

      // defs + clipPath that matches both arms
      const defs = el("defs");
      const clipId = "chrClip";
      const clip = el("clipPath", { id: clipId });

      const armStroke = "rgba(127,127,127,0.22)";
      const armFill = "rgba(127,127,127,0.12)";

      const pArm = el("rect", { x: pX, y: pY, width: pW, height: pH, rx: 9, fill: armFill, stroke: armStroke });
      const qArm = el("rect", { x: qX, y: qY, width: qW, height: qH, rx: 9, fill: armFill, stroke: armStroke });

      clip.appendChild(el("rect", { x: pX, y: pY, width: pW, height: pH, rx: 9 }));
      clip.appendChild(el("rect", { x: qX, y: qY, width: qW, height: qH, rx: 9 }));

      defs.appendChild(clip);
      tracksSvg.appendChild(defs);

      tracksSvg.appendChild(pArm);
      tracksSvg.appendChild(qArm);
      
      // Calculate p-arm and q-arm lengths in base pairs
      const pArmLength = centromerePos;
      const qArmLength = chrLength - centromerePos;
      
      const bandInnerX = isVertical ? bandX - 2 : bandX;
      const bandInnerY = isVertical ? bandY : bandY - 2;
      const bandInnerW = isVertical ? bandW + 4 : bandW;
      const bandInnerH = isVertical ? bandH : bandH + 4;
      
      // Render each cytoband
      for (const band of ideogramData) {
        const bandStart = band.chromStart;
        const bandEnd = band.chromEnd;
        const isCentromere = band.gieStain === "acen";
        const isPArm = bandEnd <= centromerePos;
        
        // Determine which arm and calculate position
        let bandPos, bandSize;
        if (isPArm) {
          // p-arm: map from 0 to pArmLength onto p-arm dimensions
          const pFracStart = bandStart / pArmLength;
          const pFracEnd = bandEnd / pArmLength;
          const pFracSize = (bandEnd - bandStart) / pArmLength;
          
          if (isVertical) {
            // p-arm is at bottom, so we go from bottom up
            bandPos = pY + pH - (pFracEnd * pH);
            bandSize = pFracSize * pH;
          } else {
            // p-arm is on left
            bandPos = pX + (pFracStart * pW);
            bandSize = pFracSize * pW;
          }
        } else {
          // q-arm: map from centromerePos to chrLength onto q-arm dimensions
          const qFracStart = (bandStart - centromerePos) / qArmLength;
          const qFracEnd = (bandEnd - centromerePos) / qArmLength;
          const qFracSize = (bandEnd - bandStart) / qArmLength;
          
          if (isVertical) {
            // q-arm is at top
            bandPos = qY + (qFracStart * qH);
            bandSize = qFracSize * qH;
          } else {
            // q-arm is on right
            bandPos = qX + (qFracStart * qW);
            bandSize = qFracSize * qW;
          }
        }
        
        // Convert color from hex to rgba for better visibility
        const color = band.color || "#808080";
        let fillColor, strokeColor, strokeWidth;
        if (isCentromere) {
          fillColor = "rgba(255,77,77,0.35)";
          strokeColor = "none";
          strokeWidth = 0;
        } else {
          // Convert hex to rgba with opacity
          const r = parseInt(color.slice(1, 3), 16);
          const g = parseInt(color.slice(3, 5), 16);
          const b = parseInt(color.slice(5, 7), 16);
          // Adjust opacity based on color intensity (darker = more opaque)
          const intensity = (r + g + b) / 3;
          const opacity = 0.1 + (1 - intensity / 255) * 0.3;
          fillColor = `rgba(${r},${g},${b},${opacity})`;
          strokeColor = "none";
          strokeWidth = 0;
        }
        
        if (isVertical) {
          tracksSvg.appendChild(el("rect", {
            x: bandInnerX,
            y: bandPos,
            width: bandInnerW,
            height: Math.max(1, bandSize),
            fill: fillColor,
            stroke: strokeColor,
            "stroke-width": strokeWidth,
            "clip-path": `url(#${clipId})`
          }));
        } else {
          tracksSvg.appendChild(el("rect", {
            x: bandPos,
            y: bandInnerY,
            width: Math.max(1, bandSize),
            height: bandInnerH,
            fill: fillColor,
            stroke: strokeColor,
            "stroke-width": strokeWidth,
            "clip-path": `url(#${clipId})`
          }));
        }
      }

      // Locus highlight - small red rectangle showing current view position
      const locusCenter = (state.startBp + state.endBp) / 2;
      const locusFrac = locusCenter / chrLength;
      
      // Determine if locus is on p-arm or q-arm
      const isLocusPArm = locusCenter <= centromerePos;
      
      if (isVertical) {
        let locusY, locusHighlightHeight = 12;
        if (isLocusPArm) {
          // p-arm is at bottom
          const pFrac = locusCenter / pArmLength;
          locusY = pY + pH - (pFrac * pH);
        } else {
          // q-arm is at top
          const qFrac = (locusCenter - centromerePos) / qArmLength;
          locusY = qY + (qFrac * qH);
        }
        const locusHighlightY = Math.max(
          isLocusPArm ? pY : qY,
          Math.min(
            (isLocusPArm ? pY + pH : qY + qH) - locusHighlightHeight,
            locusY - locusHighlightHeight / 2
          )
        );
        
        tracksSvg.appendChild(el("rect", {
          x: (isLocusPArm ? pX : qX) - 1,
          y: locusHighlightY,
          width: (isLocusPArm ? pW : qW) + 2,
          height: locusHighlightHeight,
          fill: "rgba(255,77,77,0.25)",
          stroke: "rgba(255,77,77,0.95)",
          "stroke-width": 1
        }));
      } else {
        let locusX, locusHighlightWidth = 12;
        if (isLocusPArm) {
          // p-arm is on left
          const pFrac = locusCenter / pArmLength;
          locusX = pX + (pFrac * pW);
        } else {
          // q-arm is on right
          const qFrac = (locusCenter - centromerePos) / qArmLength;
          locusX = qX + (qFrac * qW);
        }
        const locusHighlightX = Math.max(
          isLocusPArm ? pX : qX,
          Math.min(
            (isLocusPArm ? pX + pW : qX + qW) - locusHighlightWidth,
            locusX - locusHighlightWidth / 2
          )
        );
        
        tracksSvg.appendChild(el("rect", {
          x: locusHighlightX,
          y: (isLocusPArm ? pY : qY) - 1,
          width: locusHighlightWidth,
          height: (isLocusPArm ? pH : qH) + 2,
          fill: "rgba(255,77,77,0.25)",
          stroke: "rgba(255,77,77,0.95)",
          "stroke-width": 1
        }));
      }
    }

    // --- Genes track (exons/introns/strand)
    if (!genesLayout.track.collapsed) {
      let geneStartX, geneStartY, laneDim, lanes, genesDim;
      if (isVertical) {
        geneStartX = genesLayout.contentLeft + 8;
        laneDim = 30;
        lanes = 3;
        genesDim = lanes * laneDim;
        geneStartY = 16;
      } else {
        geneStartY = genesLayout.contentTop + 8;
        laneDim = 30;
        lanes = 3;
        genesDim = lanes * laneDim;
        geneStartX = 16;
      }

      for (let lane=0; lane<lanes; lane++) {
        if (isVertical) {
          const x = geneStartX + lane*laneDim + laneDim/2;
          tracksSvg.appendChild(el("line", {
            x1: x, x2: x, y1: 16, y2: H-16,
            stroke: "rgba(127,127,127,0.14)"
          }));
        } else {
          const y = geneStartY + lane*laneDim + laneDim/2;
          tracksSvg.appendChild(el("line", {
            x1: 16, x2: W-16, y1: y, y2: y,
            stroke: "rgba(127,127,127,0.14)"
          }));
        }
      }

      function drawStrandArrows(pos1, pos2, perpPos, strand, isVert) {
        const dir = strand === "-" ? -1 : 1;
        const step = 24;
        const start = Math.min(pos1, pos2), end = Math.max(pos1, pos2);
        for (let p = start + 10; p < end - 10; p += step) {
          const size = 5;
          if (isVert) {
            const cy = p;
            const p1 = `${perpPos},${cy}`;
            const p2 = `${perpPos - dir*size*0.8},${cy + dir*size}`;
            const p3 = `${perpPos + dir*size*0.8},${cy + dir*size}`;
            tracksSvg.appendChild(el("polygon", {
              points: `${p1} ${p2} ${p3}`,
              fill: "rgba(127,127,127,0.45)"
            }));
          } else {
            const cx = p;
            const p1 = `${cx},${perpPos}`;
            const p2 = `${cx - dir*size},${perpPos - size*0.8}`;
            const p3 = `${cx - dir*size},${perpPos + size*0.8}`;
            tracksSvg.appendChild(el("polygon", {
              points: `${p1} ${p2} ${p3}`,
              fill: "rgba(127,127,127,0.45)"
            }));
          }
        }
      }

    for (const t of transcripts) {
      const s = Math.max(t.start, state.startBp);
      const e = Math.min(t.end,   state.endBp);
      if (e <= state.startBp || s >= state.endBp) continue;

      let perpPos;
      if (isVertical) {
        perpPos = geneStartX + t.lane*laneDim + laneDim/2;
      } else {
        perpPos = geneStartY + t.lane*laneDim + laneDim/2;
      }

      // intron baseline (full transcript span)
      const pos1 = genomePos(s);
      const pos2 = genomePos(e);
      
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: perpPos, x2: perpPos, y1: pos1, y2: pos2,
          stroke: "rgba(127,127,127,0.40)",
          "stroke-width": 1
        }));
        drawStrandArrows(pos1, pos2, perpPos, t.strand, true);
      } else {
        tracksSvg.appendChild(el("line", {
          x1: pos1, x2: pos2, y1: perpPos, y2: perpPos,
          stroke: "rgba(127,127,127,0.40)",
          "stroke-width": 1
        }));
        drawStrandArrows(pos1, pos2, perpPos, t.strand, false);
      }

      // exons
      let firstExonY = null; // Track bottom-most exon Y position for gene name alignment in vertical mode
      let firstExonX = null; // Track first exon X position for gene name alignment in horizontal mode
      for (const [es0, ee0] of t.exons) {
        const es = Math.max(es0, state.startBp);
        const ee = Math.min(ee0, state.endBp);
        if (ee <= state.startBp || es >= state.endBp) continue;
        const exPos1 = genomePos(es);
        const exPos2 = genomePos(ee);

        if (isVertical) {
          // In vertical mode, exons are horizontal bars
          // exPos1 and exPos2 are Y coordinates, need to ensure correct ordering
          const yMin = Math.min(exPos1, exPos2);
          const yMax = Math.max(exPos1, exPos2);
          // Track the bottom-most exon's bottom Y position for gene name alignment
          // (yMax is the bottom of the exon in vertical mode where higher Y = bottom)
          // We want the highest Y value (bottom-most exon)
          if (firstExonY === null || yMax > firstExonY) {
            firstExonY = yMax;
          }
          tracksSvg.appendChild(el("rect", {
            x: perpPos - 6, y: yMin,
            width: 12, height: Math.max(2, yMax - yMin),
            rx: 4,
            fill: "var(--blueFill)",
            stroke: "var(--blue)",
            "stroke-width": 1
          }));
        } else {
          // Track the first exon's X position for gene name alignment
          if (firstExonX === null) {
            firstExonX = exPos1;
          }
          tracksSvg.appendChild(el("rect", {
            x: exPos1, y: perpPos - 6,
            width: Math.max(2, exPos2 - exPos1), height: 12,
            rx: 4,
            fill: "var(--blueFill)",
            stroke: "var(--blue)",
            "stroke-width": 1
          }));
        }
      }

      // gene label near transcript start
      if (isVertical) {
        // Gene name to the left of the gene track
        // Y position should match the bottom of the bottom-most exon
        const geneNameY = firstExonY !== null ? firstExonY : pos1;
        tracksSvg.appendChild(el("text", {
          x: perpPos - 8,
          y: geneNameY,
          class:"svg-geneName",
          "text-anchor": "start",
          "dominant-baseline": "text-after-edge",
          transform: "rotate(-90 " + (perpPos - 8) + " " + geneNameY + ")"
        }, `${t.name}`));
        // Strand indicator to the right of the gene track (just a bit to the right)
        tracksSvg.appendChild(el("text", {
          x: perpPos + 8,
          y: pos1,
          class:"svg-small",
          "text-anchor": "start",
          "dominant-baseline": "middle"
        }, t.strand === "+" ? "↑" : "↓"));
      } else {
        // In horizontal mode, X position should match the first exon's X position
        const geneNameX = firstExonX !== null ? firstExonX : pos1;
        tracksSvg.appendChild(el("text", {
          x: geneNameX,
          y: perpPos - 12,
          class:"svg-geneName"
        }, `${t.name}`));
        tracksSvg.appendChild(el("text", {
          x: pos1 + 2,
          y: perpPos + 16,
          class:"svg-small"
        }, t.strand === "+" ? "→" : "←"));
      }
    }
    }

    // --- RepeatMasker track
    if (!repeatsLayout.track.collapsed) {
      let repeatsX, repeatsY, repeatsW, repeatsH;
      if (isVertical) {
        repeatsX = repeatsLayout.contentLeft + 8;
        repeatsW = 22;
        repeatsY = 16;
        // In vertical mode, repeatsH should use W (genomic axis dimension), not H
        repeatsH = W - 32;
      } else {
        repeatsY = repeatsLayout.contentTop + 8;
        repeatsH = 22;
        repeatsX = 16;
        repeatsW = W - 32;
      }

      // background guide line
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: repeatsX + repeatsW/2, x2: repeatsX + repeatsW/2, y1: 16, y2: W-16,
          stroke: "rgba(127,127,127,0.16)"
        }));
      } else {
        tracksSvg.appendChild(el("line", {
          x1: 16, x2: W-16, y1: repeatsY + repeatsH/2, y2: repeatsY + repeatsH/2,
          stroke: "rgba(127,127,127,0.16)"
        }));
      }

    function repeatColor(cls) {
      // simple palette-ish mapping; kept subtle
      switch (cls) {
        case "SINE": return "rgba(255, 206, 86, 0.35)";
        case "LINE": return "rgba(75, 192, 192, 0.28)";
        case "LTR":  return "rgba(153, 102, 255, 0.28)";
        case "DNA":  return "rgba(255, 99, 132, 0.22)";
        default:     return "rgba(201, 203, 207, 0.22)";
      }
    }

    function repeatColorToRgba(cls) {
      const rgbaStr = repeatColor(cls);
      // Parse "rgba(255, 206, 86, 0.35)" to [r, g, b, a] normalized
      const match = rgbaStr.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
      if (match) {
        return [
          parseInt(match[1]) / 255,
          parseInt(match[2]) / 255,
          parseInt(match[3]) / 255,
          parseFloat(match[4])
        ];
      }
      return [0.5, 0.5, 0.5, 0.5]; // fallback
    }

    // Optimize repeat rendering: filter, cluster, and batch DOM operations
    // Calculate minimum pixel width (don't render repeats smaller than 1 pixel)
    const minPixelWidth = 1;
    const clusterThreshold = 5; // Cluster repeats within 5bp of each other
    const maxRepeatsToRender = 5000; // Safety limit to prevent crashes

    // Filter and prepare visible repeats
    const visibleRepeats = [];
    for (const r of repeats) {
      if (r.end <= state.startBp || r.start >= state.endBp) continue;
      const rs = Math.max(r.start, state.startBp);
      const re = Math.min(r.end, state.endBp);
      
      const pos1 = genomePos(rs);
      const pos2 = genomePos(re);
      const width = Math.abs(pos2 - pos1);
      
      // Skip repeats that are too small to render
      if (width < minPixelWidth) continue;
      
      visibleRepeats.push({
        start: rs,  // Clamped start for rendering
        end: re,   // Clamped end for rendering
        originalStart: r.start,  // Original RepeatMasker start coordinate
        originalEnd: r.end,     // Original RepeatMasker end coordinate
        cls: r.cls,
        pos1: pos1,
        pos2: pos2,
        width: width
      });
    }

    // Sort by position for clustering
    visibleRepeats.sort((a, b) => a.start - b.start);

    // Cluster nearby repeats of the same class to reduce DOM elements
    const clusteredRepeats = [];
    let currentCluster = null;
    
    for (const r of visibleRepeats) {
      if (currentCluster && 
          r.cls === currentCluster.cls &&
          r.start - currentCluster.end <= clusterThreshold) {
        // Merge into current cluster
        currentCluster.end = Math.max(currentCluster.end, r.end);
        currentCluster.originalEnd = Math.max(currentCluster.originalEnd, r.originalEnd);
        currentCluster.pos2 = genomePos(currentCluster.end);
        currentCluster.width = Math.abs(currentCluster.pos2 - currentCluster.pos1);
      } else {
        // Start new cluster
        if (currentCluster) {
          clusteredRepeats.push(currentCluster);
        }
        currentCluster = {
          start: r.start,
          end: r.end,
          originalStart: r.originalStart,
          originalEnd: r.originalEnd,
          cls: r.cls,
          pos1: r.pos1,
          pos2: r.pos2,
          width: r.width
        };
      }
    }
    if (currentCluster) {
      clusteredRepeats.push(currentCluster);
    }

    // Limit the number of elements to render (take first N if too many)
    const repeatsToRender = clusteredRepeats.slice(0, maxRepeatsToRender);
    
    if (clusteredRepeats.length > maxRepeatsToRender) {
      console.warn(`Too many repeats (${clusteredRepeats.length}), rendering only first ${maxRepeatsToRender}`);
    }

    // Store repeat data for hit testing
    repeatHitTestData = [];
    
    // Use WebGPU if available, otherwise fall back to SVG
    if (webgpuSupported && instancedRenderer) {
      // Add rectangles to WebGPU renderer
      // Scale by devicePixelRatio since WebGPU canvas uses physical pixels
      const dpr = window.devicePixelRatio || 1;
      
      for (const r of repeatsToRender) {
        const pos1 = r.pos1;
        const pos2 = r.pos2;
        const width = Math.max(1, pos2 - pos1);
        const height = repeatsH - 8;
        
        let x, y, w, h;
        if (isVertical) {
          const yMin = Math.min(pos1, pos2);
          const yMax = Math.max(pos1, pos2);
          x = repeatsX + 4;
          y = yMin;
          w = repeatsW - 8;
          h = Math.max(1, yMax - yMin);
        } else {
          x = pos1;
          y = repeatsY + 4;
          w = width;
          h = height;
        }
        
        const rgba = repeatColorToRgba(r.cls);
        // Scale coordinates by DPR to match physical pixel canvas
        instancedRenderer.addRect(x * dpr, y * dpr, w * dpr, h * dpr, rgba);
        
        // Store for hit testing (use original RepeatMasker coordinates, not clamped/clustered)
        repeatHitTestData.push({
          start: r.originalStart,
          end: r.originalEnd,
          cls: r.cls
        });
      }
    } else {
      // Fallback to SVG rendering
      const fragment = document.createDocumentFragment();
      
      for (const r of repeatsToRender) {
        const pos1 = r.pos1;
        const pos2 = r.pos2;
        const isSmall = r.width < 3; // Don't add stroke for very small elements
        
        // Format tooltip text with repeat class and original coordinates
        const tooltipText = `${r.cls} repeat\n${Math.floor(r.originalStart).toLocaleString()} - ${Math.floor(r.originalEnd).toLocaleString()}`;
        
        // Create rect element
        let rect;
        if (isVertical) {
          const yMin = Math.min(pos1, pos2);
          const yMax = Math.max(pos1, pos2);
          rect = el("rect", {
            x: repeatsX + 4,
            y: yMin,
            width: repeatsW - 8,
            height: Math.max(1, yMax - yMin),
            rx: isSmall ? 0 : 6,
            fill: repeatColor(r.cls),
            style: "cursor: pointer;"
          });
          if (!isSmall) {
            rect.setAttribute("stroke", "rgba(127,127,127,0.20)");
          }
        } else {
          rect = el("rect", {
            x: pos1,
            y: repeatsY + 4,
            width: Math.max(1, pos2 - pos1),
            height: repeatsH - 8,
            rx: isSmall ? 0 : 6,
            fill: repeatColor(r.cls),
            style: "cursor: pointer;"
          });
          if (!isSmall) {
            rect.setAttribute("stroke", "rgba(127,127,127,0.20)");
          }
        }
        
        // Add mouse event handlers for tooltip
        rect.addEventListener("mousemove", (e) => {
          state.hoveredRepeatTooltip = {
            text: tooltipText,
            x: e.clientX + 10,
            y: e.clientY + 10
          };
          updateTooltip();
        });
        
        rect.addEventListener("mouseleave", () => {
          state.hoveredRepeatTooltip = null;
          updateTooltip();
        });
        
        fragment.appendChild(rect);
      }
      
      // Append all elements at once (single DOM operation)
      tracksSvg.appendChild(fragment);
    }
    }

    // --- Locus ruler
    if (!rulerLayout.track.collapsed) {
      let rulerX, rulerY, rulerW, rulerH, baseX, baseY;
      if (isVertical) {
        rulerX = rulerLayout.contentLeft + 8;
        rulerW = 56;
        rulerY = 16;
        rulerH = H - 32;
        baseX = rulerX + 14;
      } else {
        rulerY = rulerLayout.contentTop + 8;
        rulerH = 56;
        rulerX = 16;
        rulerW = W - 32;
        baseY = rulerY + 14;
      }

      // Base line
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: baseX, x2: baseX, y1: 16, y2: H-16,
          stroke: "rgba(127,127,127,0.70)",
          "stroke-width": 1.2
        }));
      } else {
        tracksSvg.appendChild(el("line", {
          x1: 16, x2: W-16, y1: baseY, y2: baseY,
          stroke: "rgba(127,127,127,0.70)",
          "stroke-width": 1.2
        }));
      }

      const span = state.endBp - state.startBp;
      const dim = isVertical ? H : W;
      const desiredMajorTicks = Math.max(5, Math.min(10, Math.floor((dim - 32) / 140)));
      const majorBp = chooseNiceTickBp(span, desiredMajorTicks);
      const minorBp = majorBp / 5;

      const pxPerMajor = (dim - 32) / (span / majorBp);
      const showLabels = pxPerMajor >= 80;

    const firstMinor = Math.ceil(state.startBp / minorBp) * minorBp;

    // Track major tick label positions to avoid overlap with edge labels
    const majorTickLabelPositions = [];

    for (let bp = firstMinor; bp <= state.endBp; bp += minorBp) {
      const pos = genomePos(bp);
      const isMajor = (Math.round(bp / minorBp) % 5) === 0;

      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: baseX - (isMajor ? 9 : 5), x2: baseX + (isMajor ? 9 : 5),
          y1: pos, y2: pos,
          stroke: isMajor ? "rgba(127,127,127,0.55)" : "rgba(127,127,127,0.30)",
          "stroke-width": isMajor ? 1.1 : 1
        }));

        if (isMajor && showLabels) {
          const textEl = el("text", {
            x: baseX + 26,
            y: pos,
            class: "svg-small",
            "text-anchor": "start",
            "dominant-baseline": "middle",
            transform: "rotate(-90 " + (baseX + 26) + " " + pos + ")"
          }, formatBp(Math.round(bp), span));
          tracksSvg.appendChild(textEl);
          majorTickLabelPositions.push(pos);
        }
      } else {
        tracksSvg.appendChild(el("line", {
          x1: pos, x2: pos,
          y1: baseY - (isMajor ? 9 : 5), y2: baseY + (isMajor ? 9 : 5),
          stroke: isMajor ? "rgba(127,127,127,0.55)" : "rgba(127,127,127,0.30)",
          "stroke-width": isMajor ? 1.1 : 1
        }));

        if (isMajor && showLabels) {
          tracksSvg.appendChild(el("text", {
            x: pos,
            y: baseY + 26,
            class: "svg-small",
            "text-anchor": "middle"
          }, formatBp(Math.round(bp), span)));
          majorTickLabelPositions.push(pos);
        }
      }
    }

    // Only show edge labels if no tick label is too close
    const edgeThreshold = 100; // pixels
    if (isVertical) {
      const bottomEdgeY = H - 16;
      const topEdgeY = 16;
      const hasNearbyBottomTick = majorTickLabelPositions.some(tickY => Math.abs(tickY - bottomEdgeY) < edgeThreshold);
      const hasNearbyTopTick = majorTickLabelPositions.some(tickY => Math.abs(tickY - topEdgeY) < edgeThreshold);

      if (!hasNearbyBottomTick) {
        const textEl = el("text", {
          x: baseX + 26, y: bottomEdgeY, class:"svg-small", "text-anchor":"start", "dominant-baseline":"middle",
          transform: "rotate(-90 " + (baseX + 26) + " " + bottomEdgeY + ")"
        }, formatBp(Math.round(state.startBp), span));
        tracksSvg.appendChild(textEl);
      }
      if (!hasNearbyTopTick) {
        const textEl = el("text", {
          x: baseX + 26, y: topEdgeY, class:"svg-small", "text-anchor":"start", "dominant-baseline":"middle",
          transform: "rotate(-90 " + (baseX + 26) + " " + topEdgeY + ")"
        }, formatBp(Math.round(state.endBp), span));
        tracksSvg.appendChild(textEl);
      }
    } else {
      const leftEdgeX = 16;
      const rightEdgeX = W - 16;
      const hasNearbyLeftTick = majorTickLabelPositions.some(tickX => Math.abs(tickX - leftEdgeX) < edgeThreshold);
      const hasNearbyRightTick = majorTickLabelPositions.some(tickX => Math.abs(tickX - rightEdgeX) < edgeThreshold);

      if (!hasNearbyLeftTick) {
        tracksSvg.appendChild(el("text", { x: 16, y: baseY + 26, class:"svg-small" },
          formatBp(Math.round(state.startBp), span)
        ));
      }
      if (!hasNearbyRightTick) {
        tracksSvg.appendChild(el("text", {
          x: W - 16, y: baseY + 26, class:"svg-small", "text-anchor":"end"
        }, formatBp(Math.round(state.endBp), span)));
      }
    }

    // Variant marks
    for (let idx = 0; idx < variants.length; idx++) {
      const v = variants[idx];
      if (v.pos < state.startBp || v.pos > state.endBp) continue;
      const pos = genomePos(v.pos);
      const isHovered = state.hoveredVariantIndex === idx;
      const strokeWidth = isHovered ? 2.5 : 1.2;
      const circleStrokeWidth = isHovered ? 2.2 : 1.4;
      const isIns = isInsertion(v);

      let lineEl;
      if (isVertical) {
        lineEl = el("line", {
          x1: baseX - 18, x2: baseX + 18,
          y1: pos, y2: pos,
          stroke: "var(--blue)",
          "stroke-width": strokeWidth,
          style: "cursor: pointer;"
        });
      } else {
        lineEl = el("line", {
          x1: pos, x2: pos,
          y1: baseY - 18, y2: baseY + 18,
          stroke: "var(--blue)",
          "stroke-width": strokeWidth,
          style: "cursor: pointer;"
        });
      }
      lineEl.addEventListener("mouseenter", () => {
        state.hoveredVariantIndex = idx;
        renderAll();
      });
      lineEl.addEventListener("mouseleave", () => {
        state.hoveredVariantIndex = null;
        renderAll();
      });
      
      // For insertions, add pointerdown handler to the line itself
      if (isInsertion(v)) {
        lineEl.style.pointerEvents = "auto";
        lineEl.addEventListener("pointerdown", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (state.expandedInsertions.has(v.id)) {
            state.expandedInsertions.delete(v.id);
          } else {
            state.expandedInsertions.add(v.id);
          }
          renderAll();
        });
      }
      tracksSvg.appendChild(lineEl);
      
      // For insertions, add a larger invisible clickable area AFTER the line (so it's on top)
      if (isInsertion(v)) {
        // Add an invisible wider rectangle for easier clicking
        let clickArea;
        if (isVertical) {
          clickArea = el("rect", {
            x: baseX - 20,
            y: pos - 5,
            width: 40,
            height: 10,
            fill: "transparent",
            style: "cursor: pointer; pointer-events: auto;"
          });
        } else {
          clickArea = el("rect", {
            x: pos - 5,
            y: baseY - 20,
            width: 10,
            height: 40,
            fill: "transparent",
            style: "cursor: pointer; pointer-events: auto;"
          });
        }
        clickArea.addEventListener("pointerdown", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (state.expandedInsertions.has(v.id)) {
            state.expandedInsertions.delete(v.id);
          } else {
            state.expandedInsertions.add(v.id);
          }
          renderAll();
        });
        tracksSvg.appendChild(clickArea);
      }

      let circleEl;
      if (isVertical) {
        circleEl = el("circle", {
          cx: baseX - 18, cy: pos, r: 3.4,
          fill: "none",
          stroke: "var(--blue)",
          "stroke-width": circleStrokeWidth,
          style: "cursor: pointer;"
        });
      } else {
        circleEl = el("circle", {
          cx: pos, cy: baseY - 18, r: 3.4,
          fill: "none",
          stroke: "var(--blue)",
          "stroke-width": circleStrokeWidth,
          style: "cursor: pointer;"
        });
      }
      circleEl.addEventListener("mouseenter", () => {
        state.hoveredVariantIndex = idx;
        renderAll();
      });
      circleEl.addEventListener("mouseleave", () => {
        state.hoveredVariantIndex = null;
        renderAll();
      });
      // Pointerdown handler to toggle insertion expansion
      if (isInsertion(v)) {
        circleEl.style.pointerEvents = "auto";
        circleEl.addEventListener("pointerdown", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (state.expandedInsertions.has(v.id)) {
            state.expandedInsertions.delete(v.id);
          } else {
            state.expandedInsertions.add(v.id);
          }
          renderAll();
        });
      }
      tracksSvg.appendChild(circleEl);
      
      // Draw expanded insertion sequence if expanded
      if (state.expandedInsertions.has(v.id) && isInsertion(v)) {
        const maxInsertLen = getMaxInsertionLength(v);
        const gapSize = maxInsertLen * 8;
        
        // Draw inserted sequence (use longest alt allele)
        const longestAlt = v.altAlleles.reduce((a, b) => a.length > b.length ? a : b);
        const insertedSeq = longestAlt.substring(v.refAllele.length);
        const baseSize = gapSize / insertedSeq.length;
        
        const nucleotideColors = {
          'A': 'rgba(0, 200, 0, 0.8)',      // green
          'C': 'rgba(0, 0, 255, 0.8)',      // blue
          'G': 'rgba(255, 165, 0, 0.8)',    // orange
          'T': 'rgba(255, 0, 0, 0.8)'       // red
        };
        
        if (isVertical) {
          const gapStartY = pos;
          const gapEndY = gapStartY - gapSize; // going up (toward start)
          
          // Draw gap background
          tracksSvg.appendChild(el("rect", {
            x: baseX - 18,
            y: gapEndY,
            width: 36,
            height: gapSize,
            fill: "rgba(255,255,255,0.1)",
            stroke: "rgba(127,127,127,0.3)",
            "stroke-width": 1,
            "stroke-dasharray": "2,2"
          }));
          
          for (let i = 0; i < insertedSeq.length; i++) {
            const base = insertedSeq[i].toUpperCase();
            const baseY = gapStartY - (i + 1) * baseSize;
            const color = nucleotideColors[base] || 'rgba(127,127,127,0.8)';
            
            tracksSvg.appendChild(el("rect", {
              x: baseX - 16,
              y: baseY,
              width: 32,
              height: baseSize - 1,
              fill: color
            }));
            
            // Draw base letter if space allows
            if (baseSize >= 8) {
              const textEl = el("text", {
                x: baseX,
                y: baseY + baseSize / 2,
                class: "svg-small",
                "text-anchor": "middle",
                fill: "white",
                "font-weight": "bold",
                "dominant-baseline": "middle",
                transform: "rotate(-90 " + baseX + " " + (baseY + baseSize / 2) + ")"
              }, base);
              tracksSvg.appendChild(textEl);
            }
          }
        } else {
          const gapStartX = pos;
          const gapEndX = gapStartX + gapSize;
          
          // Draw gap background
          tracksSvg.appendChild(el("rect", {
            x: gapStartX,
            y: baseY - 18,
            width: gapSize,
            height: 36,
            fill: "rgba(255,255,255,0.1)",
            stroke: "rgba(127,127,127,0.3)",
            "stroke-width": 1,
            "stroke-dasharray": "2,2"
          }));
          
          for (let i = 0; i < insertedSeq.length; i++) {
            const base = insertedSeq[i].toUpperCase();
            const baseX = gapStartX + i * baseSize;
            const color = nucleotideColors[base] || 'rgba(127,127,127,0.8)';
            
            tracksSvg.appendChild(el("rect", {
              x: baseX,
              y: baseY - 16,
              width: baseSize - 1,
              height: 32,
              fill: color
            }));
            
            // Draw base letter if space allows
            if (baseSize >= 8) {
              tracksSvg.appendChild(el("text", {
                x: baseX + baseSize / 2,
                y: baseY,
                class: "svg-small",
                "text-anchor": "middle",
                fill: "white",
                "font-weight": "bold",
                "dominant-baseline": "middle"
              }, base));
            }
          }
        }
      }
    }

      // separator
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: rulerX + rulerW, x2: rulerX + rulerW, y1: 0, y2: H,
          stroke: "rgba(127,127,127,0.12)"
        }));
      } else {
        tracksSvg.appendChild(el("line", {
          x1: 0, x2: W, y1: rulerY + rulerH, y2: rulerY + rulerH,
          stroke: "rgba(127,127,127,0.12)"
        }));
      }
    }

    // --- Reference track
    if (!referenceLayout.track.collapsed) {
      let referenceX, referenceY, referenceW, referenceH;
      if (isVertical) {
        referenceX = referenceLayout.contentLeft + 8;
        referenceW = 24;
        referenceY = 16;
        referenceH = H - 32;
      } else {
        referenceY = referenceLayout.contentTop + 8;
        referenceH = 24;
        referenceX = 16;
        referenceW = W - 32;
      }

      // Helper function to get reference sequence for a region
      // Returns { sequence: array, startBp: number } where startBp is the genomic position of sequence[0]
      function getReferenceSequence(startBp, endBp) {
        // Use the real reference sequence from config if available
        if (referenceSequence && referenceSequence.length > 0) {
          // Calculate the offset into the sequence
          // The reference sequence starts at data_bounds.start (0-based)
          // UCSC returns sequence for [start, end), so sequence[i] corresponds to genomic position (dataStart + i)
          const dataStart = window.GENOMESHADER_CONFIG?.data_bounds?.start || 0;
          const viewStart = Math.floor(startBp);
          const viewEnd = Math.floor(endBp);
          
          // Calculate sequence indices (0-based relative to sequence start)
          // seqStart: index in sequence string for viewStart genomic position
          // seqEnd: index in sequence string for (viewEnd + 1) genomic position (exclusive end)
          const seqStart = Math.max(0, viewStart - dataStart);
          const seqEnd = Math.min(referenceSequence.length, viewEnd - dataStart + 1);
          
          // Only return sequence if we have valid indices within bounds
          if (seqStart >= 0 && seqEnd > seqStart && seqStart < referenceSequence.length) {
            const sequence = referenceSequence.slice(seqStart, seqEnd).split('');
            // The actual genomic start position of the returned sequence
            const actualStartBp = dataStart + seqStart;
            return { sequence: sequence, startBp: actualStartBp };
          }
        }
        // Fallback: return empty array if no sequence data
        return { sequence: [], startBp: startBp };
      }

      const span = state.endBp - state.startBp;
      const startBpInt = Math.floor(state.startBp);
      const endBpInt = Math.floor(state.endBp);
      const refSeqData = getReferenceSequence(startBpInt, endBpInt);
      const refSeq = refSeqData.sequence;
      const refSeqStartBp = refSeqData.startBp;

      const nucleotideColors = {
        'A': 'rgba(0, 200, 0, 0.8)',      // green
        'C': 'rgba(0, 0, 255, 0.8)',      // blue
        'G': 'rgba(255, 165, 0, 0.8)',    // orange
        'T': 'rgba(255, 0, 0, 0.8)'       // red
      };

      // Helper function to convert nucleotide color to RGBA array for WebGPU
      function nucleotideColorToRgba(base) {
        const rgbaStr = nucleotideColors[base] || 'rgba(127,127,127,0.8)';
        const match = rgbaStr.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        if (match) {
          return [
            parseInt(match[1]) / 255,
            parseInt(match[2]) / 255,
            parseInt(match[3]) / 255,
            parseFloat(match[4])
          ];
        }
        return [0.5, 0.5, 0.5, 0.8]; // fallback
      }

      // Calculate base size based on zoom level
      const minBaseSize = 2; // Minimum size per base in pixels
      const baseSize = Math.max(minBaseSize, state.pxPerBp);

      // Only show individual bases if zoomed in enough (at least 2 actual pixels per base)
      const showIndividualBases = state.pxPerBp >= 2;

      // Performance limit: maximum number of bases to render
      const maxBasesToRender = 10000;

      if (showIndividualBases && refSeq.length > 0) {
        // Filter and prepare visible bases
        const visibleBases = [];
        for (let i = 0; i < refSeq.length; i++) {
          // Calculate the actual genomic position for this base
          // refSeq[i] corresponds to genomic position refSeqStartBp + i
          const bp = refSeqStartBp + i;
          
          // Only render bases that are within the visible view
          if (bp < state.startBp || bp > state.endBp) continue;
          
          // Use genomePosCanonical to account for insertion gaps
          const pos = genomePosCanonical(bp);
          const nextBp = bp + 1;
          const nextPos = nextBp <= state.endBp ? genomePosCanonical(nextBp) : genomePosCanonical(state.endBp);
          const actualSize = Math.max(minBaseSize, Math.abs(nextPos - pos));
          
          // Skip bases that are too small to render
          if (actualSize < minBaseSize) continue;
          
          const base = refSeq[i].toUpperCase();
          visibleBases.push({
            bp: bp,
            base: base,
            pos: pos,
            nextPos: nextPos,
            actualSize: actualSize
          });
        }

        // Limit the number of bases to render
        const basesToRender = visibleBases.slice(0, maxBasesToRender);
        
        if (visibleBases.length > maxBasesToRender) {
          console.warn(`Too many bases (${visibleBases.length}), rendering only first ${maxBasesToRender}`);
        }

        // Use WebGPU if available, otherwise fall back to SVG
        if (webgpuSupported && instancedRenderer) {
          // Add rectangles to WebGPU renderer
          // Scale by devicePixelRatio since WebGPU canvas uses physical pixels
          const dpr = window.devicePixelRatio || 1;
          
          for (const b of basesToRender) {
            const pos = b.pos;
            const actualSize = b.actualSize;
            const base = b.base;
            const rgba = nucleotideColorToRgba(base);
            
            let x, y, w, h;
            if (isVertical) {
              x = referenceX;
              y = pos;
              w = referenceW;
              h = actualSize - 0.5;
            } else {
              x = pos;
              y = referenceY;
              w = actualSize - 0.5;
              h = referenceH;
            }
            
            // Scale coordinates by DPR to match physical pixel canvas
            instancedRenderer.addRect(x * dpr, y * dpr, w * dpr, h * dpr, rgba);
          }
          
          // Draw base letters using SVG (text rendering can stay SVG-based)
          const fragment = document.createDocumentFragment();
          for (const b of basesToRender) {
            if (b.actualSize >= 8) {
              const base = b.base;
              const pos = b.pos;
              const actualSize = b.actualSize;
              
              if (isVertical) {
                const textEl = el("text", {
                  x: referenceX + referenceW / 2,
                  y: pos + actualSize / 2,
                  class: "svg-small",
                  "text-anchor": "middle",
                  fill: "#fff",
                  stroke: "#000",
                  "stroke-width": "0.5",
                  "font-weight": "bold",
                  "dominant-baseline": "middle",
                  transform: "rotate(-90 " + (referenceX + referenceW / 2) + " " + (pos + actualSize / 2) + ")"
                }, base);
                fragment.appendChild(textEl);
              } else {
                const textEl = el("text", {
                  x: pos + actualSize / 2,
                  y: referenceY + referenceH / 2,
                  class: "svg-small",
                  "text-anchor": "middle",
                  fill: "#fff",
                  stroke: "#000",
                  "stroke-width": "0.5",
                  "font-weight": "bold",
                  "dominant-baseline": "middle"
                }, base);
                fragment.appendChild(textEl);
              }
            }
          }
          tracksSvg.appendChild(fragment);
        } else {
          // Fallback to SVG rendering
          const fragment = document.createDocumentFragment();
          
          for (const b of basesToRender) {
            const pos = b.pos;
            const actualSize = b.actualSize;
            const base = b.base;
            const color = nucleotideColors[base] || 'rgba(127,127,127,0.8)';
            
            if (isVertical) {
              fragment.appendChild(el("rect", {
                x: referenceX,
                y: pos,
                width: referenceW,
                height: actualSize - 0.5,
                fill: color
              }));

              // Draw base letter if space allows
              if (actualSize >= 8) {
                const textEl = el("text", {
                  x: referenceX + referenceW / 2,
                  y: pos + actualSize / 2,
                  class: "svg-small",
                  "text-anchor": "middle",
                  fill: "#fff",
                  stroke: "#000",
                  "stroke-width": "0.5",
                  "font-weight": "bold",
                  "dominant-baseline": "middle",
                  transform: "rotate(-90 " + (referenceX + referenceW / 2) + " " + (pos + actualSize / 2) + ")"
                }, base);
                fragment.appendChild(textEl);
              }
            } else {
              fragment.appendChild(el("rect", {
                x: pos,
                y: referenceY,
                width: actualSize - 0.5,
                height: referenceH,
                fill: color
              }));

              // Draw base letter if space allows
              if (actualSize >= 8) {
                const textEl = el("text", {
                  x: pos + actualSize / 2,
                  y: referenceY + referenceH / 2,
                  class: "svg-small",
                  "text-anchor": "middle",
                  fill: "#fff",
                  stroke: "#000",
                  "stroke-width": "0.5",
                  "font-weight": "bold",
                  "dominant-baseline": "middle"
                }, base);
                fragment.appendChild(textEl);
              }
            }
          }
          
          // Append all elements at once (single DOM operation)
          tracksSvg.appendChild(fragment);
        }
      } else {
        // Zoomed out: show a continuous reference line with subtle pattern
        if (isVertical) {
          const topPad = 16, bottomPad = 16;
          const innerH = H - topPad - bottomPad;
          const totalGapPx = getTotalInsertionGapWidth();
          const totalGapBp = totalGapPx / state.pxPerBp;
          const effectiveSpan = span + totalGapBp;

          // Draw background
          tracksSvg.appendChild(el("rect", {
            x: referenceX,
            y: topPad,
            width: referenceW,
            height: innerH,
            fill: "rgba(127,127,127,0.08)",
            rx: 4
          }));

          // Draw a subtle pattern indicating reference sequence
          const patternHeight = 20;
          for (let y = topPad; y < topPad + innerH; y += patternHeight * 2) {
            tracksSvg.appendChild(el("rect", {
              x: referenceX,
              y: y,
              width: referenceW,
              height: Math.min(patternHeight, topPad + innerH - y),
              fill: "rgba(127,127,127,0.12)"
            }));
          }
        } else {
          const leftPad = 16, rightPad = 16;
          const innerW = W - leftPad - rightPad;
          const totalGapPx = getTotalInsertionGapWidth();
          const totalGapBp = totalGapPx / state.pxPerBp;
          const effectiveSpan = span + totalGapBp;

          // Draw background
          tracksSvg.appendChild(el("rect", {
            x: leftPad,
            y: referenceY,
            width: innerW,
            height: referenceH,
            fill: "rgba(127,127,127,0.08)",
            rx: 4
          }));

          // Draw a subtle pattern indicating reference sequence
          const patternWidth = 20;
          for (let x = leftPad; x < leftPad + innerW; x += patternWidth * 2) {
            tracksSvg.appendChild(el("rect", {
              x: x,
              y: referenceY,
              width: Math.min(patternWidth, leftPad + innerW - x),
              height: referenceH,
              fill: "rgba(127,127,127,0.12)"
            }));
          }
        }
      }

      // Separator
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: referenceX + referenceW, x2: referenceX + referenceW, y1: 0, y2: H,
          stroke: "rgba(127,127,127,0.12)"
        }));
      } else {
        tracksSvg.appendChild(el("line", {
          x1: 0, x2: W, y1: referenceY - 4, y2: referenceY - 4,
          stroke: "rgba(127,127,127,0.12)"
        }));
      }
    }

    // Execute WebGPU render pass after all tracks are rendered
    if (webgpuSupported && instancedRenderer && instancedRenderer.rectInstances.length > 0) {
      try {
        // Update projection matrix for current canvas size
        const devicePixelRatio = window.devicePixelRatio || 1;
        const width = tracksWebGPU.clientWidth * devicePixelRatio;
        const height = tracksWebGPU.clientHeight * devicePixelRatio;
        
        if (tracksWebGPU.width !== width || tracksWebGPU.height !== height) {
          tracksWebGPU.width = width;
          tracksWebGPU.height = height;
          webgpuCore.handleResize();
        }
        
        const encoder = webgpuCore.createCommandEncoder();
        const texture = webgpuCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear', // Clear canvas on each render
            storeOp: 'store',
          }],
        });
        
        instancedRenderer.render(encoder, renderPass);
        renderPass.end();
        webgpuCore.submit([encoder.finish()]);
      } catch (error) {
        console.error("WebGPU render error:", error);
        // Fallback: clear instances and continue with SVG only
        instancedRenderer.clear();
      }
    } else if (webgpuSupported && instancedRenderer) {
      // Clear WebGPU canvas if no instances to render
      try {
        const encoder = webgpuCore.createCommandEncoder();
        const texture = webgpuCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear',
            storeOp: 'store',
          }],
        });
        renderPass.end();
        webgpuCore.submit([encoder.finish()]);
      } catch (error) {
        // Ignore errors when clearing
      }
    }
  }

  // -----------------------------
  // Canvas helpers
  // -----------------------------
  function resizeCanvasTo(el, canvas) {
    const dpr = window.devicePixelRatio || 1;
    const w = Math.floor(rectW(el) * dpr);
    const h = Math.floor(rectH(el) * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
    return dpr;
  }

  function visibleVariantWindow() {
    // Return all variants in the visible genomic range, not limited by state.K
    // state.K is just used for initial window sizing
    const visibleVariants = variants.filter(v => v.pos >= state.startBp && v.pos <= state.endBp);
    return visibleVariants;
  }

  function roundRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y,   x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x,   y+h, rr);
    ctx.arcTo(x,   y+h, x,   y,   rr);
    ctx.arcTo(x,   y,   x+w, y,   rr);
    ctx.closePath();
  }

  // -----------------------------
  // Sankey placeholder (Canvas2D)
  // -----------------------------
  function renderFlowCanvas() {
    const layout = getTrackLayout();
    const flowLayout = layout.find(l => l.track.id === "flow");
    if (!flowLayout || flowLayout.track.collapsed) {
      // Clear canvas if collapsed
      const ctx = flowCanvas.getContext("2d");
      ctx.clearRect(0, 0, flowCanvas.width, flowCanvas.height);
      return;
    }

    const dpr = resizeCanvasTo(flow, flowCanvas);
    const ctx = flowCanvas.getContext("2d");
    
    // Clear and set up canvas
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,flowCanvas.width,flowCanvas.height);
    ctx.scale(dpr, dpr);

    const isVertical = isVerticalMode();
    const variantMode = getVariantLayoutMode();
    const junctionY = 40;
    const junctionX = 40;

    const W = flowWidthPx(), H = flowHeightPx();

    const colLines = cssVar("--grid");
    const colGrid  = cssVar("--grid2");
    const colText  = cssVar("--muted");
    const colBlue  = cssVar("--blue");

    // background
    ctx.fillStyle = "rgba(127,127,127,0.035)";
    ctx.fillRect(0,0,W,H);

    // connectors (diagonal lines - make them meet the ruler variant position precisely)
    const win = visibleVariantWindow();
    
    if (isVertical) {
      // In vertical mode, sort variants by position for consistent ordering
      const sortedWin = [...win].sort((a, b) => a.pos - b.pos);
      
      // columns (horizontal lines in vertical mode)
      ctx.strokeStyle = colBlue;
      ctx.globalAlpha = 0.6;
      for (let i=0;i<sortedWin.length;i++) {
        const v = sortedWin[i];
        const variantIdx = variants.findIndex(v2 => v2.id === v.id);
        const isHovered = state.hoveredVariantIndex === variantIdx;
        ctx.lineWidth = isHovered ? 2.5 : 1;
        // Position column based on mode
        const y = variantMode === "genomic" 
          ? yGenomeCanonical(v.pos, H)
          : yColumn(i, sortedWin.length);
        ctx.beginPath();
        ctx.moveTo(junctionX, y);
        ctx.lineTo(W-18, y);
        ctx.stroke();

        ctx.fillStyle = colText;
        ctx.font = "12px ui-sans-serif, system-ui";
        ctx.save();
        ctx.translate(14, y + 6); // Move down by 6px total
        ctx.rotate(-Math.PI/2);
        ctx.fillText(`v${variantIdx + 1}`, 0, 0);
        ctx.restore();
      }
      ctx.strokeStyle = colBlue;
      ctx.globalAlpha = 0.5;

      const x0 = 6;
      for (let i=0; i<sortedWin.length; i++) {
        const v = sortedWin[i];
        const variantIdx = variants.findIndex(v2 => v2.id === v.id);
        const isHovered = state.hoveredVariantIndex === variantIdx;
        ctx.lineWidth = isHovered ? 2.5 : 1;
        const vy = yGenomeCanonical(v.pos, H); // always use genomic position for ruler connection
        const cy = variantMode === "genomic"
          ? yGenomeCanonical(v.pos, H)
          : yColumn(i, sortedWin.length);
        ctx.beginPath();
        ctx.moveTo(x0, vy);
        ctx.lineTo(junctionX, cy);
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
    } else {
      // columns (vertical lines)
      ctx.strokeStyle = colBlue;
      ctx.globalAlpha = 0.6;
      for (let i=0;i<win.length;i++) {
        const v = win[i];
        const variantIdx = variants.findIndex(v2 => v2.id === v.id);
        const isHovered = state.hoveredVariantIndex === variantIdx;
        ctx.lineWidth = isHovered ? 2.5 : 1;
        // Position column based on mode
        const x = variantMode === "genomic"
          ? xGenomeCanonical(v.pos, W)
          : xColumn(i, win.length);
        ctx.beginPath();
        ctx.moveTo(x, junctionY);
        ctx.lineTo(x, H-18);
        ctx.stroke();

        ctx.fillStyle = colText;
        ctx.font = "12px ui-sans-serif, system-ui";
        ctx.fillText(`v${variantIdx + 1}`, x - 10, 14);
      }
      ctx.strokeStyle = colBlue;
      ctx.globalAlpha = 0.5;

      const y0 = 6;
      for (let i=0; i<win.length; i++) {
        const v = win[i];
        const variantIdx = variants.findIndex(v2 => v2.id === v.id);
        const isHovered = state.hoveredVariantIndex === variantIdx;
        ctx.lineWidth = isHovered ? 2.5 : 1;
        const vx = xGenomeCanonical(v.pos, W); // always use genomic position for ruler connection
        const cx = variantMode === "genomic"
          ? xGenomeCanonical(v.pos, W)
          : xColumn(i, win.length);
        ctx.beginPath();
        ctx.moveTo(vx, y0);
        ctx.lineTo(cx, junctionY);
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
    }

    // placeholder nodes
    const labels = ["./.","ref","a1"];
    const nodeW = 16, nodeH = 18, gap = 8;
    
    if (isVertical) {
      const sortedWin = [...win].sort((a, b) => a.pos - b.pos);
      const left = 70;
      
      for (let i=0;i<sortedWin.length;i++){
        const v = sortedWin[i];
        // Position based on variant layout mode
        const cy = variantMode === "genomic"
          ? yGenomeCanonical(v.pos, H)
          : yColumn(i, sortedWin.length);
        
        for (let j=0;j<labels.length;j++){
          const x = left + j*(nodeW+gap);

          ctx.fillStyle = "rgba(127,127,127,0.08)";
          ctx.strokeStyle = "rgba(127,127,127,0.18)";
          ctx.beginPath();
          roundRect(ctx, x, cy - nodeH/2, nodeW, nodeH, 5);
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = colText;
          ctx.font = "11px ui-sans-serif, system-ui";
          ctx.save();
          // Position label above the node (shift left for better alignment)
          ctx.translate(x + nodeW/2 - gap - 5 + 12, cy - 12); // Center on node, shift left by gap + 5px, move up by 12px total
          ctx.rotate(-Math.PI/2);
          ctx.fillText(labels[j], 0, 4);
          ctx.restore();
        }
      }
    } else {
      for (let i=0;i<win.length;i++){
        // Position based on variant layout mode
        const cx = variantMode === "genomic"
          ? xGenomeCanonical(win[i].pos, W)
          : xColumn(i, win.length);
        const top = 70;

        for (let j=0;j<labels.length;j++){
          const y = top + j*(nodeH+gap);

          ctx.fillStyle = "rgba(127,127,127,0.08)";
          ctx.strokeStyle = "rgba(127,127,127,0.18)";
          ctx.beginPath();
          roundRect(ctx, cx - nodeW/2, y, nodeW, nodeH, 5);
          ctx.fill();
          ctx.stroke();

          ctx.fillStyle = colText;
          ctx.font = "11px ui-sans-serif, system-ui";
          ctx.fillText(labels[j], cx + 12, y + 13);
        }
      }
    }
  }

  // -----------------------------
  // Reads placeholder (IGV-style area)
  // -----------------------------
  function renderReadsCanvas() {
    const layout = getTrackLayout();
    const readsLayout = layout.find(l => l.track.id === "reads");
    if (!readsLayout || readsLayout.track.collapsed) {
      return; // Don't render if collapsed
    }

    const dpr = resizeCanvasTo(reads, readsCanvas);
    const ctx = readsCanvas.getContext("2d");

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,readsCanvas.width,readsCanvas.height);
    ctx.scale(dpr, dpr);

    const isVertical = isVerticalMode();
    const W = readsWidthPx(), H = readsHeightPx();
    const colText = cssVar("--muted");
    const grid = cssVar("--grid2");

    // soft background
    ctx.fillStyle = "rgba(127,127,127,0.02)";
    ctx.fillRect(0,0,W,H);

    if (isVertical) {
      // a few columns to suggest lanes (vertical mode)
      ctx.strokeStyle = grid;
      ctx.lineWidth = 1;
      const left = 8;
      const colW = 18;
      const cols = Math.floor((W - left - 12) / colW);
      for (let i=0; i<cols; i++) {
        const x = left + i*colW + colW/2;
        ctx.beginPath();
        ctx.moveTo(x, 16);
        ctx.lineTo(x, H-16);
        ctx.stroke();
      }

      // placeholder "reads" as rounded rects aligned in genome space
      function drawRead(bpStart, bpEnd, col, alpha=0.20) {
        const y1 = yGenomeCanonical(bpStart, H);
        const y2 = yGenomeCanonical(bpEnd, H);
        const x = left + col*colW + 2;
        const w = colW - 6;

        ctx.fillStyle = `rgba(120,180,255,${alpha})`;
        ctx.strokeStyle = `rgba(120,180,255,${alpha + 0.15})`;
        ctx.beginPath();
        roundRect(ctx, x, Math.min(y1, y2), w, Math.max(6, Math.abs(y2-y1)), 6);
        ctx.fill();
        ctx.stroke();
      }

      // a few fake reads
      drawRead(100_030, 100_160, 1, 0.10);
      drawRead(100_090, 100_240, 2, 0.12);
      drawRead(100_210, 100_420, 3, 0.10);
      drawRead(100_380, 100_610, 4, 0.11);
      drawRead(100_590, 100_820, 5, 0.10);
      drawRead(100_700, 100_900, 6, 0.11);

      // variant guide lines (bright blue)
      ctx.strokeStyle = cssVar("--blue");
      for (let idx = 0; idx < variants.length; idx++) {
        const v = variants[idx];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        const isHovered = state.hoveredVariantIndex === idx;
        ctx.globalAlpha = isHovered ? 0.7 : 0.4;
        ctx.lineWidth = isHovered ? 2.5 : 1;
        const y = yGenomeCanonical(v.pos, H);
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(W-10, y);
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
    } else {
      // a few rows to suggest lanes
      ctx.strokeStyle = grid;
      ctx.lineWidth = 1;
      const top = 8;
      const rowH = 18;
      const rows = Math.floor((H - top - 12) / rowH);
      for (let i=0; i<rows; i++) {
        const y = top + i*rowH + rowH/2;
        ctx.beginPath();
        ctx.moveTo(16, y);
        ctx.lineTo(W-16, y);
        ctx.stroke();
      }

      // placeholder "reads" as rounded rects aligned in genome space
      function drawRead(bpStart, bpEnd, row, alpha=0.20) {
        const x1 = xGenomeCanonical(bpStart, W);
        const x2 = xGenomeCanonical(bpEnd, W);
        const y = top + row*rowH + 2;
        const h = rowH - 6;

        ctx.fillStyle = `rgba(120,180,255,${alpha})`;
        ctx.strokeStyle = `rgba(120,180,255,${alpha + 0.15})`;
        ctx.beginPath();
        roundRect(ctx, x1, y, Math.max(6, x2-x1), h, 6);
        ctx.fill();
        ctx.stroke();
      }

      // a few fake reads
      drawRead(100_030, 100_160, 1, 0.10);
      drawRead(100_090, 100_240, 2, 0.12);
      drawRead(100_210, 100_420, 3, 0.10);
      drawRead(100_380, 100_610, 4, 0.11);
      drawRead(100_590, 100_820, 5, 0.10);
      drawRead(100_700, 100_900, 6, 0.11);

      // variant guide lines (bright blue)
      ctx.strokeStyle = cssVar("--blue");
      for (let idx = 0; idx < variants.length; idx++) {
        const v = variants[idx];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        const isHovered = state.hoveredVariantIndex === idx;
        ctx.globalAlpha = isHovered ? 0.7 : 0.4;
        ctx.lineWidth = isHovered ? 2.5 : 1;
        const x = xGenomeCanonical(v.pos, W);
        ctx.beginPath();
        ctx.moveTo(x, top);
        ctx.lineTo(x, H-10);
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
    }

    // connectors from Sankey columns down to Reads track (diagonal lines)
    // Disabled for now - makes display too busy
    /*
    const win = visibleVariantWindow();
    const trackLayoutForConnectors = getTrackLayout();
    const flowLayoutItem = trackLayoutForConnectors.find(l => l.track.id === "flow");
    const readsLayoutItem = trackLayoutForConnectors.find(l => l.track.id === "reads");
    
    if (flowLayoutItem && readsLayoutItem && !flowLayoutItem.track.collapsed && !readsLayoutItem.track.collapsed) {
      ctx.strokeStyle = cssVar("--blue");
      ctx.globalAlpha = 0.5;
      ctx.lineWidth = 1;
      
      // Draw diagonal lines from Sankey columns to variant positions in Reads track
      // Similar to how Locus connects to Sankey, but in reverse direction
      for (let i=0; i<win.length; i++) {
        const v = win[i];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        
        // Calculate column x position in Reads canvas coordinates
        // Use the same logic as xColumn but with Reads canvas width
        const margin = 60;
        const innerW = Math.max(10, W - 2*margin);
        let columnX;
        if (state.K <= 1) {
          columnX = margin;
        } else {
          columnX = margin + (i / (state.K - 1)) * innerW;
        }
        
        // Variant position x in Reads track (genomic coordinate mapping)
        const variantX = xGenomeCanonical(v.pos, W);
        
        // Draw diagonal line from column position to variant position
        ctx.beginPath();
        ctx.moveTo(columnX, 0); // top of reads canvas, at column x position
        ctx.lineTo(variantX, top); // connect to variant position at top of read lanes
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
    }
    */
  }

  // -----------------------------
  // Track controls rendering
  // -----------------------------
  const trackControls = document.getElementById("trackControls");
  function renderTrackControls() {
    trackControls.innerHTML = "";
    const layout = getTrackLayout();
    const isVertical = isVerticalMode();

    for (const item of layout) {
      const track = item.track;
      const container = document.createElement("div");
      container.className = "track-control-container";
      
      if (isVertical) {
        container.style.position = "absolute";
        container.style.left = `${item.left}px`;
        container.style.width = `${item.width}px`;
        container.style.top = "0";
        container.style.height = "100%";
      } else {
        container.style.position = "absolute";
        container.style.left = "0";
        container.style.right = "0";
        container.style.top = `${item.top}px`;
        container.style.height = `${item.height}px`;
      }
      container.dataset.trackId = track.id;

      const controls = document.createElement("div");
      controls.className = "track-controls";
      controls.dataset.trackId = track.id;

      const collapseBtn = document.createElement("button");
      collapseBtn.className = "track-collapse-btn";
      if (isVertical) {
        collapseBtn.textContent = track.collapsed ? "▲" : "▶";
      } else {
        collapseBtn.textContent = track.collapsed ? "▶" : "▼";
      }
      collapseBtn.type = "button";
      collapseBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        e.preventDefault();
        track.collapsed = !track.collapsed;
        updateTracksHeight();
        renderAll();
      });

      const label = document.createElement("div");
      label.className = "track-label";
      label.textContent = track.label;

      // In vertical mode, reverse order: label on top, button on bottom
      if (isVertical) {
        controls.appendChild(label);
        controls.appendChild(collapseBtn);
        container.appendChild(controls);
        // After appending, measure the label's width and adjust transform
        // With transform-origin: left center, the first character stays at bottom
        // We need to translate right by half width to center it horizontally
        setTimeout(() => {
          try {
            const width = label.offsetWidth || label.getBoundingClientRect().width;
            if (width > 0) {
              // After -90deg rotation:
              // - translateX moves vertically (negative = up, positive = down)
              // - translateY moves horizontally (negative = left, positive = right)
              // Use translateX(12px) to position vertically and translateY(0.0px) for horizontal
              label.style.transform = `rotate(-90deg) translateX(12px) translateY(0.0px)`;
            }
          } catch (e) {
            console.error('Error adjusting label transform:', e);
          }
        }, 10);
      } else {
        controls.appendChild(collapseBtn);
        controls.appendChild(label);
        container.appendChild(controls);
      }

      if (!track.collapsed) {
        const resizeHandle = document.createElement("div");
        resizeHandle.className = "track-resize-handle";
        resizeHandle.dataset.trackId = track.id;
        container.appendChild(resizeHandle);
      }

      trackControls.appendChild(container);
    }
  }

  // -----------------------------
  // HUD + renderAll
  // -----------------------------
  function renderHUD() {
    const locusText = `${state.contig}:${Math.floor(state.startBp).toLocaleString()}-${Math.floor(state.endBp).toLocaleString()}`;
    
    // Preserve lazy loading status if it exists
    if (window._genomeshaderLazyStatus) {
      const status = window._genomeshaderLazyStatus;
      const statusColor = status.type === 'error' ? 'var(--accent)' : 'var(--text)';
      hud.innerHTML = `<span style="color: ${statusColor}; font-weight: 500;">${status.message}</span> | ${locusText}`;
    } else {
      hud.textContent = locusText;
    }
  }

  function updateTooltip() {
    if (state.hoveredRepeatTooltip) {
      tooltip.textContent = state.hoveredRepeatTooltip.text;
      tooltip.style.left = state.hoveredRepeatTooltip.x + 'px';
      tooltip.style.top = state.hoveredRepeatTooltip.y + 'px';
      tooltip.classList.add('visible');
    } else {
      tooltip.classList.remove('visible');
    }
  }

  function renderAll() {
    updateDerived();
    updateTracksHeight();
    renderTracks();
    renderTrackControls();
    updateFlowAndReadsPosition();
    renderFlowCanvas();
    renderReadsCanvas();
    renderHUD();
    updateTooltip();
    setupCanvasHover();
  }

  // Hit testing for WebGPU-rendered repeats (only add listeners once)
  if (tracksWebGPU && !tracksWebGPU._tooltipListenersAdded) {
    tracksWebGPU._tooltipListenersAdded = true;
    tracksWebGPU.addEventListener('mousemove', (e) => {
      if (!webgpuSupported || repeatHitTestData.length === 0) return;
      
      const rect = tracksWebGPU.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const isVertical = isVerticalMode();
      
      // Get RepeatMasker track layout to restrict hit testing to track bounds
      const layout = getTrackLayout();
      const repeatsLayout = layout.find(l => l.track.id === "repeats");
      if (!repeatsLayout || repeatsLayout.track.collapsed) return;
      
      let repeatsY, repeatsH;
      if (isVertical) {
        repeatsY = 16;
        repeatsH = tracksWidthPx() - 32; // W - 32 in vertical mode
      } else {
        repeatsY = repeatsLayout.contentTop + 8;
        repeatsH = 22;
      }
      
      // Only do hit testing if mouse is within RepeatMasker track bounds
      if (isVertical) {
        // In vertical mode, check X coordinate (genomic axis is vertical)
        const repeatsX = repeatsLayout.contentLeft + 8;
        const repeatsW = 22;
        if (x < repeatsX || x > repeatsX + repeatsW) {
          state.hoveredRepeatTooltip = null;
          updateTooltip();
          return;
        }
      } else {
        // In horizontal mode, check Y coordinate
        if (y < repeatsY || y > repeatsY + repeatsH) {
          state.hoveredRepeatTooltip = null;
          updateTooltip();
          return;
        }
      }
      
      // Convert mouse coordinates to genome position
      let bp;
      if (isVertical) {
        const H = tracksHeightPx();
        bp = bpFromYGenome(y, H);
      } else {
        const W = tracksWidthPx();
        bp = bpFromXGenome(x, W);
      }
      
      // Find overlapping repeat (check against original coordinates)
      const hitRepeat = repeatHitTestData.find(r => 
        bp >= r.start && bp <= r.end
      );
      
      if (hitRepeat) {
        state.hoveredRepeatTooltip = {
          text: `${hitRepeat.cls} repeat\n${Math.floor(hitRepeat.start).toLocaleString()} - ${Math.floor(hitRepeat.end).toLocaleString()}`,
          x: e.clientX + 10,
          y: e.clientY + 10
        };
      } else {
        state.hoveredRepeatTooltip = null;
      }
      updateTooltip();
    });
    
    tracksWebGPU.addEventListener('mouseleave', () => {
      state.hoveredRepeatTooltip = null;
      updateTooltip();
    });
  }

  // Setup hover detection for canvas elements
  let flowHoverHandler = null;
  let flowLeaveHandler = null;
  let readsHoverHandler = null;
  let readsLeaveHandler = null;

  function setupCanvasHover() {
    // Remove existing listeners to avoid duplicates
    if (flowHoverHandler) {
      flow.removeEventListener("mousemove", flowHoverHandler);
      flow.removeEventListener("mouseleave", flowLeaveHandler);
    }
    if (readsHoverHandler) {
      reads.removeEventListener("mousemove", readsHoverHandler);
      reads.removeEventListener("mouseleave", readsLeaveHandler);
    }

    // Flow canvas hover detection
    flowHoverHandler = (e) => {
      const rect = flow.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const isVertical = isVerticalMode();
      const variantMode = getVariantLayoutMode();
      const win = visibleVariantWindow();
      
      if (isVertical) {
        const junctionX = 40;
        const H = flowHeightPx();
        const sortedWin = [...win].sort((a, b) => a.pos - b.pos);
        
        // Check if mouse is near a column line (horizontal in vertical mode)
        for (let i = 0; i < sortedWin.length; i++) {
          const v = sortedWin[i];
          // Position based on variant layout mode
          const cy = variantMode === "genomic"
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          
          if (Math.abs(y - cy) < 10 && x >= junctionX) {
            if (state.hoveredVariantIndex !== variantIdx) {
              state.hoveredVariantIndex = variantIdx;
              renderAll();
            }
            return;
          }
        }
        
        // Check if mouse is near a diagonal connector
        const x0 = 6;
        for (let i = 0; i < sortedWin.length; i++) {
          const v = sortedWin[i];
          if (v.pos < state.startBp || v.pos > state.endBp) continue;
          const vy = yGenomeCanonical(v.pos, H); // always genomic for ruler connection
          const cy = variantMode === "genomic"
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          
          const dist = Math.abs((x - x0) * (cy - vy) / (junctionX - x0) + vy - y);
          if (dist < 5 && x >= x0 && x <= junctionX) {
            if (state.hoveredVariantIndex !== variantIdx) {
              state.hoveredVariantIndex = variantIdx;
              renderAll();
            }
            return;
          }
        }
      } else {
        const junctionY = 40;
        const W = flowWidthPx();
        
        // Check if mouse is near a column line
        for (let i = 0; i < win.length; i++) {
          // Position based on variant layout mode
          const cx = variantMode === "genomic"
            ? xGenomeCanonical(win[i].pos, W)
            : xColumn(i, win.length);
          const variantIdx = state.firstVariantIndex + i;
          
          if (Math.abs(x - cx) < 10 && y >= junctionY) {
            if (state.hoveredVariantIndex !== variantIdx) {
              state.hoveredVariantIndex = variantIdx;
              renderAll();
            }
            return;
          }
        }
        
        // Check if mouse is near a diagonal connector
        const y0 = 6;
        for (let i = 0; i < win.length; i++) {
          const v = win[i];
          if (v.pos < state.startBp || v.pos > state.endBp) continue;
          const vx = xGenomeCanonical(v.pos, W); // always genomic for ruler connection
          const cx = variantMode === "genomic"
            ? xGenomeCanonical(v.pos, W)
            : xColumn(i, win.length);
          const variantIdx = state.firstVariantIndex + i;
          
          const dist = Math.abs((y - y0) * (cx - vx) / (junctionY - y0) + vx - x);
          if (dist < 5 && y >= y0 && y <= junctionY) {
            if (state.hoveredVariantIndex !== variantIdx) {
              state.hoveredVariantIndex = variantIdx;
              renderAll();
            }
            return;
          }
        }
      }
      
      // No variant hovered
      if (state.hoveredVariantIndex !== null) {
        state.hoveredVariantIndex = null;
        renderAll();
      }
    };
    
    flowLeaveHandler = () => {
      if (state.hoveredVariantIndex !== null) {
        state.hoveredVariantIndex = null;
        renderAll();
      }
    };
    
    flow.addEventListener("mousemove", flowHoverHandler);
    flow.addEventListener("mouseleave", flowLeaveHandler);

    // Reads canvas hover detection
    readsHoverHandler = (e) => {
      const rect = reads.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const isVertical = isVerticalMode();
      
      if (isVertical) {
        const H = readsHeightPx();
        const left = 8;
        
        // Check if mouse is near a variant line (horizontal in vertical mode)
        for (let idx = 0; idx < variants.length; idx++) {
          const v = variants[idx];
          if (v.pos < state.startBp || v.pos > state.endBp) continue;
          const vy = yGenomeCanonical(v.pos, H);
          
          if (Math.abs(y - vy) < 10 && x >= left) {
            if (state.hoveredVariantIndex !== idx) {
              state.hoveredVariantIndex = idx;
              renderAll();
            }
            return;
          }
        }
      } else {
        const W = readsWidthPx();
        const top = 8;
        
        // Check if mouse is near a variant line
        for (let idx = 0; idx < variants.length; idx++) {
          const v = variants[idx];
          if (v.pos < state.startBp || v.pos > state.endBp) continue;
          const vx = xGenomeCanonical(v.pos, W);
          
          if (Math.abs(x - vx) < 10 && y >= top) {
            if (state.hoveredVariantIndex !== idx) {
              state.hoveredVariantIndex = idx;
              renderAll();
            }
            return;
          }
        }
      }
      
      // No variant hovered
      if (state.hoveredVariantIndex !== null) {
        state.hoveredVariantIndex = null;
        renderAll();
      }
    };
    
    readsLeaveHandler = () => {
      if (state.hoveredVariantIndex !== null) {
        state.hoveredVariantIndex = null;
        renderAll();
      }
    };
    
    reads.addEventListener("mousemove", readsHoverHandler);
    reads.addEventListener("mouseleave", readsLeaveHandler);
  }

  function updateFlowAndReadsPosition() {
    const layout = getTrackLayout();
    const isVertical = isVerticalMode();
    
    const flowLayout = layout.find(l => l.track.id === "flow");
    if (flowLayout) {
      if (isVertical) {
        flow.style.left = `${flowLayout.contentLeft}px`;
        flow.style.width = flowLayout.track.collapsed ? "0px" : `${flowLayout.contentWidth}px`;
        flow.style.top = "0";
        flow.style.height = "100%";
      } else {
        flow.style.top = `${flowLayout.contentTop}px`;
        flow.style.height = flowLayout.track.collapsed ? "0px" : `${flowLayout.contentHeight}px`;
        flow.style.left = "0";
        flow.style.width = "100%";
      }
      flow.style.display = flowLayout.track.collapsed ? "none" : "block";
    }
    
    const readsLayout = layout.find(l => l.track.id === "reads");
    if (readsLayout) {
      if (isVertical) {
        reads.style.left = `${readsLayout.contentLeft}px`;
        // Extend Reads track to the right edge of the main container
        const mainWidth = rectW(main);
        reads.style.width = readsLayout.track.collapsed ? "0px" : `${mainWidth - readsLayout.contentLeft}px`;
        reads.style.top = "0";
        reads.style.height = "100%";
      } else {
        reads.style.top = `${readsLayout.contentTop}px`;
        reads.style.height = readsLayout.track.collapsed ? "0px" : `${readsLayout.contentHeight}px`;
        reads.style.left = "0";
        reads.style.width = "100%";
      }
      reads.style.display = readsLayout.track.collapsed ? "none" : "block";
    }
  }

  // -----------------------------
  // Pan + Zoom helpers
  // -----------------------------
  function clampSpan(span) {
    const MIN_SPAN = 50;
    const MAX_SPAN = 5_000_000;
    return Math.max(MIN_SPAN, Math.min(MAX_SPAN, span));
  }

  function zoomByFactor(factor, anchorBp) {
    const oldSpan = state.endBp - state.startBp;
    const newSpan = clampSpan(oldSpan / factor);

    const leftFrac = (anchorBp - state.startBp) / oldSpan;
    const newStart = anchorBp - leftFrac * newSpan;

    state.startBp = newStart;
    state.endBp = newStart + newSpan;

    // Clamp to chromosome boundaries
    clampToChromosomeBounds();

    renderAll();
  }

  function panByPixels(dxPx, dyPx) {
    const isVertical = isVerticalMode();
    const deltaPx = isVertical ? (dyPx !== undefined ? dyPx : 0) : (dxPx !== undefined ? dxPx : 0);
    const deltaBp = deltaPx / state.pxPerBp;
    // In vertical mode: down = lower locus (increase), up = higher locus (decrease)
    // In horizontal mode: right = higher locus (increase), left = lower locus (decrease)
    if (isVertical) {
      state.startBp += deltaBp;
      state.endBp   += deltaBp;
    } else {
      state.startBp -= deltaBp;
      state.endBp   -= deltaBp;
    }

    // Clamp to chromosome boundaries
    clampToChromosomeBounds();

    // Placeholder heuristic for shifting the variant window
    const win = visibleVariantWindow();
    if (win.length > 0) {
      const first = win[0].pos;
      while (state.firstVariantIndex > 0 && first > state.endBp) state.firstVariantIndex--;
      while (state.firstVariantIndex + 1 < variants.length &&
             first < state.startBp - (state.endBp-state.startBp)*0.25) {
        state.firstVariantIndex++;
        if (state.firstVariantIndex + state.K > variants.length) break;
      }
      state.firstVariantIndex = Math.max(0, Math.min(state.firstVariantIndex, Math.max(0, variants.length - state.K)));
    }

    renderAll();
  }

  function anchorBpFromClientX(clientX) {
    const rect = tracksSvg.getBoundingClientRect();
    const xInPane = clientX - rect.left;
    return bpFromXGenome(xInPane, tracksWidthPx());
  }
  function anchorBpFromClientY(clientY) {
    const rect = tracksSvg.getBoundingClientRect();
    const yInPane = clientY - rect.top;
    return bpFromYGenome(yInPane, tracksHeightPx());
  }
  function anchorBpFromClient(clientX, clientY) {
    const isVertical = isVerticalMode();
    if (isVertical) {
      return anchorBpFromClientY(clientY);
    } else {
      return anchorBpFromClientX(clientX);
    }
  }

  // -----------------------------
  // Interaction (right pane)
  // -----------------------------
  main.addEventListener("pointerdown", (e) => {
    // Don't start drag if clicking on a variant (for insertion expansion)
    // Check if clicking on SVG elements that are variants
    const target = e.target;
    if (target && target.tagName && (target.tagName === "line" || target.tagName === "circle" || target.tagName === "rect")) {
      // Check if this is a variant element (has blue stroke or is in the variant area)
      const stroke = target.getAttribute ? target.getAttribute("stroke") : null;
      if (stroke && (stroke === "var(--blue)" || stroke === cssVar("--blue") || stroke.includes("blue"))) {
        // This might be a variant - don't start dragging, let click handler work
        return;
      }
      // Also check if it's the invisible click area for insertions
      if (target.getAttribute && target.getAttribute("fill") === "transparent" && target.getAttribute("width") === "10") {
        return;
      }
    }
    
    state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    main.setPointerCapture(e.pointerId);

    if (state.pointers.size === 1) {
      state.dragging = true;
      state.lastX = e.clientX;
      state.lastY = e.clientY;
    } else {
      state.dragging = false;
    }
  });

  main.addEventListener("pointermove", (e) => {
    if (!state.pointers.has(e.pointerId)) return;
    state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

    if (state.pointers.size === 2) {
      const pts = Array.from(state.pointers.values());
      const dx = pts[0].x - pts[1].x;
      const dy = pts[0].y - pts[1].y;
      const dist = Math.hypot(dx, dy);

      if (state.pinchStartDist == null) {
        state.pinchStartDist = dist;
        state.pinchStartSpan = (state.endBp - state.startBp);

        const midX = (pts[0].x + pts[1].x) / 2;
        const midY = (pts[0].y + pts[1].y) / 2;
        state.pinchAnchorBp = anchorBpFromClient(midX, midY);
      } else {
        const scale = dist / state.pinchStartDist; // >1 apart => zoom in
        const oldSpan = state.pinchStartSpan;
        const newSpan = clampSpan(oldSpan / scale);

        const anchorBp = state.pinchAnchorBp ?? (state.startBp + (state.endBp-state.startBp)/2);
        const leftFrac = (anchorBp - state.startBp) / (state.endBp - state.startBp);
        const newStart = anchorBp - leftFrac * newSpan;

        state.startBp = newStart;
        state.endBp = newStart + newSpan;

        // Clamp to chromosome boundaries
        clampToChromosomeBounds();

        renderAll();
      }
      return;
    }

    if (state.dragging) {
      const isVertical = isVerticalMode();
      const dx = e.clientX - state.lastX;
      const dy = e.clientY - state.lastY;
      state.lastX = e.clientX;
      state.lastY = e.clientY;
      if (isVertical) {
        panByPixels(0, -dy);
      } else {
        panByPixels(-dx, 0);
      }
    }
  });

  function endPointer(e) {
    state.pointers.delete(e.pointerId);
    if (state.pointers.size < 2) {
      state.pinchStartDist = null;
      state.pinchStartSpan = null;
      state.pinchAnchorBp = null;
    }
    if (state.pointers.size === 0) state.dragging = false;
  }
  main.addEventListener("pointerup", endPointer);
  main.addEventListener("pointercancel", endPointer);

  // Wheel: default zoom (no ctrl/meta), shift+wheel (or horizontal) pan
  main.addEventListener("wheel", (e) => {
    if (e.ctrlKey || e.metaKey) return;

    const isVertical = isVerticalMode();
    const dx = e.deltaX;
    const dy = e.deltaY;
    
    if (isVertical) {
      // In vertical mode: vertical wheel = pan, horizontal wheel = zoom
      const wantPan = e.shiftKey || Math.abs(dy) > Math.abs(dx);
      
      if (wantPan) {
        e.preventDefault();
        const panDy = e.shiftKey ? dx : dy;
        panByPixels(0, panDy);
        return;
      }

      e.preventDefault();
      const zoomIntensity = 0.0018;
      const factor = Math.exp(-dx * zoomIntensity);

      const anchorBp = anchorBpFromClientY(e.clientY);
      zoomByFactor(factor, anchorBp);
    } else {
      // In horizontal mode: horizontal wheel = pan, vertical wheel = zoom
      const wantPan = e.shiftKey || Math.abs(dx) > Math.abs(dy);

      if (wantPan) {
        e.preventDefault();
        const panDx = e.shiftKey ? dy : dx;
        panByPixels(panDx, 0);
        return;
      }

      e.preventDefault();
      const zoomIntensity = 0.0018;
      const factor = Math.exp(-dy * zoomIntensity);

      const anchorBp = anchorBpFromClientX(e.clientX);
      zoomByFactor(factor, anchorBp);
    }
  }, { passive: false });

  main.addEventListener("dblclick", (e) => {
    const anchorBp = anchorBpFromClient(e.clientX, e.clientY);
    zoomByFactor(1.6, anchorBp);
  });

  // -----------------------------
  // Track interactions (drag, resize)
  // -----------------------------
  if (trackControls) {
  trackControls.addEventListener("pointerdown", (e) => {
    // Don't start drag if clicking on collapse button
    if (e.target.closest(".track-collapse-btn")) {
      e.stopPropagation();
      return;
    }
    
    const controls = e.target.closest(".track-controls");
    const resizeHandle = e.target.closest(".track-resize-handle");
    
    if (resizeHandle) {
      // Start resizing
      e.stopPropagation();
      const trackId = resizeHandle.dataset.trackId;
      const track = state.tracks.find(t => t.id === trackId);
      if (!track) return;
      
      e.preventDefault();
      const isVertical = isVerticalMode();
      state.trackResizeState = {
        trackId,
        startX: e.clientX,
        startY: e.clientY,
        startHeight: track.height
      };
      trackControls.setPointerCapture(e.pointerId);
    } else if (controls) {
      // Start dragging for reorder
      e.stopPropagation();
      const trackId = controls.dataset.trackId;
      e.preventDefault();
      const isVertical = isVerticalMode();
      state.trackDragState = {
        trackId,
        startX: e.clientX,
        startY: e.clientY,
        offsetX: 0,
        offsetY: 0
      };
      trackControls.setPointerCapture(e.pointerId);
    }
  });

  trackControls.addEventListener("pointermove", (e) => {
    if (state.trackResizeState) {
      // Resizing
      const track = state.tracks.find(t => t.id === state.trackResizeState.trackId);
      if (!track) return;
      
      e.preventDefault();
      const isVertical = isVerticalMode();
      let delta;
      if (isVertical) {
        // In vertical mode, resize based on horizontal movement
        delta = e.clientX - state.trackResizeState.startX;
      } else {
        // In horizontal mode, resize based on vertical movement
        delta = e.clientY - state.trackResizeState.startY;
      }
      const newHeight = Math.max(track.minHeight, state.trackResizeState.startHeight + delta);
      track.height = newHeight;
      updateTracksHeight();
      renderAll();
    } else if (state.trackDragState) {
      // Dragging for reorder
      e.preventDefault();
      const isVertical = isVerticalMode();
      const dx = e.clientX - state.trackDragState.startX;
      const dy = e.clientY - state.trackDragState.startY;
      
      if (isVertical) {
        state.trackDragState.offsetX = dx;
      } else {
        state.trackDragState.offsetY = dy;
      }
      
      // Visual feedback: move the dragged track
      const layout = getTrackLayout();
      const draggedItem = layout.find(l => l.track.id === state.trackDragState.trackId);
      if (draggedItem) {
        const container = trackControls.querySelector(`[data-track-id="${state.trackDragState.trackId}"]`);
        if (container) {
          if (isVertical) {
            container.style.transform = `translateX(${dx}px)`;
          } else {
            container.style.transform = `translateY(${dy}px)`;
          }
          container.style.zIndex = "100";
          container.style.opacity = "0.8";
        }
      }
    }
  });

  function endTrackInteraction(e) {
    // Only process if we have an active interaction
    if (!state.trackResizeState && !state.trackDragState) return;
    
    // Release pointer capture
    if (e.target.releasePointerCapture) {
      try {
        e.target.releasePointerCapture(e.pointerId);
      } catch (err) {
        // Ignore if already released
      }
    }
    
    if (state.trackResizeState) {
      state.trackResizeState = null;
    } else if (state.trackDragState) {
      // Handle reordering
      const layout = getTrackLayout();
      const draggedItem = layout.find(l => l.track.id === state.trackDragState.trackId);
      if (draggedItem) {
        const container = trackControls.querySelector(`[data-track-id="${state.trackDragState.trackId}"]`);
        if (container) {
          container.style.transform = "";
          container.style.zIndex = "";
          container.style.opacity = "";
        }
        
        // Find new position based on orientation
        const isVertical = isVerticalMode();
        let newIndex = 0;
        if (isVertical) {
          const newX = draggedItem.left + state.trackDragState.offsetX;
          for (let i = 0; i < layout.length; i++) {
            if (newX > layout[i].left + layout[i].width / 2) {
              newIndex = i + 1;
            }
          }
        } else {
          const newY = draggedItem.top + state.trackDragState.offsetY;
          for (let i = 0; i < layout.length; i++) {
            if (newY > layout[i].top + layout[i].height / 2) {
              newIndex = i + 1;
            }
          }
        }
        newIndex = Math.max(0, Math.min(newIndex, layout.length - 1));
        
        // Reorder tracks
        const currentIndex = state.tracks.findIndex(t => t.id === state.trackDragState.trackId);
        if (currentIndex !== newIndex && currentIndex !== -1) {
          const [track] = state.tracks.splice(currentIndex, 1);
          state.tracks.splice(newIndex, 0, track);
          renderAll();
        } else {
          // Just re-render to reset visual state
          renderAll();
        }
      }
      state.trackDragState = null;
    }
  }

  trackControls.addEventListener("pointerup", endTrackInteraction);
  trackControls.addEventListener("pointercancel", endTrackInteraction);
  
  // Also listen on document to catch pointerup events that might occur outside
  document.addEventListener("pointerup", (e) => {
    if (state.trackResizeState || state.trackDragState) {
      endTrackInteraction(e);
    }
  });
  document.addEventListener("pointercancel", (e) => {
    if (state.trackResizeState || state.trackDragState) {
      endTrackInteraction(e);
    }
  });
  }

  // Resize
  new ResizeObserver(() => {
    // Handle WebGPU canvas resize
    if (webgpuCore && webgpuSupported) {
      try {
        webgpuCore.handleResize();
      } catch (error) {
        console.error("WebGPU resize error:", error);
      }
    }
    renderAll();
  }).observe(flow);
  new ResizeObserver(() => renderAll()).observe(reads);
  new ResizeObserver(() => {
    // Handle WebGPU canvas resize when tracks container resizes
    if (webgpuCore && webgpuSupported) {
      try {
        webgpuCore.handleResize();
      } catch (error) {
        console.error("WebGPU resize error:", error);
      }
    }
    renderAll();
  }).observe(tracksSvg);
  window.addEventListener("resize", () => {
    // Handle WebGPU canvas resize
    if (webgpuCore && webgpuSupported) {
      try {
        webgpuCore.handleResize();
      } catch (error) {
        console.error("WebGPU resize error:", error);
      }
    }
    renderAll();
  });

  renderAll();
</script>
</body>
</html>