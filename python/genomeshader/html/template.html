<!doctype html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Genomeshader Prototype (SVG scaffolding)</title>

  <!--__GENOMESHADER_BOOTSTRAP__-->

  <style>
    :root {
      --sidebar-w: 240px;
      --tracks-h: 280px;   /* ideogram + genes + repeats + ruler */
      --flow-h: 500px;     /* sankey placeholder */
      --reads-h: 220px;    /* IGV-style reads area placeholder */

      --bg: #0b0d10;
      --panel: #11151b;
      --panel2: rgba(255,255,255,0.03);

      --border: rgba(255,255,255,0.10);
      --border2: rgba(255,255,255,0.08);

      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --muted2: rgba(255,255,255,0.45);

      --grid: rgba(255,255,255,0.12);
      --grid2: rgba(255,255,255,0.07);

      --accent: #ff4d4d;

      --blue: rgba(120,180,255,0.9);
      --blueFill: rgba(120,180,255,0.18);

      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --hudBg: rgba(0,0,0,0.35);
    }

    html[data-theme="light"] {
      --bg: #f7f8fb;
      --panel: #ffffff;
      --panel2: rgba(0,0,0,0.03);

      --border: rgba(0,0,0,0.12);
      --border2: rgba(0,0,0,0.10);

      --text: rgba(0,0,0,0.90);
      --muted: rgba(0,0,0,0.62);
      --muted2: rgba(0,0,0,0.45);

      --grid: rgba(0,0,0,0.12);
      --grid2: rgba(0,0,0,0.07);

      --accent: #d81b1b;

      --blue: rgba(18, 110, 255, 0.85);
      --blueFill: rgba(18, 110, 255, 0.14);

      --shadow: 0 10px 30px rgba(0,0,0,0.12);
      --hudBg: rgba(255,255,255,0.78);
    }

    @media (prefers-color-scheme: light) {
      html[data-theme="auto"] {
        --bg: #f7f8fb;
        --panel: #ffffff;
        --panel2: rgba(0,0,0,0.03);

        --border: rgba(0,0,0,0.12);
        --border2: rgba(0,0,0,0.10);

        --text: rgba(0,0,0,0.90);
        --muted: rgba(0,0,0,0.62);
        --muted2: rgba(0,0,0,0.45);

        --grid: rgba(0,0,0,0.12);
        --grid2: rgba(0,0,0,0.07);

        --accent: #d81b1b;

        --blue: rgba(18, 110, 255, 0.85);
        --blueFill: rgba(18, 110, 255, 0.14);

        --shadow: 0 10px 30px rgba(0,0,0,0.12);
        --hudBg: rgba(255,255,255,0.78);
      }
    }
    @media (prefers-color-scheme: dark) {
      html[data-theme="auto"] {
        --bg: #0b0d10;
        --panel: #11151b;
        --panel2: rgba(255,255,255,0.03);

        --border: rgba(255,255,255,0.10);
        --border2: rgba(255,255,255,0.08);

        --text: rgba(255,255,255,0.92);
        --muted: rgba(255,255,255,0.65);
        --muted2: rgba(255,255,255,0.45);

        --grid: rgba(255,255,255,0.12);
        --grid2: rgba(255,255,255,0.07);

        --accent: #ff4d4d;

        --blue: rgba(120,180,255,0.9);
        --blueFill: rgba(120,180,255,0.18);

        --shadow: 0 10px 30px rgba(0,0,0,0.35);
        --hudBg: rgba(0,0,0,0.35);
      }
    }

    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui; }
    * { box-sizing: border-box; }

    .app {
      display: grid;
      grid-template-columns: var(--sidebar-w) 1fr;
      height: 100%;
      overflow: hidden;
      transition: grid-template-columns 0.2s ease;
    }
    .app.sidebar-collapsed {
      grid-template-columns: 12px 1fr;
    }
    .app.sidebar-collapsed .sidebar {
      width: 12px !important;
      min-width: 12px;
    }

    .sidebar {
      position: relative;
      background: var(--panel);
      border-right: 1px solid var(--border2);
      padding: 12px;
      overflow: visible;
      padding-bottom: 56px; /* space for gear button */
      transition: opacity 0.2s ease;
    }
    .sidebar::after {
      content: "";
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease, width 0.2s ease, box-shadow 0.2s ease;
      z-index: 10;
    }
    .sidebar:hover::after {
      background: var(--blue);
      width: 6px;
      box-shadow: 0 0 8px rgba(120, 180, 255, 0.4);
    }
    .app.sidebar-collapsed .sidebar {
      padding: 0;
      overflow: visible;
    }
    .app.sidebar-collapsed .sidebar > * {
      opacity: 0;
      pointer-events: none;
    }
    .app.sidebar-collapsed .sidebar::after {
      pointer-events: auto;
      opacity: 1 !important;
      right: 0;
      width: 12px;
      background: rgba(127, 127, 127, 0.08);
      border-right: 1px solid var(--border2);
    }
    .app.sidebar-collapsed .sidebar:hover::after {
      width: 14px;
      background: var(--blue);
      border-right: none;
      box-shadow: 0 0 12px rgba(120, 180, 255, 0.5);
    }
    /* Adjust main panel position when sidebar is collapsed */
    .app.sidebar-collapsed .main {
      left: 12px !important;
    }

    .sidebarHeader {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      margin-bottom: 10px;
      gap: 8px;
    }
    
    .sidebarToggle {
      width: 24px;
      height: 24px;
      border: 1px solid var(--border2);
      background: var(--panel2);
      color: var(--text);
      border-radius: 6px;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      padding: 0;
      flex-shrink: 0;
      transition: all 0.15s ease;
    }
    .sidebarToggle:hover {
      background: var(--panel);
      border-color: var(--border);
    }
    .sidebarToggle:active {
      transform: scale(0.95);
    }
    
    .sidebarHeader h3 {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
      font-weight: 650;
      letter-spacing: 0.02em;
    }

    .group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 9px 10px;
      margin: 7px 0;
      border-radius: 10px;
      background: var(--panel2);
      cursor: pointer;
      user-select: none;
      border: 1px solid transparent;
    }
    .group:hover { border-color: var(--border2); }
    .pill { font-size: 12px; padding: 2px 8px; border-radius: 999px; background: rgba(127,127,127,0.16); color: var(--muted); }

    /* Gear button bottom-left (requested) */
    .gearBtn {
      position: absolute !important;
      left: 12px !important;
      bottom: 12px !important;
      top: auto !important;
      right: auto !important;
      border: 1px solid var(--border2);
      background: var(--panel2);
      color: var(--text);
      width: 36px;
      height: 36px;
      border-radius: 12px;
      cursor: pointer;
      user-select: none;
      display: grid;
      place-items: center;
      font-size: 18px;
      line-height: 1;
    }
    .gearBtn:hover { filter: brightness(1.06); }
    .gearBtn:active { transform: translateY(1px); }

    /* Context menu */
    .menu {
      position: absolute;
      min-width: 220px;
      padding: 8px;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      z-index: 50;
      display: none;
    }
    .menu.open { display: block; }
    .menuTitle {
      font-size: 11px;
      color: var(--muted2);
      padding: 6px 8px 4px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }
    .menuItem {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 10px;
      border-radius: 10px;
      cursor: pointer;
      user-select: none;
      color: var(--text);
      font-size: 13px;
    }
    .menuItem:hover { background: var(--panel2); }
    .menuRight { color: var(--muted); font-size: 12px; }

    .main {
      position: relative;
      overflow: hidden;
      touch-action: none; /* we own pan/zoom gestures on right pane */
    }

    .tracks {
      position: absolute;
      left: 0; top: 0; right: 0;
      height: var(--tracks-h);
      border-bottom: 1px solid var(--border);
      background: linear-gradient(to bottom, rgba(127,127,127,0.08), rgba(127,127,127,0.00));
    }
    #trackControls {
      position: absolute;
      inset: 0;
      z-index: 20;
      pointer-events: none;
    }

    .flow {
      position: absolute;
      left: 0; right: 0;
      background: rgba(127,127,127,0.04);
    }

    .reads {
      position: absolute;
      left: 0; right: 0;
      background: rgba(127,127,127,0.02);
    }

    /* Vertical mode: tracks laid out side-by-side */
    .main.vertical .tracks {
      display: flex;
      flex-direction: row;
      height: 100%;
      width: 100%;
      left: 0;
      top: 0;
      right: auto;
      bottom: 0;
      border-bottom: none;
      border-right: 1px solid var(--border);
    }

    .main.vertical .flow,
    .main.vertical .reads {
      position: absolute;
      top: 0;
      bottom: 0;
      height: 100%;
    }

    canvas.canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    canvas.webgpu-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      pointer-events: auto;
      z-index: 1; /* Above SVG, below controls */
    }

    svg.overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    /* Locus indicator lower-right */
    .hud {
      position: absolute;
      right: 10px;
      bottom: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      background: var(--hudBg);
      border: 1px solid var(--border2);
      font-size: 12px;
      color: var(--muted);
      backdrop-filter: blur(6px);
      pointer-events: none;
      white-space: nowrap;
      box-shadow: var(--shadow);
      display: none;
      transition: opacity 0.3s ease;
    }
    /* In vertical mode, position HUD in upper right */
    .main.vertical .hud {
      bottom: auto;
      top: 10px;
    }
    .hud.visible {
      display: block;
    }

    /* Tooltip */
    .tooltip {
      position: fixed;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--panel);
      border: 1px solid var(--border);
      font-size: 12px;
      color: var(--text);
      pointer-events: none;
      z-index: 1000;
      white-space: pre-line;
      box-shadow: var(--shadow);
      display: none;
      line-height: 1.4;
    }
    .tooltip.visible {
      display: block;
    }

    /* SVG text classes */
    .svg-label { fill: var(--muted); font-size: 12px; font-weight: 600; }
    .svg-small { fill: var(--muted2); font-size: 10px; }
    .svg-chr   { fill: var(--text); font-size: 12px; font-weight: 650; }

    .svg-geneName { fill: rgba(180,220,255,0.92); font-size: 11px; font-weight: 650; }
    html[data-theme="light"] .svg-geneName { fill: rgba(18, 110, 255, 0.92); }
    @media (prefers-color-scheme: light) {
      html[data-theme="auto"] .svg-geneName { fill: rgba(18, 110, 255, 0.92); }
    }
    @media (prefers-color-scheme: dark) {
      html[data-theme="auto"] .svg-geneName { fill: rgba(180,220,255,0.92); }
    }

    .svg-trackHint { fill: var(--muted2); font-size: 11px; }

    /* Track controls */
    .track-controls {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      height: 24px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 12px;
      background: rgba(127,127,127,0.03);
      border-bottom: 1px solid var(--border2);
      z-index: 10;
      cursor: move;
    }
    .main.vertical .track-controls {
      top: auto;
    }
    .track-controls:hover { background: rgba(127,127,127,0.06); }

    .track-collapse-btn {
      width: 18px;
      height: 18px;
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      padding: 0;
      border-radius: 4px;
      flex-shrink: 0;
    }
    .track-collapse-btn:hover { background: var(--panel2); color: var(--text); }
    .track-collapse-btn:active { transform: scale(0.95); }

    .track-label {
      flex: 1;
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
      user-select: none;
      pointer-events: none;
    }

    /* Vertical mode: track controls at bottom, vertically oriented */
    .main.vertical .track-control-container {
      position: absolute;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      align-items: flex-start;
    }
    .main.vertical .track-controls {
      width: 24px;
      height: 100%;
      flex-direction: column;
      padding: 0;
      border-bottom: none;
      border-right: 1px solid var(--border2);
      position: relative;
      left: 0;
      right: auto;
      transform: none;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      margin-bottom: 0;
    }
    .main.vertical .track-label {
      order: 1;
      white-space: nowrap;
      writing-mode: horizontal-tb;
      margin: 0;
      position: absolute;
      bottom: 0;
      left: 50%;
      transform-origin: left center;
      flex-shrink: 0;
      /* Default transform to prevent flash of unstyled content */
      transform: rotate(-90deg) translateX(12px) translateY(0.0px);
    }
    .main.vertical .track-collapse-btn {
      align-self: center;
      order: 2;
      margin-top: 0;
      margin-bottom: 0;
    }

    .track-resize-handle {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 6px;
      cursor: ns-resize;
      z-index: 15;
      background: transparent;
      pointer-events: auto;
    }
    .track-resize-handle:hover {
      background: var(--accent);
      opacity: 0.3;
    }
    .track-resize-handle:active {
      background: var(--accent);
      opacity: 0.6;
    }
    .main.vertical .track-resize-handle {
      left: auto;
      right: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      height: 100%;
      cursor: ew-resize;
    }

    .track-content {
      position: absolute;
      left: 0;
      right: 0;
      top: 24px;
      bottom: 0;
      overflow: hidden;
    }

    .track-control-container {
      pointer-events: none;
    }
    .track-control-container .track-controls,
    .track-control-container .track-resize-handle {
      pointer-events: auto;
    }

  </style>
</head>

<body>
  <div class="app" style="position: relative; display: block;">
    <div class="sidebar" id="sidebar" style="position: absolute; left: 0; top: 0; bottom: 0; width: 240px; z-index: 100; pointer-events: auto;">
      <div class="sidebarHeader">
        <h3>Participant groups</h3>
      </div>

      <div class="group"><span>AFR</span><span class="pill">2634</span></div>
      <div class="group"><span>AMR</span><span class="pill">603</span></div>
      <div class="group"><span>EAS</span><span class="pill">1095</span></div>
      <div class="group"><span>EUR</span><span class="pill">5340</span></div>
      <div class="group"><span>SAS</span><span class="pill">328</span></div>

      <button class="gearBtn" id="menuBtn" title="Settings" aria-label="Settings">⚙︎</button>

      <div class="menu" id="ctxMenu" role="menu" aria-hidden="true">
        <div class="menuTitle">Display</div>
        <div class="menuItem" id="themeItem" role="menuitem">
          <span>Theme</span>
          <span class="menuRight" id="themeLabel">Auto</span>
        </div>

        <div class="menuItem" id="orientationItem" role="menuitem">
          <span>Orientation</span>
          <span class="menuRight" id="orientationLabel">Horizontal</span>
        </div>

        <div class="menuItem" id="variantLayoutModeItem" role="menuitem">
          <span>Variant Layout</span>
          <span class="menuRight" id="variantLayoutModeLabel">Equidistant</span>
        </div>

        <div class="menuItem" id="fullscreenItem" role="menuitem">
          <span>Full screen</span>
          <span class="menuRight" id="fullscreenLabel">Enter full screen</span>
        </div>

        <div class="menuTitle">Grouping</div>
        <div class="menuItem" role="menuitem">
          <span>Variable</span>
          <span class="menuRight">Super-pop</span>
        </div>
      </div>
    </div>

    <div class="main" id="main" style="position: absolute; left: 240px; top: 0; right: 0; bottom: 0; z-index: 1;">
      <div class="tracks" id="tracksContainer">
        <svg id="tracksSvg" width="100%" height="100%"></svg>
        <canvas id="tracksWebGPU" class="webgpu-canvas" width="100%" height="100%"></canvas>
        <div id="trackControls"></div>
      </div>

      <div class="flow" id="flow">
        <canvas class="canvas" id="flowCanvas"></canvas>
        <canvas id="flowWebGPU" class="webgpu-canvas" width="100%" height="100%"></canvas>
        <svg class="overlay" id="flowOverlay"></svg>
      </div>

      <div class="reads" id="reads">
        <canvas class="canvas" id="readsCanvas"></canvas>
        <svg class="overlay" id="readsOverlay"></svg>
      </div>

      <div class="hud" id="hud"></div>
      <div class="tooltip" id="tooltip"></div>
    </div>
  </div>

<script type="module">
  // -----------------------------
  // WebGPU Classes (inlined to avoid module import issues with blob URLs)
  // -----------------------------
  class WebGPUCore {
    constructor() {
      this.device = null;
      this.context = null;
      this.canvas = null;
      this.format = null;
      this.projectionMatrix = null;
      this.screenSize = null;
      this.projectionBuffer = null;
    }

    async init(canvas) {
      if (!navigator.gpu) {
        throw new Error('WebGPU is not supported in this browser');
      }

      this.canvas = canvas;
      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) {
        throw new Error('Failed to get WebGPU adapter');
      }

      this.device = await adapter.requestDevice();
      this.format = navigator.gpu.getPreferredCanvasFormat();
      
      this.context = canvas.getContext('webgpu');
      if (!this.context) {
        throw new Error('Failed to get WebGPU context');
      }

      const devicePixelRatio = window.devicePixelRatio || 1;
      const width = canvas.clientWidth * devicePixelRatio;
      const height = canvas.clientHeight * devicePixelRatio;

      this.context.configure({
        device: this.device,
        format: this.format,
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
        alphaMode: 'premultiplied',
      });

      // Create projection matrix buffer (orthographic 2D projection)
      this.projectionMatrix = new Float32Array([
        2.0 / width, 0, 0, 0,
        0, -2.0 / height, 0, 0,
        0, 0, 1, 0,
        -1, 1, 0, 1
      ]);
      
      // Pad vec2 to vec4 for 16-byte alignment (vec2 = 8 bytes, needs padding to 16)
      this.screenSize = new Float32Array([width, height, 0, 0]);

      this.projectionBuffer = this.device.createBuffer({
        size: (16 + 4) * 4, // mat4x4 (16 floats) + vec4 padded (4 floats) = 20 floats * 4 bytes = 80 bytes
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      });

      // Write projection matrix and screen size to buffer
      this.device.queue.writeBuffer(this.projectionBuffer, 0, this.projectionMatrix);
      this.device.queue.writeBuffer(this.projectionBuffer, 16 * 4, this.screenSize);

      // Handle resize
      window.addEventListener('resize', () => this.handleResize());
    }

    handleResize() {
      if (!this.canvas || !this.context) return;

      const devicePixelRatio = window.devicePixelRatio || 1;
      const width = this.canvas.clientWidth * devicePixelRatio;
      const height = this.canvas.clientHeight * devicePixelRatio;

      // Update canvas size
      this.canvas.width = width;
      this.canvas.height = height;

      // Update projection matrix
      this.projectionMatrix[0] = 2.0 / width;
      this.projectionMatrix[5] = -2.0 / height;
      this.projectionMatrix[12] = -1;
      this.projectionMatrix[13] = 1;
      
      // Update screen size (vec4 padded)
      this.screenSize[0] = width;
      this.screenSize[1] = height;
      this.screenSize[2] = 0;
      this.screenSize[3] = 0;

      this.device.queue.writeBuffer(this.projectionBuffer, 0, this.projectionMatrix);
      this.device.queue.writeBuffer(this.projectionBuffer, 16 * 4, this.screenSize);
    }

    getCurrentTexture() {
      return this.context.getCurrentTexture();
    }

    createCommandEncoder() {
      return this.device.createCommandEncoder();
    }

    submit(commands) {
      this.device.queue.submit(commands);
    }
  }

  class InstancedRenderer {
    constructor(webgpuCore) {
      this.core = webgpuCore;
      this.device = webgpuCore.device;
      
      // Rectangle rendering
      this.rectPipeline = null;
      this.rectInstances = [];
      this.rectBuffer = null;
      this.rectVertexBuffer = null;
      
      // Triangle rendering
      this.trianglePipeline = null;
      this.triangleInstances = [];
      this.triangleBuffer = null;
      this.triangleVertexBuffer = null;
      
      // Line rendering
      this.linePipeline = null;
      this.lineInstances = [];
      this.lineBuffer = null;
      
      this.init();
    }

    init() {
      this.createRectPipeline();
      this.createTrianglePipeline();
      this.createLinePipeline();
      this.createGeometryBuffers();
    }

    // Convert hex color to normalized RGBA
    hexToRgba(hex, alpha = 1.0) {
      if (typeof hex === 'string') {
        if (hex.startsWith('#')) {
          hex = hex.slice(1);
        }
        const r = parseInt(hex.slice(0, 2), 16) / 255;
        const g = parseInt(hex.slice(2, 4), 16) / 255;
        const b = parseInt(hex.slice(4, 6), 16) / 255;
        return [r, g, b, alpha];
      } else {
        // Assume it's a number (0xRRGGBB)
        const r = ((hex >> 16) & 0xFF) / 255;
        const g = ((hex >> 8) & 0xFF) / 255;
        const b = (hex & 0xFF) / 255;
        return [r, g, b, alpha];
      }
    }

    createRectPipeline() {
      const vertexShader = `
        struct Uniforms {
          projection: mat4x4<f32>,
          screenSize: vec2<f32>,
          _padding: vec2<f32>, // Padding for 16-byte alignment
        }
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        struct VertexOutput {
          @builtin(position) position: vec4<f32>,
          @location(1) @interpolate(flat) instanceMin: vec2<f32>,
          @location(2) @interpolate(flat) instanceMax: vec2<f32>,
          @location(3) @interpolate(flat) color: vec4<f32>,
        }

        @vertex
        fn vs_main(
          @builtin(vertex_index) vertexIndex: u32,
          @builtin(instance_index) instanceIndex: u32,
          @location(0) position: vec2<f32>,
          @location(1) size: vec2<f32>,
          @location(2) color: vec4<f32>
        ) -> VertexOutput {
          // Quad vertices: (-0.5, -0.5), (0.5, -0.5), (-0.5, 0.5), (0.5, 0.5)
          var quadPos = vec2<f32>(0.0);
          if (vertexIndex == 0u) {
            quadPos = vec2<f32>(-0.5, -0.5);
          } else if (vertexIndex == 1u) {
            quadPos = vec2<f32>(0.5, -0.5);
          } else if (vertexIndex == 2u) {
            quadPos = vec2<f32>(-0.5, 0.5);
          } else {
            quadPos = vec2<f32>(0.5, 0.5);
          }
          
          var worldPos = position + quadPos * size;
          var halfSize = size * 0.5;
          var output: VertexOutput;
          output.position = uniforms.projection * vec4<f32>(worldPos, 0.0, 1.0);
          output.instanceMin = position - halfSize;
          output.instanceMax = position + halfSize;
          output.color = color;
          return output;
        }
      `;

      const fragmentShader = `
        struct Uniforms {
          projection: mat4x4<f32>,
          screenSize: vec2<f32>,
          _padding: vec2<f32>, // Padding for 16-byte alignment
        }
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        @fragment
        fn fs_main(
          @builtin(position) fragCoord: vec4<f32>,
          @location(1) @interpolate(flat) instanceMin: vec2<f32>,
          @location(2) @interpolate(flat) instanceMax: vec2<f32>,
          @location(3) @interpolate(flat) color: vec4<f32>
        ) -> @location(0) vec4<f32> {
          // fragCoord.xy is in framebuffer pixel coordinates (not NDC)
          // This directly matches our world coordinates since we use an orthographic projection
          let worldPos = fragCoord.xy;
          
          // Get rectangle dimensions and center
          let size = instanceMax - instanceMin;
          let center = (instanceMin + instanceMax) * 0.5;
          let halfSize = size * 0.5;
          let minDim = min(size.x, size.y);
          
          // For very small rectangles (< 6px), don't apply rounding
          if (minDim < 6.0) {
            // Still need premultiplied alpha for correct blending
            return vec4<f32>(color.rgb * color.a, color.a);
          }
          
          // Apply rounded corners with radius 6 pixels
          let radius = 6.0;
          let actualRadius = min(radius, minDim * 0.5);
          
          // Proper rounded rectangle SDF
          // Calculate position relative to center
          let p = abs(worldPos - center);
          // Shrink the half-size by radius to get the inner rectangle
          let q = p - halfSize + actualRadius;
          // Distance to rounded rectangle: negative inside, positive outside
          let d = length(max(q, vec2<f32>(0.0))) + min(max(q.x, q.y), 0.0) - actualRadius;
          
          // Smooth edge with anti-aliasing (d < 0 means inside)
          let alpha = 1.0 - smoothstep(-0.5, 0.5, d);
          
          // Output premultiplied alpha for correct blending
          let finalAlpha = color.a * alpha;
          return vec4<f32>(color.rgb * finalAlpha, finalAlpha);
        }
      `;

      const vertexModule = this.device.createShaderModule({ code: vertexShader });
      const fragmentModule = this.device.createShaderModule({ code: fragmentShader });

      this.rectPipeline = this.device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: vertexModule,
          entryPoint: 'vs_main',
          buffers: [
            {
              arrayStride: 8 * 4, // position(8) + size(8) + color(16) = 32 bytes
              stepMode: 'instance',
              attributes: [
                { shaderLocation: 0, offset: 0, format: 'float32x2' }, // position
                { shaderLocation: 1, offset: 8, format: 'float32x2' }, // size
                { shaderLocation: 2, offset: 16, format: 'float32x4' }, // color
              ],
            },
          ],
        },
        fragment: {
          module: fragmentModule,
          entryPoint: 'fs_main',
          targets: [{
            format: this.core.format,
            blend: {
              color: {
                srcFactor: 'one',
                dstFactor: 'one-minus-src-alpha',
                operation: 'add',
              },
              alpha: {
                srcFactor: 'one',
                dstFactor: 'one-minus-src-alpha',
                operation: 'add',
              },
            },
          }],
        },
        primitive: {
          topology: 'triangle-strip',
        },
      });
    }

    createTrianglePipeline() {
      const vertexShader = `
        struct Uniforms {
          projection: mat4x4<f32>,
        }
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        struct VertexOutput {
          @builtin(position) position: vec4<f32>,
          @location(3) @interpolate(flat) color: vec4<f32>,
        }

        @vertex
        fn vs_main(
          @builtin(vertex_index) vertexIndex: u32,
          @builtin(instance_index) instanceIndex: u32,
          @location(0) v0: vec2<f32>,
          @location(1) v1: vec2<f32>,
          @location(2) v2: vec2<f32>,
          @location(3) color: vec4<f32>
        ) -> VertexOutput {
          var pos: vec2<f32>;
          if (vertexIndex == 0u) {
            pos = v0;
          } else if (vertexIndex == 1u) {
            pos = v1;
          } else {
            pos = v2;
          }
          var output: VertexOutput;
          output.position = uniforms.projection * vec4<f32>(pos, 0.0, 1.0);
          output.color = color;
          return output;
        }
      `;

      const fragmentShader = `
        @fragment
        fn fs_main(
          @location(3) @interpolate(flat) color: vec4<f32>
        ) -> @location(0) vec4<f32> {
          return color;
        }
      `;

      const vertexModule = this.device.createShaderModule({ code: vertexShader });
      const fragmentModule = this.device.createShaderModule({ code: fragmentShader });

      this.trianglePipeline = this.device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: vertexModule,
          entryPoint: 'vs_main',
          buffers: [
            {
              arrayStride: 10 * 4, // v0(8) + v1(8) + v2(8) + color(16) = 40 bytes = 10 floats
              stepMode: 'instance',
              attributes: [
                { shaderLocation: 0, offset: 0, format: 'float32x2' }, // v0
                { shaderLocation: 1, offset: 8, format: 'float32x2' }, // v1
                { shaderLocation: 2, offset: 16, format: 'float32x2' }, // v2
                { shaderLocation: 3, offset: 24, format: 'float32x4' }, // color
              ],
            },
          ],
        },
        fragment: {
          module: fragmentModule,
          entryPoint: 'fs_main',
          targets: [{ format: this.core.format }],
        },
        primitive: {
          topology: 'triangle-list',
        },
      });
    }

    createLinePipeline() {
      const vertexShader = `
        struct Uniforms {
          projection: mat4x4<f32>,
        }
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        struct VertexOutput {
          @builtin(position) position: vec4<f32>,
          @location(2) @interpolate(flat) color: vec4<f32>,
        }

        @vertex
        fn vs_main(
          @builtin(vertex_index) vertexIndex: u32,
          @builtin(instance_index) instanceIndex: u32,
          @location(0) start: vec2<f32>,
          @location(1) end: vec2<f32>,
          @location(2) color: vec4<f32>
        ) -> VertexOutput {
          var pos: vec2<f32>;
          if (vertexIndex == 0u) {
            pos = start;
          } else {
            pos = end;
          }
          var output: VertexOutput;
          output.position = uniforms.projection * vec4<f32>(pos, 0.0, 1.0);
          output.color = color;
          return output;
        }
      `;

      const fragmentShader = `
        @fragment
        fn fs_main(
          @location(2) @interpolate(flat) color: vec4<f32>
        ) -> @location(0) vec4<f32> {
          return color;
        }
      `;

      const vertexModule = this.device.createShaderModule({ code: vertexShader });
      const fragmentModule = this.device.createShaderModule({ code: fragmentShader });

      this.linePipeline = this.device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: vertexModule,
          entryPoint: 'vs_main',
          buffers: [
            {
              arrayStride: 8 * 4, // start(8) + end(8) + color(16) = 32 bytes
              stepMode: 'instance',
              attributes: [
                { shaderLocation: 0, offset: 0, format: 'float32x2' }, // start
                { shaderLocation: 1, offset: 8, format: 'float32x2' }, // end
                { shaderLocation: 2, offset: 16, format: 'float32x4' }, // color
              ],
            },
          ],
        },
        fragment: {
          module: fragmentModule,
          entryPoint: 'fs_main',
          targets: [{ format: this.core.format }],
        },
        primitive: {
          topology: 'line-list',
        },
      });
    }

    createGeometryBuffers() {
      // Rectangle uses triangle-strip, no vertex buffer needed (generated in shader)
      // Triangle uses triangle-list, no vertex buffer needed (generated in shader)
      // Line uses line-list, no vertex buffer needed (generated in shader)
    }

    // Add rectangle instance
    // color can be: hex string (e.g., "#FF0000"), hex number, or rgba array [r, g, b, a]
    addRect(x, y, width, height, color, alpha = 1.0) {
      let rgba;
      if (Array.isArray(color) && color.length >= 3) {
        // Already an rgba array
        rgba = color.length === 4 ? color : [...color, alpha];
      } else {
        // Convert hex to rgba
        rgba = this.hexToRgba(color, alpha);
      }
      this.rectInstances.push({
        position: [x + width / 2, y + height / 2], // center position
        size: [width, height],
        color: rgba,
      });
    }

    // Add triangle instance
    addTriangle(x0, y0, x1, y1, x2, y2, color, alpha = 1.0) {
      const rgba = this.hexToRgba(color, alpha);
      this.triangleInstances.push({
        v0: [x0, y0],
        v1: [x1, y1],
        v2: [x2, y2],
        color: rgba,
      });
    }

    // Add line instance
    addLine(x0, y0, x1, y1, color, alpha = 1.0) {
      const rgba = this.hexToRgba(color, alpha);
      this.lineInstances.push({
        start: [x0, y0],
        end: [x1, y1],
        color: rgba,
      });
    }

    // Clear all instances
    clear() {
      this.rectInstances = [];
      this.triangleInstances = [];
      this.lineInstances = [];
    }

    // Render all instances
    render(encoder, renderPass) {
      // Create uniform bind group (same layout for all pipelines)
      const uniformBindGroupLayout = this.rectPipeline.getBindGroupLayout(0);
      const uniformBindGroup = this.device.createBindGroup({
        layout: uniformBindGroupLayout,
        entries: [
          {
            binding: 0,
            resource: {
              buffer: this.core.projectionBuffer,
            },
          },
        ],
      });

      // Render rectangles
      if (this.rectInstances.length > 0) {
        const instanceData = new Float32Array(this.rectInstances.length * 8);
        for (let i = 0; i < this.rectInstances.length; i++) {
          const inst = this.rectInstances[i];
          const offset = i * 8;
          instanceData[offset + 0] = inst.position[0];
          instanceData[offset + 1] = inst.position[1];
          instanceData[offset + 2] = inst.size[0];
          instanceData[offset + 3] = inst.size[1];
          instanceData[offset + 4] = inst.color[0];
          instanceData[offset + 5] = inst.color[1];
          instanceData[offset + 6] = inst.color[2];
          instanceData[offset + 7] = inst.color[3];
        }

        if (!this.rectBuffer || this.rectBuffer.size < instanceData.byteLength) {
          if (this.rectBuffer) this.rectBuffer.destroy();
          this.rectBuffer = this.device.createBuffer({
            size: instanceData.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          });
        }

        this.device.queue.writeBuffer(this.rectBuffer, 0, instanceData);

        renderPass.setPipeline(this.rectPipeline);
        renderPass.setBindGroup(0, uniformBindGroup);
        renderPass.setVertexBuffer(0, this.rectBuffer);
        renderPass.draw(4, this.rectInstances.length); // 4 vertices per quad
      }

      // Render triangles
      if (this.triangleInstances.length > 0) {
        // v0(2) + v1(2) + v2(2) + color(4) = 10 floats per instance
        const instanceData = new Float32Array(this.triangleInstances.length * 10);
        for (let i = 0; i < this.triangleInstances.length; i++) {
          const inst = this.triangleInstances[i];
          const offset = i * 10;
          instanceData[offset + 0] = inst.v0[0];
          instanceData[offset + 1] = inst.v0[1];
          instanceData[offset + 2] = inst.v1[0];
          instanceData[offset + 3] = inst.v1[1];
          instanceData[offset + 4] = inst.v2[0];
          instanceData[offset + 5] = inst.v2[1];
          instanceData[offset + 6] = inst.color[0];
          instanceData[offset + 7] = inst.color[1];
          instanceData[offset + 8] = inst.color[2];
          instanceData[offset + 9] = inst.color[3];
        }

        if (!this.triangleBuffer || this.triangleBuffer.size < instanceData.byteLength) {
          if (this.triangleBuffer) this.triangleBuffer.destroy();
          this.triangleBuffer = this.device.createBuffer({
            size: instanceData.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          });
        }

        this.device.queue.writeBuffer(this.triangleBuffer, 0, instanceData);

        const triangleUniformBindGroup = this.device.createBindGroup({
          layout: this.trianglePipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: this.core.projectionBuffer,
              },
            },
          ],
        });
        
        renderPass.setPipeline(this.trianglePipeline);
        renderPass.setBindGroup(0, triangleUniformBindGroup);
        renderPass.setVertexBuffer(0, this.triangleBuffer);
        renderPass.draw(3, this.triangleInstances.length); // 3 vertices per triangle
      }

      // Render lines
      if (this.lineInstances.length > 0) {
        const instanceData = new Float32Array(this.lineInstances.length * 8);
        for (let i = 0; i < this.lineInstances.length; i++) {
          const inst = this.lineInstances[i];
          const offset = i * 8;
          instanceData[offset + 0] = inst.start[0];
          instanceData[offset + 1] = inst.start[1];
          instanceData[offset + 2] = inst.end[0];
          instanceData[offset + 3] = inst.end[1];
          instanceData[offset + 4] = inst.color[0];
          instanceData[offset + 5] = inst.color[1];
          instanceData[offset + 6] = inst.color[2];
          instanceData[offset + 7] = inst.color[3];
        }

        if (!this.lineBuffer || this.lineBuffer.size < instanceData.byteLength) {
          if (this.lineBuffer) this.lineBuffer.destroy();
          this.lineBuffer = this.device.createBuffer({
            size: instanceData.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          });
        }

        this.device.queue.writeBuffer(this.lineBuffer, 0, instanceData);

        const lineUniformBindGroup = this.device.createBindGroup({
          layout: this.linePipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: this.core.projectionBuffer,
              },
            },
          ],
        });
        
        renderPass.setPipeline(this.linePipeline);
        renderPass.setBindGroup(0, lineUniformBindGroup);
        renderPass.setVertexBuffer(0, this.lineBuffer);
        renderPass.draw(2, this.lineInstances.length); // 2 vertices per line
      }
    }

    // Get rendering statistics
    getStats() {
      return {
        rectangles: this.rectInstances.length,
        triangles: this.triangleInstances.length,
        lines: this.lineInstances.length,
        totalPolygons: this.rectInstances.length + this.triangleInstances.length + this.lineInstances.length,
      };
    }
  }

  // ------------------------------------------------------------
  // WebGPU: Instanced cubic Bezier ribbon renderer (Sankey ribbons)
  // ------------------------------------------------------------
  class BezierRibbonRenderer {
    constructor(webgpuCore, opts = {}) {
      this.core = webgpuCore;
      this.device = webgpuCore.device;

      this.segments = Math.max(8, Math.min(128, opts.segments ?? 40)); // smooth, not too heavy
      this.pipeline = null;
      this.bindGroup = null;

      this.instances = [];
      this.instanceBuffer = null;

      this._init();
    }

    clear() {
      this.instances.length = 0;
    }

    // Instance layout (Float32):
    // topP0.xy topP1.xy topP2.xy topP3.xy  (8 floats)
    // botP0.xy botP1.xy botP2.xy botP3.xy  (8 floats)
    // color.rgba (4 floats)
    addRibbon(topP0, topP1, topP2, topP3, botP0, botP1, botP2, botP3, colorRgba) {
      // Basic validity guard
      if (!isFinite(topP0[0]) || !isFinite(topP0[1]) || !isFinite(topP3[0]) || !isFinite(topP3[1])) return;
      if (!isFinite(botP0[0]) || !isFinite(botP0[1]) || !isFinite(botP3[0]) || !isFinite(botP3[1])) return;

      this.instances.push({
        topP0, topP1, topP2, topP3,
        botP0, botP1, botP2, botP3,
        color: colorRgba,
      });
    }

    _init() {
      const wgsl = `
        struct Uniforms {
          projection: mat4x4<f32>,
          screenSize: vec2<f32>,
          _pad: vec2<f32>,
        };
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        struct VSOut {
          @builtin(position) position: vec4<f32>,
          @location(0) color: vec4<f32>,
        };

        fn bezier(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>, t: f32) -> vec2<f32> {
          let omt = 1.0 - t;
          return (omt*omt*omt)*p0 +
                 (3.0*omt*omt*t)*p1 +
                 (3.0*omt*t*t)*p2 +
                 (t*t*t)*p3;
        }

        @vertex
        fn vs_main(
          @builtin(vertex_index) vid: u32,
          @builtin(instance_index) iid: u32,

          // Top boundary control points
          @location(0) topP0: vec2<f32>,
          @location(1) topP1: vec2<f32>,
          @location(2) topP2: vec2<f32>,
          @location(3) topP3: vec2<f32>,

          // Bottom boundary control points
          @location(4) botP0: vec2<f32>,
          @location(5) botP1: vec2<f32>,
          @location(6) botP2: vec2<f32>,
          @location(7) botP3: vec2<f32>,

          // Premultiplied-alpha color is done in FS
          @location(8) color: vec4<f32>,
        ) -> VSOut {
          // Triangle strip: for each segment s, emit [top(s), bottom(s)]
          // vid: 0 top(0), 1 bot(0), 2 top(1), 3 bot(1), ...
          let side: u32 = vid & 1u;         // 0 = top, 1 = bottom
          let s: u32 = vid >> 1u;           // segment index
          let denom: f32 = f32(${this.segments - 1});
          let t: f32 = select(0.0, f32(s) / denom, denom > 0.0);

          var p: vec2<f32>;
          if (side == 0u) {
            p = bezier(topP0, topP1, topP2, topP3, t);
          } else {
            p = bezier(botP0, botP1, botP2, botP3, t);
          }

          var out: VSOut;
          out.position = uniforms.projection * vec4<f32>(p, 0.0, 1.0);
          out.color = color;
          return out;
        }

        @fragment
        fn fs_main(in: VSOut) -> @location(0) vec4<f32> {
          // premultiply for correct blending
          let a = in.color.a;
          return vec4<f32>(in.color.rgb * a, a);
        }
      `;

      const module = this.device.createShaderModule({ code: wgsl });

      this.pipeline = this.device.createRenderPipeline({
        layout: "auto",
        vertex: {
          module,
          entryPoint: "vs_main",
          buffers: [
            {
              stepMode: "instance",
              arrayStride: (8 + 8 + 4) * 4, // 20 floats
              attributes: [
                { shaderLocation: 0, offset:  0 * 4, format: "float32x2" }, // topP0
                { shaderLocation: 1, offset:  2 * 4, format: "float32x2" }, // topP1
                { shaderLocation: 2, offset:  4 * 4, format: "float32x2" }, // topP2
                { shaderLocation: 3, offset:  6 * 4, format: "float32x2" }, // topP3

                { shaderLocation: 4, offset:  8 * 4, format: "float32x2" }, // botP0
                { shaderLocation: 5, offset: 10 * 4, format: "float32x2" }, // botP1
                { shaderLocation: 6, offset: 12 * 4, format: "float32x2" }, // botP2
                { shaderLocation: 7, offset: 14 * 4, format: "float32x2" }, // botP3

                { shaderLocation: 8, offset: 16 * 4, format: "float32x4" }, // color
              ],
            },
          ],
        },
        fragment: {
          module,
          entryPoint: "fs_main",
          targets: [{
            format: this.core.format,
            blend: {
              color: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
              alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
            },
          }],
        },
        primitive: { topology: "triangle-strip" },
      });

      this.bindGroup = this.device.createBindGroup({
        layout: this.pipeline.getBindGroupLayout(0),
        entries: [{ binding: 0, resource: { buffer: this.core.projectionBuffer } }],
      });
    }

    _ensureInstanceBuffer() {
      const neededFloats = this.instances.length * 20;
      const neededBytes = neededFloats * 4;
      if (!this.instanceBuffer || this.instanceBuffer.size < neededBytes) {
        // Over-allocate a bit to reduce realloc churn
        const allocBytes = Math.max(neededBytes, (this.instanceBuffer?.size ?? 0) * 2, 64 * 1024);
        this.instanceBuffer = this.device.createBuffer({
          size: allocBytes,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });
      }
    }

    render(encoder, renderPass) {
      if (!this.pipeline || this.instances.length === 0) return;

      this._ensureInstanceBuffer();

      // Pack instances -> Float32Array
      const data = new Float32Array(this.instances.length * 20);
      let o = 0;
      for (const inst of this.instances) {
        const push2 = (p) => { data[o++] = p[0]; data[o++] = p[1]; };
        push2(inst.topP0); push2(inst.topP1); push2(inst.topP2); push2(inst.topP3);
        push2(inst.botP0); push2(inst.botP1); push2(inst.botP2); push2(inst.botP3);
        data[o++] = inst.color[0]; data[o++] = inst.color[1]; data[o++] = inst.color[2]; data[o++] = inst.color[3];
      }

      this.device.queue.writeBuffer(this.instanceBuffer, 0, data);

      renderPass.setPipeline(this.pipeline);
      renderPass.setBindGroup(0, this.bindGroup);
      renderPass.setVertexBuffer(0, this.instanceBuffer);

      const vertexCount = this.segments * 2;
      renderPass.draw(vertexCount, this.instances.length, 0, 0);
    }
  }

  // -----------------------------
  // Genomeshader bootstrap
  // -----------------------------
  // Store lazy loading status to display in HUD
  window._genomeshaderLazyStatus = null;
  
  function showError(message) {
    window._genomeshaderLazyStatus = { type: 'error', message };
    updateHUDWithStatus();
  }
  
  function showInfo(message) {
    window._genomeshaderLazyStatus = { type: 'info', message };
    updateHUDWithStatus();
  }
  
  function updateHUDWithStatus() {
    const hudEl = document.getElementById('hud');
    if (!hudEl || !window._genomeshaderLazyStatus) return;
    
    const status = window._genomeshaderLazyStatus;
    const statusColor = status.type === 'error' ? 'var(--accent)' : 'var(--text)';
    const statusBorder = status.type === 'error' ? 'var(--accent)' : 'var(--border)';
    
    // Get current locus text if state is available
    // Note: state is defined later in the script, so we'll update HUD with locus later
    // For now, just show the status message
    hudEl.innerHTML = `<span style="color: ${statusColor}; font-weight: 500;">${status.message}</span>`;
  }
  
  // Determine host mode (inline or popup)
  const hostMode = (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.hostMode) || 'inline';
  
  // True lazy loading via postMessage
  const manifestUrl = window.GENOMESHADER_MANIFEST_URL;
  
  if (!manifestUrl) {
    showError('Missing GENOMESHADER_MANIFEST_URL');
  } else {
    
    // Request manifest via postMessage to opener (Jupyter notebook window)
    // The opener can fetch from localhost, avoiding CORS issues
    let requestId = 0;
    const pendingRequests = new Map();
    
    function requestData(url) {
      return new Promise((resolve, reject) => {
        // Inline mode: use direct fetch
        if (hostMode === 'inline') {
          fetch(url)
            .then(response => {
              if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
              }
              return response.json();
            })
            .then(data => {
              resolve(data);
            })
            .catch(error => {
              reject(error);
            });
          return;
        }

        // Popup mode: use postMessage
        const id = `req_${Date.now()}_${++requestId}`;
        pendingRequests.set(id, { resolve, reject });
        
        // Send request to opener
        window.opener.postMessage({
          type: 'genomeshader_fetch',
          requestId: id,
          url: url
        }, '*');
        
        // Set timeout
        setTimeout(() => {
          if (pendingRequests.has(id)) {
            pendingRequests.delete(id);
            reject(new Error('Request timeout'));
          }
        }, 30000); // 30 second timeout
      });
    }
    
    // Listen for responses from opener (only in popup mode)
    if (hostMode === 'popup') {
      window.addEventListener('message', function(event) {
        // Only accept messages from opener
        if (event.source !== window.opener) {
          return;
        }
        
        const data = event.data;
        if (data && data.type === 'genomeshader_fetch_response') {
          const request = pendingRequests.get(data.requestId);
          if (request) {
            pendingRequests.delete(data.requestId);
            if (data.success) {
              request.resolve(data.data);
            } else {
              request.reject(new Error(data.error || 'Fetch failed'));
            }
          }
        }
      });
    }
    
    // Request manifest
    requestData(manifestUrl)
      .then(manifest => {
        console.log('Loaded manifest via postMessage:', manifest);
        
        // Compute track URL
        const baseUrl = manifestUrl.slice(0, manifestUrl.lastIndexOf('/') + 1);
        const trackUrl = baseUrl + manifest.tracks.demo.url;
        
        // Request track file
        return requestData(trackUrl)
          .then(trackData => {
            const recordCount = Array.isArray(trackData) ? trackData.length : 0;
            showInfo(`Run ID: ${manifest.run_id}<br>Loaded ${recordCount} records`);
          })
          .catch(error => {
            showError(`Failed to load track: ${error.message}`);
          });
      })
      .catch(error => {
        showError(`Failed to load manifest: ${error.message}`);
      });
  }

  // -----------------------------
  // Jupyter Comms Test - REMOVED
  // This test code has been removed as it was showing unwanted dialogs
  // -----------------------------

  // -----------------------------
  // Theme + menu
  // -----------------------------
  // Find root container for scoping event handlers in inline mode
  const root = document.querySelector('[id^="genomeshader-root-"]') ||
                (document.querySelector('.app')?.closest('[id^="genomeshader-root-"]')) ||
                document.body; // Fallback to body if not found
  
  // Root-scoped element lookup helpers
  function byId(root, id) {
    const el = root.querySelector(`#${CSS.escape(id)}`);
    return el;
  }

  function $(root, selector) {
    const el = root.querySelector(selector);
    return el;
  }
  
  // Use root-scoped queries in inline mode, document queries in popup mode
  const querySelector = (selector) => {
    if (hostMode === 'inline' && root && root !== document.body) {
      return root.querySelector(selector) || document.querySelector(selector);
    }
    return document.querySelector(selector);
  };
  const getElementById = (id) => {
    if (hostMode === 'inline' && root && root !== document.body) {
      return root.getElementById ? root.getElementById(id) : root.querySelector(`#${id}`) || document.getElementById(id);
    }
    return document.getElementById(id);
  };
  
  const app = querySelector(".app");
  const sidebar = getElementById("sidebar");
  const menuBtn = getElementById("menuBtn");
  const ctxMenu = getElementById("ctxMenu");
  const themeItem = getElementById("themeItem");
  const themeLabel = getElementById("themeLabel");
  const orientationItem = getElementById("orientationItem");
  const orientationLabel = getElementById("orientationLabel");
  
  // Debug: Check if elements are found
  
  // In inline mode, keep menu in root initially, but we'll move it to body when opening
  // This ensures fixed positioning works relative to viewport, not container
  if (hostMode === 'inline' && root && ctxMenu && !root.contains(ctxMenu)) {
    root.appendChild(ctxMenu);
  }

  // Sidebar collapse/expand
  function getSidebarCollapsed() {
    return localStorage.getItem("genomeshader.sidebarCollapsed") === "true";
  }
  function setSidebarCollapsed(collapsed) {
    localStorage.setItem("genomeshader.sidebarCollapsed", String(collapsed));
    updateSidebarState();
  }
  function updateSidebarState() {
    const collapsed = getSidebarCollapsed();
    if (!app) {
      return;
    }
    if (collapsed) {
      app.classList.add("sidebar-collapsed");
    } else {
      app.classList.remove("sidebar-collapsed");
    }
    // Trigger resize after CSS transition completes to ensure tracks re-render
    // The CSS transition is 0.2s, so wait for it to complete
    setTimeout(() => {
      window.dispatchEvent(new Event('resize'));
    }, 220);
  }
  
  // Make sidebar border clickable - always bind regardless of hostMode
  if (sidebar) {
    const handleSidebarToggle = (e) => {
      // Don't toggle if clicking on menu button or menu - check this FIRST before stopping propagation
      if ((menuBtn && (menuBtn === e.target || menuBtn.contains(e.target))) ||
          (ctxMenu && (ctxMenu === e.target || ctxMenu.contains(e.target)))) {
        return; // Don't stop propagation - let menu button handler fire
      }
      
      e.preventDefault();
      e.stopPropagation();
      
      const collapsed = getSidebarCollapsed();
      const rect = sidebar.getBoundingClientRect();
      const clickX = e.clientX - rect.left;

      // Check if click is within 12px of the right edge (or anywhere if collapsed)
      if (collapsed) {
        // When collapsed, the entire 12px strip is clickable
        setSidebarCollapsed(false);
      } else if (clickX >= rect.width - 12) {
        // When open, only the right 12px edge is clickable
        setSidebarCollapsed(true);
      }
    };
    
    // Use multiple event types with capturing phase (like debug buttons)
    sidebar.addEventListener("click", handleSidebarToggle, true);
    sidebar.addEventListener("pointerdown", handleSidebarToggle, true);
    sidebar.addEventListener("pointerup", handleSidebarToggle, true);
    sidebar.addEventListener("mousedown", handleSidebarToggle, true);
    
    // Ensure sidebar is clickable
    sidebar.style.pointerEvents = "auto";
  }
  
  updateSidebarState();

  function getStoredTheme() {
    return localStorage.getItem("genomeshader.theme"); // "dark" | "light" | "auto" | null
  }
  function setTheme(theme) {
    document.documentElement.setAttribute("data-theme", theme);
    localStorage.setItem("genomeshader.theme", theme);
    updateThemeLabel();
  }
  function updateThemeLabel() {
    const t = document.documentElement.getAttribute("data-theme") || "auto";
    themeLabel.textContent = t === "auto" ? "Auto" : (t === "light" ? "Light" : "Dark");
  }
  function getStoredOrientation() {
    return localStorage.getItem("genomeshader.orientation"); // "horizontal" | "vertical" | null
  }
  function setOrientation(o) {
    localStorage.setItem("genomeshader.orientation", o);
    updateOrientationState();
  }
  function updateOrientationState() {
    const o = getStoredOrientation() ?? "horizontal";
    // Apply on the main pane so CSS can target all track contents
    main.classList.toggle("vertical", o === "vertical");
    orientationLabel.textContent = (o === "vertical") ? "Vertical" : "Horizontal";
  }
  function isVerticalMode() {
    return (getStoredOrientation() ?? "horizontal") === "vertical";
  }
  function getStoredVariantLayoutMode() {
    return localStorage.getItem("genomeshader.variantLayoutMode"); // "equidistant" | "genomic" | null
  }
  function setVariantLayoutMode(mode) {
    localStorage.setItem("genomeshader.variantLayoutMode", mode);
    state.variantLayoutMode = mode;
    updateVariantLayoutModeLabel();
  }
  function updateVariantLayoutModeLabel() {
    const mode = state.variantLayoutMode || "equidistant";
    const labelEl = document.getElementById("variantLayoutModeLabel");
    if (labelEl) {
      labelEl.textContent = mode === "equidistant" ? "Equidistant" : "Genomic";
    }
  }
  function getVariantLayoutMode() {
    return state.variantLayoutMode || "equidistant";
  }

  const stored = getStoredTheme();
  document.documentElement.setAttribute("data-theme", stored ?? "auto");
  updateThemeLabel();

  function openMenu() {
    // In inline mode, move menu to body so fixed positioning works relative to viewport
    if (hostMode === 'inline' && ctxMenu.parentElement !== document.body) {
      document.body.appendChild(ctxMenu);
    }
    
    // Use fixed positioning so menu appears over everything (including Jupyter UI)
    const r = menuBtn.getBoundingClientRect();
    // Position menu above the gear button, or below if not enough space above
    const menuHeight = 220; // Approximate menu height
    let top = r.top - menuHeight - 8;
    let left = r.left;
    
    // If not enough space above, position below
    if (top < 8) {
      top = r.bottom + 8;
    }
    
    // Ensure menu doesn't go off right edge
    const menuWidth = 220;
    if (left + menuWidth > window.innerWidth - 8) {
      left = window.innerWidth - menuWidth - 8;
    }
    
    // Ensure menu doesn't go off bottom edge
    if (top + menuHeight > window.innerHeight - 8) {
      top = Math.max(8, window.innerHeight - menuHeight - 8);
    }
    
    ctxMenu.style.position = 'fixed';
    ctxMenu.style.left = `${left}px`;
    ctxMenu.style.top = `${top}px`;
    ctxMenu.style.zIndex = '2147483647';
    ctxMenu.classList.add("open");
    ctxMenu.setAttribute("aria-hidden", "false");
    ctxMenu.style.display = 'block';
    ctxMenu.style.visibility = 'visible';
    ctxMenu.style.pointerEvents = 'auto';
    ctxMenu.style.opacity = '1';

    // Update variant layout mode label when menu opens
    updateVariantLayoutModeLabel();
  }
  function closeMenu() {
    ctxMenu.classList.remove("open");
    ctxMenu.setAttribute("aria-hidden", "true");
    ctxMenu.style.display = 'none';
    ctxMenu.style.visibility = 'hidden';
    ctxMenu.style.pointerEvents = 'none';
    
    // In inline mode, move menu back to root when closed
    if (hostMode === 'inline' && root && ctxMenu.parentElement === document.body) {
      root.appendChild(ctxMenu);
    }
  }
  function toggleMenu() {
    ctxMenu.classList.contains("open") ? closeMenu() : openMenu();
  }

  if (menuBtn && ctxMenu) {
    // Track if we've already handled this interaction to prevent double-toggle
    let menuButtonHandled = false;
    
    const handleMenuButtonClick = (e) => {
      // If we already handled this interaction (e.g., pointerdown), ignore subsequent events (click)
      if (menuButtonHandled && e.type !== 'pointerdown') {
        return;
      }
      e.stopPropagation(); 
      e.preventDefault();
      
      // Mark as handled and reset after a short delay
      menuButtonHandled = true;
      setTimeout(() => { menuButtonHandled = false; }, 300);
      
      toggleMenu(); 
    };
    
    // Use pointerdown as primary handler (fires first), click as fallback
    menuBtn.addEventListener("pointerdown", handleMenuButtonClick, true);
    menuBtn.addEventListener("click", handleMenuButtonClick, true);
    menuBtn.addEventListener("mousedown", handleMenuButtonClick, true);
    
    // Ensure menu button is clickable
    menuBtn.style.pointerEvents = "auto";
    menuBtn.style.cursor = "pointer";
    menuBtn.style.zIndex = "150";
    menuBtn.style.position = "relative";
    
    // Also set onclick as fallback
    menuBtn.onclick = handleMenuButtonClick;

    // Close menu when clicking outside, but check if click is outside menu/button
    // In inline mode, use root-scoped handler to avoid Jupyter wrapper interference
    if (hostMode === 'inline' && root) {
      // Track when menu was just opened to avoid immediate close
      let menuJustOpened = false;
      const originalToggleMenu = toggleMenu;
      toggleMenu = function() {
        menuJustOpened = true;
        originalToggleMenu();
        // Reset flag after a short delay
        setTimeout(() => { menuJustOpened = false; }, 100);
      };
      
      // Use pointerdown with capturing to catch events before they bubble
      const onPointerDown = (e) => {
        // Don't close if menu was just opened (same click event)
        if (menuJustOpened) {
          return;
        }
        // Only close if menu is open and click is outside menu/button
        if (ctxMenu.classList.contains("open") && 
            !ctxMenu.contains(e.target) && 
            !menuBtn.contains(e.target)) {
          closeMenu();
        }
      };
      root.addEventListener("pointerdown", onPointerDown, true);
    } else {
      // Popup mode: use document-level handler
      document.addEventListener("click", (e) => {
        if (!ctxMenu.contains(e.target) && !menuBtn.contains(e.target)) {
          closeMenu();
        }
      });
    }
  }
  ctxMenu.addEventListener("click", (e) => e.stopPropagation());

  themeItem.addEventListener("click", () => {
    const cur = document.documentElement.getAttribute("data-theme") || "auto";
    const next = cur === "dark" ? "light" : (cur === "light" ? "auto" : "dark");
    setTheme(next);
    renderAll();
  });

  orientationItem.addEventListener("click", () => {
    const cur = getStoredOrientation() ?? "horizontal";
    const next = (cur === "horizontal") ? "vertical" : "horizontal";
    setOrientation(next);
    renderAll();
  });

  // Variant layout mode toggle in settings menu
  const variantLayoutModeItem = getElementById("variantLayoutModeItem");
  
  if (variantLayoutModeItem) {
    variantLayoutModeItem.addEventListener("click", () => {
      const cur = getVariantLayoutMode();
      const next = (cur === "equidistant") ? "genomic" : "equidistant";
      setVariantLayoutMode(next);
      renderAll();
    });
  }

  // Fullscreen mode setup
  const fullscreenItem = getElementById("fullscreenItem");
  const fullscreenLabel = getElementById("fullscreenLabel");
  
  // Resize callback for focus mode
  function triggerResize() {
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        if (webgpuCore && webgpuSupported) {
          try {
            webgpuCore.handleResize();
          } catch (error) {
            // WebGPU resize error
          }
        }
        renderAll();
      });
    });
  }

  // Focus mode implementation (inlined from focus_mode.js)
  function installFocusMode({ viewerEl, toggleEl, viewId, onEnter, onExit }) {
    if (!viewerEl || !toggleEl || !viewId) {
      return;
    }

    let isActive = false;
    let overlay = null;
    let modal = null;
    let topbar = null;
    let placeholder = null;
    let originalParent = null;
    let originalNextSibling = null;

    const overlayId = `genomeshader-overlay-${viewId}`;
    const modalId = `genomeshader-modal-${viewId}`;
    const topbarId = `genomeshader-topbar-${viewId}`;
    const placeholderId = `genomeshader-placeholder-${viewId}`;

    function createOverlay() {
      overlay = document.createElement('div');
      overlay.id = overlayId;
      overlay.style.cssText = `
        position: fixed;
        inset: 0;
        z-index: 2147483647;
        background: rgba(0, 0, 0, 0.75);
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
      `;

      modal = document.createElement('div');
      modal.id = modalId;
      modal.style.cssText = `
        position: absolute;
        inset: 24px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        background: var(--bg, #0b0d10);
        border-radius: 12px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        pointer-events: auto;
      `;

      topbar = document.createElement('div');
      topbar.id = topbarId;
      topbar.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        border-bottom: 1px solid var(--border, rgba(255,255,255,0.10));
        background: var(--panel, #11151b);
        flex-shrink: 0;
      `;

      const title = document.createElement('div');
      title.textContent = 'Genomeshader — Full screen';
      title.style.cssText = `
        font-size: 14px;
        font-weight: 600;
        color: var(--text, rgba(255,255,255,0.92));
      `;

      const closeBtn = document.createElement('button');
      closeBtn.textContent = '✕';
      closeBtn.setAttribute('aria-label', 'Close full screen');
      closeBtn.style.cssText = `
        width: 32px;
        height: 32px;
        border: 1px solid var(--border2, rgba(255,255,255,0.08));
        background: var(--panel2, rgba(255,255,255,0.03));
        color: var(--text, rgba(255,255,255,0.92));
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        line-height: 1;
        transition: all 0.15s ease;
      `;
      closeBtn.addEventListener('mouseenter', () => {
        closeBtn.style.filter = 'brightness(1.1)';
      });
      closeBtn.addEventListener('mouseleave', () => {
        closeBtn.style.filter = '';
      });
      closeBtn.addEventListener('click', exit);

      topbar.appendChild(title);
      topbar.appendChild(closeBtn);

      const modalBody = document.createElement('div');
      modalBody.style.cssText = `
        flex: 1;
        overflow: hidden;
        position: relative;
        pointer-events: auto;
        touch-action: none;
      `;

      modal.appendChild(topbar);
      modal.appendChild(modalBody);
      overlay.appendChild(modal);

      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          exit();
        }
      });

      const handleEscape = (e) => {
        if (e.key === 'Escape' && isActive) {
          exit();
        }
      };
      document.addEventListener('keydown', handleEscape);
      overlay._escapeHandler = handleEscape;

      return { overlay, modal, modalBody };
    }

    function enter() {
      if (isActive) return;

      const { overlay, modal, modalBody } = createOverlay();
      
      originalParent = viewerEl.parentNode;
      originalNextSibling = viewerEl.nextSibling;

      placeholder = document.createElement('div');
      placeholder.id = placeholderId;
      placeholder.style.cssText = `
        width: ${viewerEl.offsetWidth}px;
        height: ${viewerEl.offsetHeight}px;
        min-height: 600px;
      `;

      if (originalNextSibling) {
        originalParent.insertBefore(placeholder, originalNextSibling);
      } else {
        originalParent.appendChild(placeholder);
      }

      modalBody.appendChild(viewerEl);
      document.body.appendChild(overlay);

      const originalOverflow = document.body.style.overflow;
      document.body.style.overflow = 'hidden';
      overlay._originalOverflow = originalOverflow;

      isActive = true;
      updateToggleLabel();

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          // Rebind interactions after DOM move
          if (typeof interactionBinding !== 'undefined' && interactionBinding) {
            interactionBinding.destroy();
          }
          // Re-find main element within the moved viewer element
          const mainAfterMove = viewerEl.querySelector ? viewerEl.querySelector("#main") : byId(root, "main");
          if (mainAfterMove && typeof bindInteractions !== 'undefined') {
            // Use root to maintain scoping, but mainAfterMove is the actual element
            interactionBinding = bindInteractions(root, state, mainAfterMove);
          }
          if (onEnter) {
            onEnter();
          }
        });
      });
    }

    function exit() {
      if (!isActive) return;

      if (overlay && overlay._originalOverflow !== undefined) {
        document.body.style.overflow = overlay._originalOverflow;
      } else {
        document.body.style.overflow = '';
      }

      if (overlay && overlay._escapeHandler) {
        document.removeEventListener('keydown', overlay._escapeHandler);
      }

      if (placeholder && originalParent) {
        if (originalNextSibling) {
          originalParent.insertBefore(viewerEl, originalNextSibling);
        } else {
          originalParent.appendChild(viewerEl);
        }
        placeholder.remove();
        placeholder = null;
      }

      if (overlay) {
        overlay.remove();
        overlay = null;
        modal = null;
        topbar = null;
      }

      isActive = false;
      updateToggleLabel();

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          // Rebind interactions after DOM move
          if (typeof interactionBinding !== 'undefined' && interactionBinding) {
            interactionBinding.destroy();
          }
          // Re-find main element within the moved viewer element
          const mainAfterMove = viewerEl.querySelector ? viewerEl.querySelector("#main") : byId(root, "main");
          if (mainAfterMove && typeof bindInteractions !== 'undefined') {
            // Use root to maintain scoping, but mainAfterMove is the actual element
            interactionBinding = bindInteractions(root, state, mainAfterMove);
          }
          if (onExit) {
            onExit();
          }
        });
      });
    }

    function updateToggleLabel() {
      if (fullscreenLabel) {
        fullscreenLabel.textContent = isActive ? 'Exit full screen' : 'Enter full screen';
      }
    }

    toggleEl.addEventListener('click', (e) => {
      e.stopPropagation();
      if (isActive) {
        exit();
      } else {
        enter();
      }
    });

    updateToggleLabel();

    return {
      enter,
      exit,
      isActive: () => isActive
    };
  }

  // Initialize focus mode after app is ready
  // Declare interactionBinding early so it's accessible to overlay callbacks
  let interactionBinding = null;
  
  const viewId = window.GENOMESHADER_VIEW_ID || document.querySelector('[data-view-id]')?.dataset.viewId || 'default';
  if (fullscreenItem && app) {
    installFocusMode({
      viewerEl: app,
      toggleEl: fullscreenItem,
      viewId: viewId,
      onEnter: triggerResize,
      onExit: triggerResize
    });
  }

  const mq = window.matchMedia?.("(prefers-color-scheme: light)");
  mq?.addEventListener?.("change", () => {
    if ((document.documentElement.getAttribute("data-theme") || "auto") === "auto") {
      updateThemeLabel();
      renderAll();
    }
  });

  // -----------------------------
  // ViewState
  // -----------------------------
  const state = {
    contig: "chr1",
    startBp: 100_000,
    endBp:   100_900,
    pxPerBp: 1,

    firstVariantIndex: 0,
    K: 8,
    hoveredVariantIndex: null, // index of hovered variant, or null
    expandedInsertions: new Set(), // Set of variant IDs that have expanded insertions
    hoveredRepeatTooltip: null, // { text, x, y } or null
    hoveredVariantLabelTooltip: null, // { text, x, y } or null

    // interaction
    dragging: false,
    lastX: 0,
    lastY: 0,

    // touch pinch
    pointers: new Map(),     // pointerId -> {x,y}
    pinchStartDist: null,
    pinchStartSpan: null,
    pinchAnchorBp: null,

    // track management
    tracks: [
      { id: "ideogram", label: "Chromosome", collapsed: false, height: 38, minHeight: 20 },
      { id: "genes", label: "Genes", collapsed: false, height: 110, minHeight: 30 },
      { id: "repeats", label: "RepeatMasker", collapsed: false, height: 50, minHeight: 30 },
      { id: "ruler", label: "Locus", collapsed: false, height: 68, minHeight: 40 },
      { id: "reference", label: "Reference", collapsed: false, height: 40, minHeight: 30 },
      { id: "flow", label: "Variants/Haplotypes", collapsed: false, height: 150, minHeight: 100 },
      { id: "reads", label: "Reads", collapsed: false, height: 220, minHeight: 50 }
    ],
    trackDragState: null,  // { trackId, startX, startY, offsetX, offsetY }
    trackResizeState: null, // { trackId, startX, startY, startHeight }
    
    // variant layout mode: "equidistant" or "genomic"
    variantLayoutMode: null, // will be initialized from localStorage
    
    // allele order for each variant: Map<variantId, string[]> where array is ['.', '(N bp) refAllele', '(N bp) altAllele1', ...]
    variantAlleleOrder: new Map(),
    
    // drag state for allele reordering
    alleleDragState: null, // { variantId, alleleIndex, label, startX, startY, offsetX, offsetY, dropIndex }
    
    // hovered allele node: { variantId, alleleIndex } or null
    hoveredAlleleNode: null,
    
    // pinned allele labels: Set of strings like "variantId:alleleIndex"
    pinnedAlleleLabels: new Set(),
    
    // pinned variant labels: Set of variant IDs (strings)
    pinnedVariantLabels: new Set()
  };

  // Initialize variant layout mode
  const storedVariantMode = getStoredVariantLayoutMode();
  state.variantLayoutMode = storedVariantMode ?? "equidistant";
  // Initialize label after DOM is ready
  setTimeout(() => updateVariantLayoutModeLabel(), 0);

  // Chromosome lengths for bounds checking
  const chrLengths = {
    "chr1": 248_956_422,
    "chr2": 242_193_529,
    "chr3": 198_295_559,
    "chr4": 190_214_555,
    "chr5": 181_538_259,
    "chr6": 170_805_979,
    "chr7": 159_345_973,
    "chr8": 145_138_636,
    "chr9": 138_394_717,
    "chr10": 133_797_422,
    "chr11": 135_086_622,
    "chr12": 133_275_309,
    "chr13": 114_364_328,
    "chr14": 107_043_718,
    "chr15": 101_991_189,
    "chr16": 90_338_345,
    "chr17": 83_257_441,
    "chr18": 80_373_285,
    "chr19": 58_617_616,
    "chr20": 64_444_167,
    "chr21": 46_709_983,
    "chr22": 50_818_468,
    "chrX": 156_040_895,
    "chrY": 57_227_415
  };

  // Helper function to get chromosome length for current contig
  function getChromosomeLength() {
    return chrLengths[state.contig] || 248_956_422;
  }

  // Helper function to clamp startBp and endBp to chromosome boundaries
  function clampToChromosomeBounds() {
    const chrLength = getChromosomeLength();
    const span = state.endBp - state.startBp;
    
    // Clamp startBp to [0, chrLength - span]
    state.startBp = Math.max(0, Math.min(state.startBp, chrLength - span));
    
    // Ensure endBp doesn't exceed chromosome length
    state.endBp = Math.min(state.startBp + span, chrLength);
    
    // If span is larger than chromosome, center it
    if (span > chrLength) {
      state.startBp = 0;
      state.endBp = chrLength;
    }
  }

  // Function to update document title with current locus
  function updateDocumentTitle() {
    const startFormatted = Math.floor(state.startBp).toLocaleString();
    const endFormatted = Math.floor(state.endBp).toLocaleString();
    document.title = `Genomeshader (${state.contig}:${startFormatted}-${endFormatted})`;
  }

  // Initialize state from GENOMESHADER_CONFIG if available
  let dataBounds = null;
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.region) {
    const region = window.GENOMESHADER_CONFIG.region;
    // Parse region string format: "chr1:100000-200000"
    const match = region.match(/^([^:]+):(\d+)-(\d+)$/);
    if (match) {
      state.contig = match[1];
      state.startBp = parseInt(match[2], 10);
      state.endBp = parseInt(match[3], 10);
    }
    
    // Store data bounds if available (where actual read data exists)
    if (window.GENOMESHADER_CONFIG.data_bounds) {
      dataBounds = {
        start: window.GENOMESHADER_CONFIG.data_bounds.start,
        end: window.GENOMESHADER_CONFIG.data_bounds.end
      };
    }
    
    // Update document title with initial locus
    updateDocumentTitle();
  }

  const main = byId(root, "main");
  const tracksSvg = byId(root, "tracksSvg");
  const flow = byId(root, "flow");
  const reads = byId(root, "reads");
  const flowCanvas = byId(root, "flowCanvas");
  const readsCanvas = byId(root, "readsCanvas");
  const hud = byId(root, "hud");
  const tooltip = byId(root, "tooltip");
  const tracksWebGPU = byId(root, "tracksWebGPU");
  const flowWebGPU = byId(root, "flowWebGPU");

  // Initialize WebGPU infrastructure
  let webgpuCore = null;
  let instancedRenderer = null;
  let flowWebGPUCore = null;
  let flowInstancedRenderer = null;
  let flowRibbonRenderer = null;
  let webgpuSupported = false;
  let repeatHitTestData = []; // For tooltip hit testing

  async function initWebGPU() {
    if (!navigator.gpu) {
      console.warn("WebGPU not supported, falling back to SVG rendering");
      if (tracksWebGPU) tracksWebGPU.style.display = 'none';
      return false;
    }

    // Wait for canvas to have dimensions
    if (!tracksWebGPU) {
      return false;
    }
    
    const checkDimensions = () => {
      const rect = tracksWebGPU.getBoundingClientRect();
      return rect.width > 0 && rect.height > 0;
    };
    
    // Wait up to 2 seconds for dimensions
    for (let i = 0; i < 40; i++) {
      if (checkDimensions()) {
        break;
      }
      await new Promise(resolve => setTimeout(resolve, 50));
    }
    
    if (!checkDimensions()) {
      if (tracksWebGPU) tracksWebGPU.style.display = 'none';
      return false;
    }

    try {
      webgpuCore = new WebGPUCore();
      await webgpuCore.init(tracksWebGPU);
      instancedRenderer = new InstancedRenderer(webgpuCore);

      // Flow WebGPU (separate canvas)
      if (flowWebGPU) {
        flowWebGPUCore = new WebGPUCore();
        await flowWebGPUCore.init(flowWebGPU);
        flowInstancedRenderer = new InstancedRenderer(flowWebGPUCore);
        flowRibbonRenderer = new BezierRibbonRenderer(flowWebGPUCore, { segments: 44 });
      }

      webgpuSupported = true;
      return true;
    } catch (error) {
      console.warn("Failed to initialize WebGPU:", error);
      if (tracksWebGPU) tracksWebGPU.style.display = 'none';
      return false;
    }
  }

  // Initialize WebGPU after a short delay to ensure DOM is ready
  setTimeout(() => {
    initWebGPU().catch(err => {
      console.error("WebGPU initialization error:", err);
    });
  }, 100);

  // Initialize orientation state after DOM elements are available
  updateOrientationState();

  function rectW(el) { 
    if (!el) return 0;
    const w = el.getBoundingClientRect().width;
    return isNaN(w) || w <= 0 ? 0 : w;
  }
  function rectH(el) { 
    if (!el) return 0;
    const h = el.getBoundingClientRect().height;
    return isNaN(h) || h <= 0 ? 0 : h;
  }

  function tracksWidthPx() { 
    if (!tracksSvg) return 0;
    const w = tracksSvg.getBoundingClientRect().width;
    return isNaN(w) || w <= 0 ? 0 : w;
  }
  function flowWidthPx()   { return rectW(flow); }
  function flowHeightPx()  { return rectH(flow); }
  function readsWidthPx()  { return rectW(reads); }
  function readsHeightPx() { return rectH(reads); }

  function cssVar(name) {
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }

  function updateDerived() {
    const span = state.endBp - state.startBp;
    if (span <= 0 || isNaN(span)) {
      // Invalid span, keep previous pxPerBp or use default
      if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
        state.pxPerBp = 1;
      }
      return;
    }
    if (isVerticalMode()) {
      const h = tracksHeightPx();
      if (h > 0 && !isNaN(h)) {
        state.pxPerBp = h / span;
      } else if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
        state.pxPerBp = 1;
      }
    } else {
      const w = tracksWidthPx();
      if (w > 0 && !isNaN(w)) {
        state.pxPerBp = w / span;
      } else if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
        state.pxPerBp = 1;
      }
    }
    // Final guard
    if (isNaN(state.pxPerBp) || state.pxPerBp <= 0) {
      state.pxPerBp = 1;
    }
  }

  // Calculate total insertion gap width for expanded insertions (in pixels)
  function getTotalInsertionGapWidth() {
    let totalGap = 0;
    for (const variant of variants) {
      if (state.expandedInsertions.has(variant.id) && isInsertion(variant)) {
        const maxInsertLen = getMaxInsertionLength(variant);
        // Each inserted base gets 8px width
        totalGap += maxInsertLen * 8;
      }
    }
    return totalGap;
  }
  
  // IMPORTANT: canonical genome-x mapping for the right pane (tracks/canvases)
  // Accounts for expanded insertion gaps
  function xGenomeCanonical(bp, W) {
    // Guard against invalid inputs
    if (!W || W <= 0 || isNaN(W) || isNaN(bp)) {
      return 16; // Return leftPad as safe default
    }
    const leftPad = 16, rightPad = 16;
    const innerW = Math.max(0, W - leftPad - rightPad);
    if (innerW <= 0) {
      return leftPad;
    }
    const span = state.endBp - state.startBp;
    if (span <= 0 || isNaN(span)) {
      return leftPad;
    }
    // Guard against invalid pxPerBp
    if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
      return leftPad;
    }
    const totalGapPx = getTotalInsertionGapWidth();
    const totalGapBp = totalGapPx / state.pxPerBp;
    if (isNaN(totalGapBp)) {
      return leftPad;
    }
    const effectiveSpan = span + totalGapBp;
    if (effectiveSpan <= 0 || isNaN(effectiveSpan)) {
      return leftPad;
    }
    
    // Calculate x position, accounting for insertion gaps before this position
    let accumulatedGapPx = 0;
    for (const variant of variants) {
      if (variant.pos < bp && state.expandedInsertions.has(variant.id) && isInsertion(variant)) {
        const maxInsertLen = getMaxInsertionLength(variant);
        accumulatedGapPx += maxInsertLen * 8;
      }
    }
    
    const bpOffset = bp - state.startBp;
    const accumulatedGapBp = accumulatedGapPx / state.pxPerBp;
    if (isNaN(accumulatedGapBp) || isNaN(bpOffset)) {
      return leftPad;
    }
    const normalizedPos = (bpOffset + accumulatedGapBp) / effectiveSpan;
    if (isNaN(normalizedPos)) {
      return leftPad;
    }
    
    const result = leftPad + normalizedPos * innerW;
    return isNaN(result) ? leftPad : Math.max(leftPad, Math.min(leftPad + innerW, result));
  }
  
  function xGenome(bp) {
    return xGenomeCanonical(bp, tracksWidthPx());
  }
  
  function bpFromXGenome(xPx, W) {
    const leftPad = 16, rightPad = 16;
    const innerW = W - leftPad - rightPad;
    const span = state.endBp - state.startBp;
    const totalGapPx = getTotalInsertionGapWidth();
    const totalGapBp = totalGapPx / state.pxPerBp;
    const effectiveSpan = span + totalGapBp;
    const t = (xPx - leftPad) / innerW;
    
    // Reverse calculation accounting for gaps - iterative refinement
    let bpEstimate = state.startBp + t * effectiveSpan;
    for (let iter = 0; iter < 5; iter++) {
      let accumulatedGapPx = 0;
      for (const variant of variants) {
        if (variant.pos < bpEstimate && state.expandedInsertions.has(variant.id) && isInsertion(variant)) {
          const maxInsertLen = getMaxInsertionLength(variant);
          accumulatedGapPx += maxInsertLen * 8;
        }
      }
      const accumulatedGapBp = accumulatedGapPx / state.pxPerBp;
      bpEstimate = state.startBp + (t * effectiveSpan) - accumulatedGapBp;
    }
    
    return bpEstimate;
  }

  // Vertical mode coordinate mapping (genomic axis vertical: bottom=start, top=end)
  function yGenomeCanonical(bp, H) {
    // Guard against invalid inputs
    if (!H || H <= 0 || isNaN(H) || isNaN(bp)) {
      return 16; // Return topPad as safe default
    }
    const topPad = 16, bottomPad = 16;
    const innerH = Math.max(0, H - topPad - bottomPad);
    if (innerH <= 0) {
      return topPad;
    }
    const span = state.endBp - state.startBp;
    if (span <= 0 || isNaN(span)) {
      return topPad;
    }
    // Guard against invalid pxPerBp
    if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
      return topPad;
    }
    const totalGapPx = getTotalInsertionGapWidth();
    const totalGapBp = totalGapPx / state.pxPerBp;
    if (isNaN(totalGapBp)) {
      return topPad;
    }
    const effectiveSpan = span + totalGapBp;
    if (effectiveSpan <= 0 || isNaN(effectiveSpan)) {
      return topPad;
    }
    
    // Calculate y position, accounting for insertion gaps before this position
    let accumulatedGapPx = 0;
    for (const variant of variants) {
      if (variant.pos < bp && state.expandedInsertions.has(variant.id) && isInsertion(variant)) {
        const maxInsertLen = getMaxInsertionLength(variant);
        accumulatedGapPx += maxInsertLen * 8;
      }
    }
    
    const bpOffset = bp - state.startBp;
    const accumulatedGapBp = accumulatedGapPx / state.pxPerBp;
    if (isNaN(accumulatedGapBp) || isNaN(bpOffset)) {
      return topPad;
    }
    const normalizedPos = (bpOffset + accumulatedGapBp) / effectiveSpan;
    if (isNaN(normalizedPos)) {
      return topPad;
    }
    
    // Invert: bottom (H - bottomPad) = start, top (topPad) = end
    const result = H - bottomPad - normalizedPos * innerH;
    return isNaN(result) ? topPad : Math.max(topPad, Math.min(H - bottomPad, result));
  }
  
  function yGenome(bp) {
    return yGenomeCanonical(bp, tracksHeightPx());
  }
  
  function tracksHeightPx() {
    if (!tracksSvg) return 0;
    const h = tracksSvg.getBoundingClientRect().height;
    return isNaN(h) || h <= 0 ? 0 : h;
  }
  
  function bpFromYGenome(yPx, H) {
    const topPad = 16, bottomPad = 16;
    const innerH = H - topPad - bottomPad;
    const span = state.endBp - state.startBp;
    const totalGapPx = getTotalInsertionGapWidth();
    const totalGapBp = totalGapPx / state.pxPerBp;
    const effectiveSpan = span + totalGapBp;
    
    // Invert: yPx is from top, but we want position from bottom
    const normalizedPos = (H - bottomPad - yPx) / innerH;
    const t = Math.max(0, Math.min(1, normalizedPos));
    
    // Reverse calculation accounting for gaps - iterative refinement
    let bpEstimate = state.startBp + t * effectiveSpan;
    for (let iter = 0; iter < 5; iter++) {
      let accumulatedGapPx = 0;
      for (const variant of variants) {
        if (variant.pos < bpEstimate && state.expandedInsertions.has(variant.id) && isInsertion(variant)) {
          const maxInsertLen = getMaxInsertionLength(variant);
          accumulatedGapPx += maxInsertLen * 8;
        }
      }
      const accumulatedGapBp = accumulatedGapPx / state.pxPerBp;
      bpEstimate = state.startBp + (t * effectiveSpan) - accumulatedGapBp;
    }
    
    return bpEstimate;
  }

  function xColumn(i, totalColumns) {
    const W = flowWidthPx();
    if (!W || W <= 0 || isNaN(W) || isNaN(i)) {
      return 60;
    }
    const margin = 60;
    const innerW = Math.max(10, W - 2*margin);
    const numCols = totalColumns !== undefined ? totalColumns : state.K;
    if (numCols <= 1) return margin;
    const result = margin + (i / (numCols - 1)) * innerW;
    return isNaN(result) ? margin : result;
  }
  function yColumn(i, totalColumns) {
    const H = flowHeightPx();
    if (!H || H <= 0 || isNaN(H) || isNaN(i)) {
      return 60;
    }
    const margin = 60;
    const innerH = Math.max(10, H - 2*margin);
    const numCols = totalColumns !== undefined ? totalColumns : state.K;
    if (numCols <= 1) return margin;
    // Invert: index 0 (earliest variant) should be at bottom (higher Y), 
    // last index (latest variant) should be at top (lower Y)
    const result = margin + innerH - (i / (numCols - 1)) * innerH;
    return isNaN(result) ? margin : result;
  }

  // -----------------------------
  // Variant data: load from config or use demo data
  // -----------------------------
  let variants = [];
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.variants_data) {
    const data = window.GENOMESHADER_CONFIG.variants_data;
    // Data should already be an array of variant objects
    if (Array.isArray(data) && data.length > 0) {
      variants = data;
      console.log(`Loaded ${variants.length} variants from config`);
    } else {
      console.warn("Variants data is not in expected array format or is empty:", data);
      // Fall back to empty array or demo data
      variants = [];
    }
  } else {
    // Fall back to demo data if no config provided
    console.log("No variants_data found in GENOMESHADER_CONFIG, using demo data");
    variants = [
      { id: "v1", pos: 100_120, alleles: ["ref","a1"], refAllele: "A", altAlleles: ["A" + "ATCGATCGATCGATCGATCGATCGATCGAT"] }, // insertion example (30 bp inserted: ATCGATCGATCGATCGATCGATCGATCGAT)
      { id: "v2", pos: 100_240, alleles: ["ref","a1"] },
      { id: "v3", pos: 100_410, alleles: ["ref","a1","a2"] },
      { id: "v4", pos: 100_610, alleles: ["ref","a1"] },
      { id: "v5", pos: 100_720, alleles: ["ref","a1"] },
      { id: "v6", pos: 100_780, alleles: ["ref","a1"] },
      { id: "v7", pos: 100_860, alleles: ["ref","a1"] },
      { id: "v8", pos: 100_895, alleles: ["ref","a1"] },
      { id: "v9", pos: 100_930, alleles: ["ref","a1"] },
    ];
  }
  
  // Helper to check if variant is an insertion
  function isInsertion(variant) {
    if (!variant.refAllele || !variant.altAlleles) return false;
    const refLen = variant.refAllele.length;
    return variant.altAlleles.some(alt => alt.length > refLen);
  }
  
  // Get the longest insertion allele length for a variant
  function getMaxInsertionLength(variant) {
    if (!variant.refAllele || !variant.altAlleles) return 0;
    const refLen = variant.refAllele.length;
    return Math.max(...variant.altAlleles.map(alt => Math.max(0, alt.length - refLen)));
  }

  // Genes: load from config or use empty array as fallback
  let transcripts = [];
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.transcripts_data) {
    const data = window.GENOMESHADER_CONFIG.transcripts_data;
    // Data should already be an array of transcript objects
    if (Array.isArray(data)) {
      transcripts = data;
      console.log(`Loaded ${transcripts.length} transcripts for genes track`);
    } else {
      console.warn("Transcripts data is not in expected array format:", data);
    }
  } else {
    console.warn("No transcripts_data found in GENOMESHADER_CONFIG:", window.GENOMESHADER_CONFIG);
  }

  // RepeatMasker: load from config or use empty array as fallback
  let repeats = [];
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.repeats_data) {
    const data = window.GENOMESHADER_CONFIG.repeats_data;
    // Data should already be an array of repeat objects with start, end, cls
    if (Array.isArray(data)) {
      repeats = data;
      console.log(`Loaded ${repeats.length} repeats for RepeatMasker track`);
    } else {
      console.warn("Repeats data is not in expected array format:", data);
    }
  } else {
    console.warn("No repeats_data found in GENOMESHADER_CONFIG:", window.GENOMESHADER_CONFIG);
  }

  // Reference sequence: load from config or use empty string as fallback
  let referenceSequence = "";
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.reference_data) {
    const data = window.GENOMESHADER_CONFIG.reference_data;
    // Data should be a string containing the DNA sequence
    if (typeof data === 'string') {
      referenceSequence = data;
      console.log(`Loaded reference sequence of length ${referenceSequence.length} bases`);
    } else {
      console.warn("Reference data is not in expected string format:", data);
    }
  } else {
    console.warn("No reference_data found in GENOMESHADER_CONFIG:", window.GENOMESHADER_CONFIG);
  }

  // -----------------------------
  // SVG helpers
  // -----------------------------
  const SVGNS = "http://www.w3.org/2000/svg";
  function clearSvg(svg) { while (svg.firstChild) svg.removeChild(svg.firstChild); }
  function el(tag, attrs = {}, text = null) {
    const n = document.createElementNS(SVGNS, tag);
    for (const [k,v] of Object.entries(attrs)) {
      // Skip null/undefined values
      if (v == null) {
        continue;
      }
      
      let value = v;
      
      // Check if value is already NaN (number or string "NaN")
      if (typeof value === 'number' && isNaN(value)) {
        console.warn(`Genomeshader: NaN value for ${k} in <${tag}>, using 0`);
        value = 0;
      } else if (typeof value === 'string' && (value === 'NaN' || value.toLowerCase() === 'nan')) {
        console.warn(`Genomeshader: "NaN" string for ${k} in <${tag}>, using 0`);
        value = 0;
      } else {
        // Validate numeric attributes that must be non-negative
        if (['width', 'height', 'r', 'rx', 'ry'].includes(k)) {
          // Handle both number and string inputs
          let numVal;
          if (typeof value === 'number') {
            numVal = value;
          } else {
            numVal = parseFloat(value);
          }
          
          // Check for NaN first
          if (isNaN(numVal)) {
            console.warn(`Genomeshader: Invalid ${k} value ${v} (NaN) for <${tag}>, using 0`);
            value = 0;
          } 
          // Check for negative values - SVG doesn't allow negative width/height
          else if (numVal < 0) {
            console.warn(`Genomeshader: Invalid ${k} value ${v} (negative) for <${tag}>, using 0`);
            value = 0;
          } 
          // Use the parsed/validated number
          else {
            value = numVal;
          }
        }
        // Validate position attributes that must be valid numbers (can be negative for positioning)
        else if (['x', 'y', 'x1', 'x2', 'y1', 'y2', 'cx', 'cy'].includes(k)) {
          const numVal = parseFloat(value);
          if (isNaN(numVal)) {
            console.warn(`Genomeshader: Invalid ${k} value ${v} (NaN) for <${tag}>, using 0`);
            value = 0;
          } else {
            value = numVal; // Use parsed number (can be negative for positioning)
          }
        }
        // For any other numeric-looking attribute, validate it's not NaN
        else if (typeof value === 'number' && isNaN(value)) {
          console.warn(`Genomeshader: NaN value for ${k} in <${tag}>, using 0`);
          value = 0;
        }
      }
      
      n.setAttribute(k, String(value));
    }
    if (text !== null) n.textContent = text;
    return n;
  }

  // -----------------------------
  // "Nice" tick selection for ruler
  // -----------------------------
  function trimZeros(s) {
    return s.replace(/\.0+$/, "").replace(/(\.\d*[1-9])0+$/, "$1");
  }
  function formatBp(bp, spanBp = null) {
    // Determine precision based on span if provided
    let kbPrecision = 1;
    
    if (spanBp !== null) {
      if (spanBp < 100) {
        // Very zoomed in - show full base pair position with commas
        return `${Math.round(bp).toLocaleString()} bp`;
      } else if (spanBp < 1_000) {
        // Zoomed in - show more decimal places for kb
        kbPrecision = 2;
      } else if (spanBp < 10_000) {
        // Moderately zoomed - show 2 decimal places
        kbPrecision = 2;
      } else {
        // Normal zoom - show 1 decimal place
        kbPrecision = 1;
      }
    }
    
    if (bp >= 1_000_000) return `${trimZeros((bp / 1_000_000).toFixed(2))} Mb`;
    if (bp >= 1_000)     return `${trimZeros((bp / 1_000).toFixed(kbPrecision))} kb`;
    return `${bp} bp`;
  }
  function chooseNiceTickBp(spanBp, desiredTicks) {
    const target = spanBp / desiredTicks;
    const pow = Math.pow(10, Math.floor(Math.log10(target)));
    const candidates = [1,2,5,10].map(m => m*pow);
    let best = candidates[0], bestDiff = Infinity;
    for (const c of candidates) {
      const diff = Math.abs((spanBp / c) - desiredTicks);
      if (diff < bestDiff) { bestDiff = diff; best = c; }
    }
    return best;
  }

  // -----------------------------
  // Track layout calculation
  // -----------------------------
  function getTrackLayout() {
    const layout = [];
    const headerH = 24;
    const padding = 8;
    const isVertical = isVerticalMode();

    if (isVertical) {
      // Vertical mode: tracks side-by-side (left/width based)
      let currentX = 0;
      const mainHeight = rectH(main);
      // Ensure mainHeight is valid
      const safeMainHeight = (isNaN(mainHeight) || mainHeight <= 0) ? 0 : mainHeight;
      
      for (const track of state.tracks) {
        const effectiveWidth = track.collapsed ? headerH : (headerH + (track.height || 0));
        const safeContentLeft = currentX + headerH;
        const safeContentWidth = track.collapsed ? 0 : (track.height || 0);
        
        // Validate all values are numbers
        if (isNaN(currentX) || isNaN(effectiveWidth) || isNaN(safeContentLeft) || isNaN(safeContentWidth)) {
          console.warn('Genomeshader: Invalid layout values in vertical mode', { currentX, effectiveWidth, safeContentLeft, safeContentWidth, track: track.id });
          continue;
        }
        
        layout.push({
          track,
          left: currentX,
          width: effectiveWidth,
          contentLeft: safeContentLeft,
          contentWidth: safeContentWidth,
          // Also include top/height for compatibility
          top: 0,
          height: safeMainHeight,
          contentTop: 0,
          contentHeight: safeMainHeight
        });
        currentX += effectiveWidth; // no gap between tracks
      }
    } else {
      // Horizontal mode: tracks stacked vertically (top/height based)
      let currentY = 0;
      const mainWidth = rectW(main);
      // Ensure mainWidth is valid
      const safeMainWidth = (isNaN(mainWidth) || mainWidth <= 0) ? 0 : mainWidth;
      
      for (const track of state.tracks) {
        const effectiveHeight = track.collapsed ? headerH : (headerH + (track.height || 0));
        const safeContentTop = currentY + headerH;
        const safeContentHeight = track.collapsed ? 0 : (track.height || 0);
        
        // Validate all values are numbers
        if (isNaN(currentY) || isNaN(effectiveHeight) || isNaN(safeContentTop) || isNaN(safeContentHeight)) {
          console.warn('Genomeshader: Invalid layout values in horizontal mode', { currentY, effectiveHeight, safeContentTop, safeContentHeight, track: track.id });
          continue;
        }
        
        layout.push({
          track,
          top: currentY,
          height: effectiveHeight,
          contentTop: safeContentTop,
          contentHeight: safeContentHeight,
          // Also include left/width for compatibility
          left: 0,
          width: safeMainWidth,
          contentLeft: 0,
          contentWidth: safeMainWidth
        });
        currentY += effectiveHeight; // no gap between tracks
      }
    }

    return layout;
  }

  function updateTracksHeight() {
    const layout = getTrackLayout();
    const isVertical = isVerticalMode();
    // Exclude flow and reads from tracks height/width since they're positioned separately
    const tracksLayout = layout.filter(l => l.track.id !== "flow" && l.track.id !== "reads");
    if (isVertical) {
      const totalW = tracksLayout.length > 0 
        ? tracksLayout[tracksLayout.length - 1].left + tracksLayout[tracksLayout.length - 1].width
        : 0;
      // In vertical mode, tracks are side-by-side, so we don't need to set --tracks-h
      // But we might want to set a width variable if needed
    } else {
      const totalH = tracksLayout.length > 0 
        ? tracksLayout[tracksLayout.length - 1].top + tracksLayout[tracksLayout.length - 1].height
        : 0;
      // Use default height if calculation fails or returns 0
      const finalHeight = totalH > 0 ? totalH : 280; // Default to 280px if calculation fails
      document.documentElement.style.setProperty('--tracks-h', `${finalHeight}px`);
    }
  }

  // -----------------------------
  // Tracks rendering (ideogram + genes + repeats + ruler)
  // -----------------------------
  // Track retry attempts to avoid infinite loops
  let renderTracksRetryCount = 0;
  const MAX_RETRY_ATTEMPTS = 10;
  
  function renderTracks() {
    clearSvg(tracksSvg);
    // Clear WebGPU renderer instances
    if (instancedRenderer) {
      instancedRenderer.clear();
    }
    repeatHitTestData = [];
    
    const isVertical = isVerticalMode();
    const W = isVertical ? tracksHeightPx() : tracksWidthPx();
    const H = isVertical ? tracksWidthPx() : tracksHeightPx();
    
    // Guard against invalid dimensions - retry if dimensions are not ready
    if (!W || W <= 0 || isNaN(W) || !H || H <= 0 || isNaN(H)) {
      if (renderTracksRetryCount < MAX_RETRY_ATTEMPTS) {
        renderTracksRetryCount++;
        // Try to update tracks height before retrying (might fix the dimension issue)
        updateTracksHeight();
        // Schedule a retry after a short delay to allow layout to settle
        setTimeout(() => {
          renderTracks();
        }, 50);
        return;
      } else {
        renderTracksRetryCount = 0; // Reset counter
        return;
      }
    }
    
    // Reset retry counter on successful render
    renderTracksRetryCount = 0;
    
    // Ensure pxPerBp is valid before rendering
    if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
      // Try to update derived values
      updateDerived();
      // Check again
      if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
        return;
      }
    }
    
    const layout = getTrackLayout();
    
    // Coordinate mapping functions based on orientation
    const genomePos = isVertical ? yGenome.bind(null) : xGenome.bind(null);
    const genomePosCanonical = isVertical 
      ? (bp) => yGenomeCanonical(bp, H)
      : (bp) => xGenomeCanonical(bp, W);
    
    // Find track positions (needed to exclude ideogram from shading)
    const ideogramLayout = layout.find(l => l.track.id === "ideogram");
    const genesLayout = layout.find(l => l.track.id === "genes");
    const repeatsLayout = layout.find(l => l.track.id === "repeats");
    const rulerLayout = layout.find(l => l.track.id === "ruler");
    const referenceLayout = layout.find(l => l.track.id === "reference");
    const flowLayout = layout.find(l => l.track.id === "flow");
    const readsLayout = layout.find(l => l.track.id === "reads");
    
    // Calculate ideogram track bounds to exclude from shading (including track controls header)
    let ideogramTrackStart = 0;
    let ideogramTrackEnd = 0;
    if (ideogramLayout && !ideogramLayout.track.collapsed) {
      if (isVertical) {
        // In vertical mode, ideogram is on the left side (x-axis)
        // Use left/width to include the track controls header area
        ideogramTrackStart = ideogramLayout.left;
        ideogramTrackEnd = ideogramLayout.left + ideogramLayout.width;
      } else {
        // In horizontal mode, ideogram is at the top (y-axis)
        // Use top/height to include the track controls header area
        ideogramTrackStart = ideogramLayout.top;
        ideogramTrackEnd = ideogramLayout.top + ideogramLayout.height;
      }
    }
    
    // Draw data bounds overlays across all tracks except ideogram (if data bounds exist and differ from view)
    if (dataBounds && (dataBounds.start > state.startBp || dataBounds.end < state.endBp)) {
      const dataStartPos = genomePos(dataBounds.start);
      const dataEndPos = genomePos(dataBounds.end);
      
      // Find the tracks container bounds
      const tracksContainer = document.getElementById("tracksContainer");
      if (tracksContainer) {
        const containerRect = tracksContainer.getBoundingClientRect();
        const svgRect = tracksSvg.getBoundingClientRect();
        
        // Helper function to draw out-of-bounds shading (darker)
        const drawOutOfBoundsRect = (x, y, width, height) => {
          tracksSvg.appendChild(el("rect", {
            x: x,
            y: y,
            width: width,
            height: height,
            fill: "rgba(127,127,127,0.15)", // Darker for out-of-bounds
            "pointer-events": "none",
            "class": "data-bounds-overlay"
          }));
        };
        
        if (isVertical) {
          // In vertical mode, Y axis is inverted: bottom (higher Y) = smaller bp, top (lower Y) = larger bp
          // dataStartPos = Y position of dataBounds.start (smaller bp → higher Y, near bottom)
          // dataEndPos = Y position of dataBounds.end (larger bp → lower Y, near top)
          
          // Out-of-bounds region below data (smaller bp than dataBounds.start)
          // dataBounds.start > state.startBp means view extends to show bp < dataBounds.start
          // In vertical mode: smaller bp → higher Y → bottom of screen
          // So out-of-bounds is from dataStartPos to H (bottom)
          if (dataBounds.start > state.startBp) {
            const overlayY1 = Math.max(dataStartPos, 0);
            const overlayY2 = H;
            if (overlayY2 > overlayY1) {
              if (ideogramTrackEnd > 0) {
                // Left side of ideogram track
                if (ideogramTrackStart > 0) {
                  drawOutOfBoundsRect(0, overlayY1, ideogramTrackStart, overlayY2 - overlayY1);
                }
                // Right side of ideogram track
                if (ideogramTrackEnd < W) {
                  drawOutOfBoundsRect(ideogramTrackEnd, overlayY1, W - ideogramTrackEnd, overlayY2 - overlayY1);
                }
              } else {
                // No ideogram track, draw full width
                drawOutOfBoundsRect(0, overlayY1, W, overlayY2 - overlayY1);
              }
            }
          }
          
          // Out-of-bounds region above data (larger bp than dataBounds.end)
          // dataBounds.end < state.endBp means view extends to show bp > dataBounds.end
          // In vertical mode: larger bp → lower Y → top of screen
          // So out-of-bounds is from 0 to dataEndPos (top)
          if (dataBounds.end < state.endBp) {
            const overlayY1 = 0;
            const overlayY2 = Math.min(dataEndPos, H);
            if (overlayY2 > overlayY1) {
              if (ideogramTrackEnd > 0) {
                // Left side of ideogram track
                if (ideogramTrackStart > 0) {
                  drawOutOfBoundsRect(0, overlayY1, ideogramTrackStart, overlayY2 - overlayY1);
                }
                // Right side of ideogram track
                if (ideogramTrackEnd < W) {
                  drawOutOfBoundsRect(ideogramTrackEnd, overlayY1, W - ideogramTrackEnd, overlayY2 - overlayY1);
                }
              } else {
                // No ideogram track, draw full width
                drawOutOfBoundsRect(0, overlayY1, W, overlayY2 - overlayY1);
              }
            }
          }
        } else {
          // Horizontal mode - exclude ideogram track area
          // Region before data start (out-of-bounds, darker)
          if (dataBounds.start > state.startBp) {
            const overlayX1 = 0;
            const overlayX2 = dataStartPos;
            if (ideogramTrackEnd > 0) {
              // Top side of ideogram track
              if (ideogramTrackStart > 0) {
                drawOutOfBoundsRect(overlayX1, 0, overlayX2 - overlayX1, ideogramTrackStart);
              }
              // Bottom side of ideogram track
              if (ideogramTrackEnd < H) {
                drawOutOfBoundsRect(overlayX1, ideogramTrackEnd, overlayX2 - overlayX1, H - ideogramTrackEnd);
              }
            } else {
              // No ideogram track, draw full height
              drawOutOfBoundsRect(overlayX1, 0, overlayX2 - overlayX1, H);
            }
          }
          
          // Region after data end (out-of-bounds, darker)
          if (dataBounds.end < state.endBp) {
            const overlayX1 = dataEndPos;
            const overlayX2 = W;
            if (ideogramTrackEnd > 0) {
              // Top side of ideogram track
              if (ideogramTrackStart > 0) {
                drawOutOfBoundsRect(overlayX1, 0, overlayX2 - overlayX1, ideogramTrackStart);
              }
              // Bottom side of ideogram track
              if (ideogramTrackEnd < H) {
                drawOutOfBoundsRect(overlayX1, ideogramTrackEnd, overlayX2 - overlayX1, H - ideogramTrackEnd);
              }
            } else {
              // No ideogram track, draw full height
              drawOutOfBoundsRect(overlayX1, 0, overlayX2 - overlayX1, H);
            }
          }
        }
      }
    }

    if (!ideogramLayout || !genesLayout || !repeatsLayout || !rulerLayout || !referenceLayout || !flowLayout || !readsLayout) return;

    // Ideogram layout
    if (!ideogramLayout.track.collapsed) {
      // Validate layout properties before using them
      const contentLeft = ideogramLayout.contentLeft;
      const contentTop = ideogramLayout.contentTop;
      if (isNaN(contentLeft) || isNaN(contentTop)) {
        console.warn('Genomeshader: Invalid ideogram layout values', { contentLeft, contentTop });
        return;
      }
      
      let ideogramX, ideogramY, ideogramW, ideogramH;
      if (isVertical) {
        ideogramX = (isNaN(contentLeft) ? 0 : contentLeft) + 12;
        ideogramW = 16;
        // Leave space at bottom for chromosome label, start ideogram higher
        ideogramY = 16;
        // In vertical mode, ideogram spans the genomic axis (W dimension, which is SVG height)
        // Leave space at bottom (about 40px) for the chromosome label
        ideogramH = Math.max(0, W - 32 - 40);
      } else {
        ideogramY = (isNaN(contentTop) ? 0 : contentTop) + 12;
        ideogramH = 16;
        ideogramX = 16;
        ideogramW = Math.max(0, W - 32);
      }
      
      // Final validation of calculated values
      if (isNaN(ideogramX) || isNaN(ideogramY) || isNaN(ideogramW) || isNaN(ideogramH) || 
          ideogramW <= 0 || ideogramH <= 0) {
        console.warn('Genomeshader: Invalid ideogram dimensions', { ideogramX, ideogramY, ideogramW, ideogramH });
        return;
      }

      // --- Chromosome label
      if (isVertical) {
        // Position chromosome label at the bottom
        const labelY = W - 16;
        tracksSvg.appendChild(el("text", {
          x: ideogramX + ideogramW/2 + 1,
          y: labelY,
          class: "svg-chr",
          "text-anchor": "middle",
          "dominant-baseline": "middle",
          transform: "rotate(-90 " + (ideogramX + ideogramW/2) + " " + labelY + ")"
        }, state.contig));
      } else {
        tracksSvg.appendChild(el("text", {
          x: 16,
          y: ideogramY + ideogramH/2 + 1,
          class: "svg-chr",
          "dominant-baseline": "middle"
        }, state.contig));
      }

      // --- Ideogram (p/q arm rounded rects + cytobands clipped inside)
      const bandX = isVertical ? ideogramX : 70;
      const bandY = isVertical ? ideogramY : ideogramY;
      const bandW = isVertical ? ideogramW : Math.max(0, W - bandX - 16);
      // In vertical mode, bandH should use the full available height
      const bandH = isVertical ? ideogramH : ideogramH;
      
      // Validate band dimensions before using them
      if (isNaN(bandX) || isNaN(bandY) || isNaN(bandW) || isNaN(bandH) || 
          bandW <= 0 || bandH <= 0) {
        console.warn('Genomeshader: Invalid band dimensions', { bandX, bandY, bandW, bandH, ideogramX, ideogramY, ideogramW, ideogramH, W, H });
        return;
      }

      // Use global chromosome lengths for mapping cytoband positions
      const chrLength = getChromosomeLength();
      
      // Get ideogram data from config (already parsed from JSON in Python)
      let ideogramData = [];
      if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.ideogram_data) {
        const data = window.GENOMESHADER_CONFIG.ideogram_data;
        // Data should already be an array, but ensure it is
        if (Array.isArray(data)) {
          ideogramData = data;
        } else {
          console.warn("Ideogram data is not in expected array format:", data);
        }
      }
      
      // Find centromere position to determine p/q arm split
      let centromereStart = null;
      let centromereEnd = null;
      for (const band of ideogramData) {
        if (band.gieStain === "acen") {
          if (centromereStart === null) {
            centromereStart = band.chromStart;
          }
          centromereEnd = band.chromEnd;
        }
      }
      
      // Calculate actual p/q arm proportions based on centromere position
      // If no centromere found, use approximate position (p-arm is typically ~48% of chromosome)
      const defaultPFrac = 0.48;
      const centromerePos = centromereStart !== null ? centromereStart : Math.floor(chrLength * defaultPFrac);
      const pFrac = centromerePos / chrLength;
      const qFrac = 1 - pFrac;

      let pX, pY, pW, pH, qX, qY, qW, qH;
      if (isVertical) {
        // In vertical mode, arms are vertical (p-arm bottom, q-arm top)
        pH = Math.max(10, Math.floor(bandH * pFrac));
        qH = Math.max(10, Math.floor(bandH * qFrac));
        pW = qW = bandW;
        pX = qX = bandX;
        pY = bandY + bandH - pH; // p-arm at bottom
        qY = bandY; // q-arm at top
      } else {
        // Horizontal mode: arms are horizontal
        pW = Math.max(10, Math.floor(bandW * pFrac));
        qW = Math.max(10, Math.floor(bandW * qFrac));
        pH = qH = bandH;
        pX = bandX;
        qX = bandX + pW;
        pY = qY = bandY;
      }
      
      // Validate all calculated arm positions and dimensions
      if (isNaN(pX) || isNaN(pY) || isNaN(pW) || isNaN(pH) ||
          isNaN(qX) || isNaN(qY) || isNaN(qW) || isNaN(qH) ||
          pW <= 0 || pH <= 0 || qW <= 0 || qH <= 0) {
        console.warn('Genomeshader: Invalid arm dimensions', { pX, pY, pW, pH, qX, qY, qW, qH });
        return;
      }

      // defs + clipPath that matches both arms
      const defs = el("defs");
      const clipId = "chrClip";
      const clip = el("clipPath", { id: clipId });

      const armStroke = "rgba(127,127,127,0.22)";
      const armFill = "rgba(127,127,127,0.12)";

      const pArm = el("rect", { x: pX, y: pY, width: pW, height: pH, rx: 9, fill: armFill, stroke: armStroke });
      const qArm = el("rect", { x: qX, y: qY, width: qW, height: qH, rx: 9, fill: armFill, stroke: armStroke });

      clip.appendChild(el("rect", { x: pX, y: pY, width: pW, height: pH, rx: 9 }));
      clip.appendChild(el("rect", { x: qX, y: qY, width: qW, height: qH, rx: 9 }));

      defs.appendChild(clip);
      tracksSvg.appendChild(defs);

      tracksSvg.appendChild(pArm);
      tracksSvg.appendChild(qArm);
      
      // Calculate p-arm and q-arm lengths in base pairs
      const pArmLength = centromerePos;
      const qArmLength = chrLength - centromerePos;
      
      const bandInnerX = isVertical ? bandX - 2 : bandX;
      const bandInnerY = isVertical ? bandY : bandY - 2;
      const bandInnerW = isVertical ? bandW + 4 : bandW;
      const bandInnerH = isVertical ? bandH : bandH + 4;
      
      // Render each cytoband
      for (const band of ideogramData) {
        const bandStart = band.chromStart;
        const bandEnd = band.chromEnd;
        const isCentromere = band.gieStain === "acen";
        const isPArm = bandEnd <= centromerePos;
        
        // Determine which arm and calculate position
        let bandPos, bandSize;
        if (isPArm) {
          // p-arm: map from 0 to pArmLength onto p-arm dimensions
          const pFracStart = bandStart / pArmLength;
          const pFracEnd = bandEnd / pArmLength;
          const pFracSize = (bandEnd - bandStart) / pArmLength;
          
          if (isVertical) {
            // p-arm is at bottom, so we go from bottom up
            bandPos = pY + pH - (pFracEnd * pH);
            bandSize = pFracSize * pH;
          } else {
            // p-arm is on left
            bandPos = pX + (pFracStart * pW);
            bandSize = pFracSize * pW;
          }
        } else {
          // q-arm: map from centromerePos to chrLength onto q-arm dimensions
          const qFracStart = (bandStart - centromerePos) / qArmLength;
          const qFracEnd = (bandEnd - centromerePos) / qArmLength;
          const qFracSize = (bandEnd - bandStart) / qArmLength;
          
          if (isVertical) {
            // q-arm is at top
            bandPos = qY + (qFracStart * qH);
            bandSize = qFracSize * qH;
          } else {
            // q-arm is on right
            bandPos = qX + (qFracStart * qW);
            bandSize = qFracSize * qW;
          }
        }
        
        // Convert color from hex to rgba for better visibility
        const color = band.color || "#808080";
        let fillColor, strokeColor, strokeWidth;
        if (isCentromere) {
          fillColor = "rgba(255,77,77,0.35)";
          strokeColor = "none";
          strokeWidth = 0;
        } else {
          // Convert hex to rgba with opacity
          const r = parseInt(color.slice(1, 3), 16);
          const g = parseInt(color.slice(3, 5), 16);
          const b = parseInt(color.slice(5, 7), 16);
          // Adjust opacity based on color intensity (darker = more opaque)
          const intensity = (r + g + b) / 3;
          const opacity = 0.1 + (1 - intensity / 255) * 0.3;
          fillColor = `rgba(${r},${g},${b},${opacity})`;
          strokeColor = "none";
          strokeWidth = 0;
        }
        
        if (isVertical) {
          tracksSvg.appendChild(el("rect", {
            x: bandInnerX,
            y: bandPos,
            width: bandInnerW,
            height: Math.max(1, bandSize),
            fill: fillColor,
            stroke: strokeColor,
            "stroke-width": strokeWidth,
            "clip-path": `url(#${clipId})`
          }));
        } else {
          tracksSvg.appendChild(el("rect", {
            x: bandPos,
            y: bandInnerY,
            width: Math.max(1, bandSize),
            height: bandInnerH,
            fill: fillColor,
            stroke: strokeColor,
            "stroke-width": strokeWidth,
            "clip-path": `url(#${clipId})`
          }));
        }
      }

      // Locus highlight - small red rectangle showing current view position
      const locusCenter = (state.startBp + state.endBp) / 2;
      const locusFrac = locusCenter / chrLength;
      
      // Determine if locus is on p-arm or q-arm
      const isLocusPArm = locusCenter <= centromerePos;
      
      if (isVertical) {
        let locusY, locusHighlightHeight = 12;
        if (isLocusPArm) {
          // p-arm is at bottom
          const pFrac = locusCenter / pArmLength;
          locusY = pY + pH - (pFrac * pH);
        } else {
          // q-arm is at top
          const qFrac = (locusCenter - centromerePos) / qArmLength;
          locusY = qY + (qFrac * qH);
        }
        const locusHighlightY = Math.max(
          isLocusPArm ? pY : qY,
          Math.min(
            (isLocusPArm ? pY + pH : qY + qH) - locusHighlightHeight,
            locusY - locusHighlightHeight / 2
          )
        );
        
        tracksSvg.appendChild(el("rect", {
          x: (isLocusPArm ? pX : qX) - 1,
          y: locusHighlightY,
          width: (isLocusPArm ? pW : qW) + 2,
          height: locusHighlightHeight,
          fill: "rgba(255,77,77,0.25)",
          stroke: "rgba(255,77,77,0.95)",
          "stroke-width": 1
        }));
      } else {
        let locusX, locusHighlightWidth = 12;
        if (isLocusPArm) {
          // p-arm is on left
          const pFrac = locusCenter / pArmLength;
          locusX = pX + (pFrac * pW);
        } else {
          // q-arm is on right
          const qFrac = (locusCenter - centromerePos) / qArmLength;
          locusX = qX + (qFrac * qW);
        }
        const locusHighlightX = Math.max(
          isLocusPArm ? pX : qX,
          Math.min(
            (isLocusPArm ? pX + pW : qX + qW) - locusHighlightWidth,
            locusX - locusHighlightWidth / 2
          )
        );
        
        tracksSvg.appendChild(el("rect", {
          x: locusHighlightX,
          y: (isLocusPArm ? pY : qY) - 1,
          width: locusHighlightWidth,
          height: (isLocusPArm ? pH : qH) + 2,
          fill: "rgba(255,77,77,0.25)",
          stroke: "rgba(255,77,77,0.95)",
          "stroke-width": 1
        }));
      }
    }

    // --- Genes track (exons/introns/strand)
    if (!genesLayout.track.collapsed) {
      let geneStartX, geneStartY, laneDim, lanes, genesDim;
      if (isVertical) {
        geneStartX = genesLayout.contentLeft + 8;
        laneDim = 30;
        lanes = 3;
        genesDim = lanes * laneDim;
        geneStartY = 16;
      } else {
        geneStartY = genesLayout.contentTop + 8;
        laneDim = 30;
        lanes = 3;
        genesDim = lanes * laneDim;
        geneStartX = 16;
      }

      for (let lane=0; lane<lanes; lane++) {
        if (isVertical) {
          const x = geneStartX + lane*laneDim + laneDim/2;
          tracksSvg.appendChild(el("line", {
            x1: x, x2: x, y1: 16, y2: H-16,
            stroke: "rgba(127,127,127,0.14)"
          }));
        } else {
          const y = geneStartY + lane*laneDim + laneDim/2;
          tracksSvg.appendChild(el("line", {
            x1: 16, x2: W-16, y1: y, y2: y,
            stroke: "rgba(127,127,127,0.14)"
          }));
        }
      }

      function drawStrandArrows(pos1, pos2, perpPos, strand, isVert) {
        const dir = strand === "-" ? -1 : 1;
        const step = 24;
        const start = Math.min(pos1, pos2), end = Math.max(pos1, pos2);
        for (let p = start + 10; p < end - 10; p += step) {
          const size = 5;
          if (isVert) {
            const cy = p;
            const p1 = `${perpPos},${cy}`;
            const p2 = `${perpPos - dir*size*0.8},${cy + dir*size}`;
            const p3 = `${perpPos + dir*size*0.8},${cy + dir*size}`;
            tracksSvg.appendChild(el("polygon", {
              points: `${p1} ${p2} ${p3}`,
              fill: "rgba(127,127,127,0.45)"
            }));
          } else {
            const cx = p;
            const p1 = `${cx},${perpPos}`;
            const p2 = `${cx - dir*size},${perpPos - size*0.8}`;
            const p3 = `${cx - dir*size},${perpPos + size*0.8}`;
            tracksSvg.appendChild(el("polygon", {
              points: `${p1} ${p2} ${p3}`,
              fill: "rgba(127,127,127,0.45)"
            }));
          }
        }
      }

    for (const t of transcripts) {
      const s = Math.max(t.start, state.startBp);
      const e = Math.min(t.end,   state.endBp);
      if (e <= state.startBp || s >= state.endBp) continue;

      let perpPos;
      if (isVertical) {
        perpPos = geneStartX + t.lane*laneDim + laneDim/2;
      } else {
        perpPos = geneStartY + t.lane*laneDim + laneDim/2;
      }

      // intron baseline (full transcript span)
      const pos1 = genomePos(s);
      const pos2 = genomePos(e);
      
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: perpPos, x2: perpPos, y1: pos1, y2: pos2,
          stroke: "rgba(127,127,127,0.40)",
          "stroke-width": 1
        }));
        drawStrandArrows(pos1, pos2, perpPos, t.strand, true);
      } else {
        tracksSvg.appendChild(el("line", {
          x1: pos1, x2: pos2, y1: perpPos, y2: perpPos,
          stroke: "rgba(127,127,127,0.40)",
          "stroke-width": 1
        }));
        drawStrandArrows(pos1, pos2, perpPos, t.strand, false);
      }

      // exons
      let firstExonY = null; // Track bottom-most exon Y position for gene name alignment in vertical mode
      let firstExonX = null; // Track first exon X position for gene name alignment in horizontal mode
      for (const [es0, ee0] of t.exons) {
        const es = Math.max(es0, state.startBp);
        const ee = Math.min(ee0, state.endBp);
        if (ee <= state.startBp || es >= state.endBp) continue;
        const exPos1 = genomePos(es);
        const exPos2 = genomePos(ee);

        if (isVertical) {
          // In vertical mode, exons are horizontal bars
          // exPos1 and exPos2 are Y coordinates, need to ensure correct ordering
          const yMin = Math.min(exPos1, exPos2);
          const yMax = Math.max(exPos1, exPos2);
          // Track the bottom-most exon's bottom Y position for gene name alignment
          // (yMax is the bottom of the exon in vertical mode where higher Y = bottom)
          // We want the highest Y value (bottom-most exon)
          if (firstExonY === null || yMax > firstExonY) {
            firstExonY = yMax;
          }
          tracksSvg.appendChild(el("rect", {
            x: perpPos - 6, y: yMin,
            width: 12, height: Math.max(2, yMax - yMin),
            rx: 4,
            fill: "var(--blueFill)",
            stroke: "var(--blue)",
            "stroke-width": 1
          }));
        } else {
          // Track the first exon's X position for gene name alignment
          if (firstExonX === null) {
            firstExonX = exPos1;
          }
          tracksSvg.appendChild(el("rect", {
            x: exPos1, y: perpPos - 6,
            width: Math.max(2, exPos2 - exPos1), height: 12,
            rx: 4,
            fill: "var(--blueFill)",
            stroke: "var(--blue)",
            "stroke-width": 1
          }));
        }
      }

      // gene label near transcript start
      if (isVertical) {
        // Gene name to the left of the gene track
        // Y position should match the bottom of the bottom-most exon
        const geneNameY = firstExonY !== null ? firstExonY : pos1;
        tracksSvg.appendChild(el("text", {
          x: perpPos - 8,
          y: geneNameY,
          class:"svg-geneName",
          "text-anchor": "start",
          "dominant-baseline": "text-after-edge",
          transform: "rotate(-90 " + (perpPos - 8) + " " + geneNameY + ")"
        }, `${t.name}`));
        // Strand indicator to the right of the gene track (just a bit to the right)
        tracksSvg.appendChild(el("text", {
          x: perpPos + 8,
          y: pos1,
          class:"svg-small",
          "text-anchor": "start",
          "dominant-baseline": "middle"
        }, t.strand === "+" ? "↑" : "↓"));
      } else {
        // In horizontal mode, X position should match the first exon's X position
        const geneNameX = firstExonX !== null ? firstExonX : pos1;
        tracksSvg.appendChild(el("text", {
          x: geneNameX,
          y: perpPos - 12,
          class:"svg-geneName"
        }, `${t.name}`));
        tracksSvg.appendChild(el("text", {
          x: pos1 + 2,
          y: perpPos + 16,
          class:"svg-small"
        }, t.strand === "+" ? "→" : "←"));
      }
    }
    }

    // --- RepeatMasker track
    if (!repeatsLayout.track.collapsed) {
      let repeatsX, repeatsY, repeatsW, repeatsH;
      if (isVertical) {
        repeatsX = repeatsLayout.contentLeft + 8;
        repeatsW = 22;
        repeatsY = 16;
        // In vertical mode, repeatsH should use W (genomic axis dimension), not H
        repeatsH = W - 32;
      } else {
        repeatsY = repeatsLayout.contentTop + 8;
        repeatsH = 22;
        repeatsX = 16;
        repeatsW = W - 32;
      }

      // background guide line
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: repeatsX + repeatsW/2, x2: repeatsX + repeatsW/2, y1: 16, y2: W-16,
          stroke: "rgba(127,127,127,0.16)"
        }));
      } else {
        tracksSvg.appendChild(el("line", {
          x1: 16, x2: W-16, y1: repeatsY + repeatsH/2, y2: repeatsY + repeatsH/2,
          stroke: "rgba(127,127,127,0.16)"
        }));
      }

    function repeatColor(cls) {
      // simple palette-ish mapping; kept subtle
      switch (cls) {
        case "SINE": return "rgba(255, 206, 86, 0.35)";
        case "LINE": return "rgba(75, 192, 192, 0.28)";
        case "LTR":  return "rgba(153, 102, 255, 0.28)";
        case "DNA":  return "rgba(255, 99, 132, 0.22)";
        default:     return "rgba(201, 203, 207, 0.22)";
      }
    }

    function repeatColorToRgba(cls) {
      const rgbaStr = repeatColor(cls);
      // Parse "rgba(255, 206, 86, 0.35)" to [r, g, b, a] normalized
      const match = rgbaStr.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
      if (match) {
        return [
          parseInt(match[1]) / 255,
          parseInt(match[2]) / 255,
          parseInt(match[3]) / 255,
          parseFloat(match[4])
        ];
      }
      return [0.5, 0.5, 0.5, 0.5]; // fallback
    }

    // Optimize repeat rendering: filter, cluster, and batch DOM operations
    // Calculate minimum pixel width (don't render repeats smaller than 1 pixel)
    const minPixelWidth = 1;
    const clusterThreshold = 5; // Cluster repeats within 5bp of each other
    const maxRepeatsToRender = 5000; // Safety limit to prevent crashes

    // Filter and prepare visible repeats
    const visibleRepeats = [];
    for (const r of repeats) {
      if (r.end <= state.startBp || r.start >= state.endBp) continue;
      const rs = Math.max(r.start, state.startBp);
      const re = Math.min(r.end, state.endBp);
      
      const pos1 = genomePos(rs);
      const pos2 = genomePos(re);
      const width = Math.abs(pos2 - pos1);
      
      // Skip repeats that are too small to render
      if (width < minPixelWidth) continue;
      
      visibleRepeats.push({
        start: rs,  // Clamped start for rendering
        end: re,   // Clamped end for rendering
        originalStart: r.start,  // Original RepeatMasker start coordinate
        originalEnd: r.end,     // Original RepeatMasker end coordinate
        cls: r.cls,
        pos1: pos1,
        pos2: pos2,
        width: width
      });
    }

    // Sort by position for clustering
    visibleRepeats.sort((a, b) => a.start - b.start);

    // Cluster nearby repeats of the same class to reduce DOM elements
    const clusteredRepeats = [];
    let currentCluster = null;
    
    for (const r of visibleRepeats) {
      if (currentCluster && 
          r.cls === currentCluster.cls &&
          r.start - currentCluster.end <= clusterThreshold) {
        // Merge into current cluster
        currentCluster.end = Math.max(currentCluster.end, r.end);
        currentCluster.originalEnd = Math.max(currentCluster.originalEnd, r.originalEnd);
        currentCluster.pos2 = genomePos(currentCluster.end);
        currentCluster.width = Math.abs(currentCluster.pos2 - currentCluster.pos1);
      } else {
        // Start new cluster
        if (currentCluster) {
          clusteredRepeats.push(currentCluster);
        }
        currentCluster = {
          start: r.start,
          end: r.end,
          originalStart: r.originalStart,
          originalEnd: r.originalEnd,
          cls: r.cls,
          pos1: r.pos1,
          pos2: r.pos2,
          width: r.width
        };
      }
    }
    if (currentCluster) {
      clusteredRepeats.push(currentCluster);
    }

    // Limit the number of elements to render (take first N if too many)
    const repeatsToRender = clusteredRepeats.slice(0, maxRepeatsToRender);
    
    if (clusteredRepeats.length > maxRepeatsToRender) {
      console.warn(`Too many repeats (${clusteredRepeats.length}), rendering only first ${maxRepeatsToRender}`);
    }

    // Store repeat data for hit testing
    repeatHitTestData = [];
    
    // Use WebGPU if available, otherwise fall back to SVG
    if (webgpuSupported && instancedRenderer) {
      // Add rectangles to WebGPU renderer
      // Scale by devicePixelRatio since WebGPU canvas uses physical pixels
      const dpr = window.devicePixelRatio || 1;
      
      for (const r of repeatsToRender) {
        const pos1 = r.pos1;
        const pos2 = r.pos2;
        const width = Math.max(1, pos2 - pos1);
        const height = repeatsH - 8;
        
        let x, y, w, h;
        if (isVertical) {
          const yMin = Math.min(pos1, pos2);
          const yMax = Math.max(pos1, pos2);
          x = repeatsX + 4;
          y = yMin;
          w = repeatsW - 8;
          h = Math.max(1, yMax - yMin);
        } else {
          x = pos1;
          y = repeatsY + 4;
          w = width;
          h = height;
        }
        
        const rgba = repeatColorToRgba(r.cls);
        // Scale coordinates by DPR to match physical pixel canvas
        instancedRenderer.addRect(x * dpr, y * dpr, w * dpr, h * dpr, rgba);
        
        // Store for hit testing (use original RepeatMasker coordinates, not clamped/clustered)
        repeatHitTestData.push({
          start: r.originalStart,
          end: r.originalEnd,
          cls: r.cls
        });
      }
    } else {
      // Fallback to SVG rendering
      const fragment = document.createDocumentFragment();
      
      for (const r of repeatsToRender) {
        const pos1 = r.pos1;
        const pos2 = r.pos2;
        const isSmall = r.width < 3; // Don't add stroke for very small elements
        
        // Format tooltip text with repeat class and original coordinates
        const tooltipText = `${r.cls} repeat\n${Math.floor(r.originalStart).toLocaleString()} - ${Math.floor(r.originalEnd).toLocaleString()}`;
        
        // Create rect element
        let rect;
        if (isVertical) {
          const yMin = Math.min(pos1, pos2);
          const yMax = Math.max(pos1, pos2);
          rect = el("rect", {
            x: repeatsX + 4,
            y: yMin,
            width: repeatsW - 8,
            height: Math.max(1, yMax - yMin),
            rx: isSmall ? 0 : 6,
            fill: repeatColor(r.cls),
            style: "cursor: pointer;"
          });
          if (!isSmall) {
            rect.setAttribute("stroke", "rgba(127,127,127,0.20)");
          }
        } else {
          rect = el("rect", {
            x: pos1,
            y: repeatsY + 4,
            width: Math.max(1, pos2 - pos1),
            height: repeatsH - 8,
            rx: isSmall ? 0 : 6,
            fill: repeatColor(r.cls),
            style: "cursor: pointer;"
          });
          if (!isSmall) {
            rect.setAttribute("stroke", "rgba(127,127,127,0.20)");
          }
        }
        
        // Add mouse event handlers for tooltip
        rect.addEventListener("mousemove", (e) => {
          state.hoveredRepeatTooltip = {
            text: tooltipText,
            x: e.clientX + 10,
            y: e.clientY + 10
          };
          updateTooltip();
        });
        
        rect.addEventListener("mouseleave", () => {
          state.hoveredRepeatTooltip = null;
          updateTooltip();
        });
        
        fragment.appendChild(rect);
      }
      
      // Append all elements at once (single DOM operation)
      tracksSvg.appendChild(fragment);
    }
    }

    // --- Locus ruler
    if (!rulerLayout.track.collapsed) {
      let rulerX, rulerY, rulerW, rulerH, baseX, baseY;
      if (isVertical) {
        rulerX = rulerLayout.contentLeft + 8;
        rulerW = 56;
        rulerY = 16;
        rulerH = H - 32;
        baseX = rulerX + 14;
      } else {
        rulerY = rulerLayout.contentTop + 8;
        rulerH = 56;
        rulerX = 16;
        rulerW = W - 32;
        baseY = rulerY + 14;
      }

      // Base line
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: baseX, x2: baseX, y1: 16, y2: H-16,
          stroke: "rgba(127,127,127,0.70)",
          "stroke-width": 1.2
        }));
      } else {
        tracksSvg.appendChild(el("line", {
          x1: 16, x2: W-16, y1: baseY, y2: baseY,
          stroke: "rgba(127,127,127,0.70)",
          "stroke-width": 1.2
        }));
      }

      const span = state.endBp - state.startBp;
      const dim = isVertical ? H : W;
      const desiredMajorTicks = Math.max(5, Math.min(10, Math.floor((dim - 32) / 140)));
      const majorBp = chooseNiceTickBp(span, desiredMajorTicks);
      const minorBp = majorBp / 5;

      const pxPerMajor = (dim - 32) / (span / majorBp);
      const showLabels = pxPerMajor >= 80;

    const firstMinor = Math.ceil(state.startBp / minorBp) * minorBp;

    // Track major tick label positions to avoid overlap with edge labels
    const majorTickLabelPositions = [];

    for (let bp = firstMinor; bp <= state.endBp; bp += minorBp) {
      const pos = genomePos(bp);
      const isMajor = (Math.round(bp / minorBp) % 5) === 0;

      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: baseX - (isMajor ? 9 : 5), x2: baseX + (isMajor ? 9 : 5),
          y1: pos, y2: pos,
          stroke: isMajor ? "rgba(127,127,127,0.55)" : "rgba(127,127,127,0.30)",
          "stroke-width": isMajor ? 1.1 : 1
        }));

        if (isMajor && showLabels) {
          const textEl = el("text", {
            x: baseX + 26,
            y: pos,
            class: "svg-small",
            "text-anchor": "start",
            "dominant-baseline": "middle",
            transform: "rotate(-90 " + (baseX + 26) + " " + pos + ")"
          }, formatBp(Math.round(bp), span));
          tracksSvg.appendChild(textEl);
          majorTickLabelPositions.push(pos);
        }
      } else {
        tracksSvg.appendChild(el("line", {
          x1: pos, x2: pos,
          y1: baseY - (isMajor ? 9 : 5), y2: baseY + (isMajor ? 9 : 5),
          stroke: isMajor ? "rgba(127,127,127,0.55)" : "rgba(127,127,127,0.30)",
          "stroke-width": isMajor ? 1.1 : 1
        }));

        if (isMajor && showLabels) {
          tracksSvg.appendChild(el("text", {
            x: pos,
            y: baseY + 26,
            class: "svg-small",
            "text-anchor": "middle"
          }, formatBp(Math.round(bp), span)));
          majorTickLabelPositions.push(pos);
        }
      }
    }

    // Only show edge labels if no tick label is too close
    const edgeThreshold = 100; // pixels
    if (isVertical) {
      const bottomEdgeY = H - 16;
      const topEdgeY = 16;
      const hasNearbyBottomTick = majorTickLabelPositions.some(tickY => Math.abs(tickY - bottomEdgeY) < edgeThreshold);
      const hasNearbyTopTick = majorTickLabelPositions.some(tickY => Math.abs(tickY - topEdgeY) < edgeThreshold);

      if (!hasNearbyBottomTick) {
        const textEl = el("text", {
          x: baseX + 26, y: bottomEdgeY, class:"svg-small", "text-anchor":"start", "dominant-baseline":"middle",
          transform: "rotate(-90 " + (baseX + 26) + " " + bottomEdgeY + ")"
        }, formatBp(Math.round(state.startBp), span));
        tracksSvg.appendChild(textEl);
      }
      if (!hasNearbyTopTick) {
        const textEl = el("text", {
          x: baseX + 26, y: topEdgeY, class:"svg-small", "text-anchor":"start", "dominant-baseline":"middle",
          transform: "rotate(-90 " + (baseX + 26) + " " + topEdgeY + ")"
        }, formatBp(Math.round(state.endBp), span));
        tracksSvg.appendChild(textEl);
      }
    } else {
      const leftEdgeX = 16;
      const rightEdgeX = W - 16;
      const hasNearbyLeftTick = majorTickLabelPositions.some(tickX => Math.abs(tickX - leftEdgeX) < edgeThreshold);
      const hasNearbyRightTick = majorTickLabelPositions.some(tickX => Math.abs(tickX - rightEdgeX) < edgeThreshold);

      if (!hasNearbyLeftTick) {
        tracksSvg.appendChild(el("text", { x: 16, y: baseY + 26, class:"svg-small" },
          formatBp(Math.round(state.startBp), span)
        ));
      }
      if (!hasNearbyRightTick) {
        tracksSvg.appendChild(el("text", {
          x: W - 16, y: baseY + 26, class:"svg-small", "text-anchor":"end"
        }, formatBp(Math.round(state.endBp), span)));
      }
    }

    // Variant marks
    for (let idx = 0; idx < variants.length; idx++) {
      const v = variants[idx];
      if (v.pos < state.startBp || v.pos > state.endBp) continue;
      const pos = genomePos(v.pos);
      const isHovered = state.hoveredVariantIndex === idx;
      const strokeWidth = isHovered ? 2.5 : 1.2;
      const circleStrokeWidth = isHovered ? 2.2 : 1.4;
      const isIns = isInsertion(v);

      let lineEl;
      const strokeColor = isHovered ? "var(--blue)" : "rgba(127,127,127,0.5)";
      if (isVertical) {
        lineEl = el("line", {
          x1: baseX - 18, x2: baseX + 18,
          y1: pos, y2: pos,
          stroke: strokeColor,
          "stroke-width": strokeWidth,
          style: "cursor: pointer;"
        });
      } else {
        lineEl = el("line", {
          x1: pos, x2: pos,
          y1: baseY - 18, y2: baseY + 18,
          stroke: strokeColor,
          "stroke-width": strokeWidth,
          style: "cursor: pointer;"
        });
      }
      lineEl.addEventListener("mouseenter", () => {
        state.hoveredVariantIndex = idx;
        renderAll();
      });
      lineEl.addEventListener("mouseleave", () => {
        state.hoveredVariantIndex = null;
        renderAll();
      });
      
      // For insertions, add pointerdown handler to the line itself
      if (isInsertion(v)) {
        lineEl.style.pointerEvents = "auto";
        lineEl.addEventListener("pointerdown", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (state.expandedInsertions.has(v.id)) {
            state.expandedInsertions.delete(v.id);
          } else {
            state.expandedInsertions.add(v.id);
          }
          renderAll();
        });
      }
      tracksSvg.appendChild(lineEl);
      
      // For insertions, add a larger invisible clickable area AFTER the line (so it's on top)
      if (isInsertion(v)) {
        // Add an invisible wider rectangle for easier clicking
        let clickArea;
        if (isVertical) {
          clickArea = el("rect", {
            x: baseX - 20,
            y: pos - 5,
            width: 40,
            height: 10,
            fill: "transparent",
            style: "cursor: pointer; pointer-events: auto;"
          });
        } else {
          clickArea = el("rect", {
            x: pos - 5,
            y: baseY - 20,
            width: 10,
            height: 40,
            fill: "transparent",
            style: "cursor: pointer; pointer-events: auto;"
          });
        }
        clickArea.addEventListener("pointerdown", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (state.expandedInsertions.has(v.id)) {
            state.expandedInsertions.delete(v.id);
          } else {
            state.expandedInsertions.add(v.id);
          }
          renderAll();
        });
        tracksSvg.appendChild(clickArea);
      }

      let circleEl;
      const circleStrokeColor = isHovered ? "var(--blue)" : "rgba(127,127,127,0.5)";
      if (isVertical) {
        circleEl = el("circle", {
          cx: baseX - 18, cy: pos, r: 3.4,
          fill: "none",
          stroke: circleStrokeColor,
          "stroke-width": circleStrokeWidth,
          style: "cursor: pointer;"
        });
      } else {
        circleEl = el("circle", {
          cx: pos, cy: baseY - 18, r: 3.4,
          fill: "none",
          stroke: circleStrokeColor,
          "stroke-width": circleStrokeWidth,
          style: "cursor: pointer;"
        });
      }
      circleEl.addEventListener("mouseenter", () => {
        state.hoveredVariantIndex = idx;
        renderAll();
      });
      circleEl.addEventListener("mouseleave", () => {
        state.hoveredVariantIndex = null;
        renderAll();
      });
      // Pointerdown handler to toggle insertion expansion
      if (isInsertion(v)) {
        circleEl.style.pointerEvents = "auto";
        circleEl.addEventListener("pointerdown", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (state.expandedInsertions.has(v.id)) {
            state.expandedInsertions.delete(v.id);
          } else {
            state.expandedInsertions.add(v.id);
          }
          renderAll();
        });
      }
      tracksSvg.appendChild(circleEl);
      
      // Draw expanded insertion sequence if expanded
      if (state.expandedInsertions.has(v.id) && isInsertion(v)) {
        const maxInsertLen = getMaxInsertionLength(v);
        const gapSize = maxInsertLen * 8;
        
        // Draw inserted sequence (use longest alt allele)
        const longestAlt = v.altAlleles.reduce((a, b) => a.length > b.length ? a : b);
        const insertedSeq = longestAlt.substring(v.refAllele.length);
        const baseSize = gapSize / insertedSeq.length;
        
        const nucleotideColors = {
          'A': 'rgba(0, 200, 0, 0.8)',      // green
          'C': 'rgba(0, 0, 255, 0.8)',      // blue
          'G': 'rgba(255, 165, 0, 0.8)',    // orange
          'T': 'rgba(255, 0, 0, 0.8)'       // red
        };
        
        if (isVertical) {
          const gapStartY = pos;
          const gapEndY = gapStartY - gapSize; // going up (toward start)
          
          // Draw gap background
          tracksSvg.appendChild(el("rect", {
            x: baseX - 18,
            y: gapEndY,
            width: 36,
            height: gapSize,
            fill: "rgba(255,255,255,0.1)",
            stroke: "rgba(127,127,127,0.3)",
            "stroke-width": 1,
            "stroke-dasharray": "2,2"
          }));
          
          for (let i = 0; i < insertedSeq.length; i++) {
            const base = insertedSeq[i].toUpperCase();
            const baseY = gapStartY - (i + 1) * baseSize;
            const color = nucleotideColors[base] || 'rgba(127,127,127,0.8)';
            
            tracksSvg.appendChild(el("rect", {
              x: baseX - 16,
              y: baseY,
              width: 32,
              height: baseSize - 1,
              fill: color
            }));
            
            // Draw base letter if space allows
            if (baseSize >= 8) {
              const textEl = el("text", {
                x: baseX,
                y: baseY + baseSize / 2,
                class: "svg-small",
                "text-anchor": "middle",
                fill: "white",
                "font-weight": "bold",
                "dominant-baseline": "middle",
                transform: "rotate(-90 " + baseX + " " + (baseY + baseSize / 2) + ")"
              }, base);
              tracksSvg.appendChild(textEl);
            }
          }
        } else {
          const gapStartX = pos;
          const gapEndX = gapStartX + gapSize;
          
          // Draw gap background
          tracksSvg.appendChild(el("rect", {
            x: gapStartX,
            y: baseY - 18,
            width: gapSize,
            height: 36,
            fill: "rgba(255,255,255,0.1)",
            stroke: "rgba(127,127,127,0.3)",
            "stroke-width": 1,
            "stroke-dasharray": "2,2"
          }));
          
          for (let i = 0; i < insertedSeq.length; i++) {
            const base = insertedSeq[i].toUpperCase();
            const baseX = gapStartX + i * baseSize;
            const color = nucleotideColors[base] || 'rgba(127,127,127,0.8)';
            
            tracksSvg.appendChild(el("rect", {
              x: baseX,
              y: baseY - 16,
              width: baseSize - 1,
              height: 32,
              fill: color
            }));
            
            // Draw base letter if space allows
            if (baseSize >= 8) {
              tracksSvg.appendChild(el("text", {
                x: baseX + baseSize / 2,
                y: baseY,
                class: "svg-small",
                "text-anchor": "middle",
                fill: "white",
                "font-weight": "bold",
                "dominant-baseline": "middle"
              }, base));
            }
          }
        }
      }
    }

      // separator
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: rulerX + rulerW, x2: rulerX + rulerW, y1: 0, y2: H,
          stroke: "rgba(127,127,127,0.12)"
        }));
      } else {
        tracksSvg.appendChild(el("line", {
          x1: 0, x2: W, y1: rulerY + rulerH, y2: rulerY + rulerH,
          stroke: "rgba(127,127,127,0.12)"
        }));
      }
    }

    // --- Reference track
    if (!referenceLayout.track.collapsed) {
      let referenceX, referenceY, referenceW, referenceH;
      if (isVertical) {
        referenceX = referenceLayout.contentLeft + 8;
        referenceW = 24;
        referenceY = 16;
        referenceH = H - 32;
      } else {
        referenceY = referenceLayout.contentTop + 8;
        referenceH = 24;
        referenceX = 16;
        referenceW = W - 32;
      }

      // Helper function to get reference sequence for a region
      // Returns { sequence: array, startBp: number } where startBp is the genomic position of sequence[0]
      function getReferenceSequence(startBp, endBp) {
        // Use the real reference sequence from config if available
        if (referenceSequence && referenceSequence.length > 0) {
          // Calculate the offset into the sequence
          // The reference sequence starts at data_bounds.start (0-based)
          // UCSC returns sequence for [start, end), so sequence[i] corresponds to genomic position (dataStart + i)
          const dataStart = window.GENOMESHADER_CONFIG?.data_bounds?.start || 0;
          const viewStart = Math.floor(startBp);
          const viewEnd = Math.floor(endBp);
          
          // Calculate sequence indices (0-based relative to sequence start)
          // seqStart: index in sequence string for viewStart genomic position
          // seqEnd: index in sequence string for (viewEnd + 1) genomic position (exclusive end)
          const seqStart = Math.max(0, viewStart - dataStart);
          const seqEnd = Math.min(referenceSequence.length, viewEnd - dataStart + 1);
          
          // Only return sequence if we have valid indices within bounds
          if (seqStart >= 0 && seqEnd > seqStart && seqStart < referenceSequence.length) {
            const sequence = referenceSequence.slice(seqStart, seqEnd).split('');
            // The actual genomic start position of the returned sequence
            const actualStartBp = dataStart + seqStart;
            return { sequence: sequence, startBp: actualStartBp };
          }
        }
        // Fallback: return empty array if no sequence data
        return { sequence: [], startBp: startBp };
      }

      const span = state.endBp - state.startBp;
      const startBpInt = Math.floor(state.startBp);
      const endBpInt = Math.floor(state.endBp);
      const refSeqData = getReferenceSequence(startBpInt, endBpInt);
      const refSeq = refSeqData.sequence;
      const refSeqStartBp = refSeqData.startBp;

      const nucleotideColors = {
        'A': 'rgba(0, 200, 0, 0.8)',      // green
        'C': 'rgba(0, 0, 255, 0.8)',      // blue
        'G': 'rgba(255, 165, 0, 0.8)',    // orange
        'T': 'rgba(255, 0, 0, 0.8)'       // red
      };

      // Helper function to convert nucleotide color to RGBA array for WebGPU
      function nucleotideColorToRgba(base) {
        const rgbaStr = nucleotideColors[base] || 'rgba(127,127,127,0.8)';
        const match = rgbaStr.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        if (match) {
          return [
            parseInt(match[1]) / 255,
            parseInt(match[2]) / 255,
            parseInt(match[3]) / 255,
            parseFloat(match[4])
          ];
        }
        return [0.5, 0.5, 0.5, 0.8]; // fallback
      }

      // Calculate base size based on zoom level
      const minBaseSize = 2; // Minimum size per base in pixels
      const baseSize = Math.max(minBaseSize, state.pxPerBp);

      // Only show individual bases if zoomed in enough (at least 2 actual pixels per base)
      const showIndividualBases = state.pxPerBp >= 2;

      // Performance limit: maximum number of bases to render
      const maxBasesToRender = 10000;

      if (showIndividualBases && refSeq.length > 0) {
        // Filter and prepare visible bases
        const visibleBases = [];
        for (let i = 0; i < refSeq.length; i++) {
          // Calculate the actual genomic position for this base
          // refSeq[i] corresponds to genomic position refSeqStartBp + i
          const bp = refSeqStartBp + i;
          
          // Only render bases that are within the visible view
          if (bp < state.startBp || bp > state.endBp) continue;
          
          // Use genomePosCanonical to account for insertion gaps
          const pos = genomePosCanonical(bp);
          const nextBp = bp + 1;
          const nextPos = nextBp <= state.endBp ? genomePosCanonical(nextBp) : genomePosCanonical(state.endBp);
          const actualSize = Math.max(minBaseSize, Math.abs(nextPos - pos));
          
          // Skip bases that are too small to render
          if (actualSize < minBaseSize) continue;
          
          const base = refSeq[i].toUpperCase();
          visibleBases.push({
            bp: bp,
            base: base,
            pos: pos,
            nextPos: nextPos,
            actualSize: actualSize
          });
        }

        // Limit the number of bases to render
        const basesToRender = visibleBases.slice(0, maxBasesToRender);
        
        if (visibleBases.length > maxBasesToRender) {
          console.warn(`Too many bases (${visibleBases.length}), rendering only first ${maxBasesToRender}`);
        }

        // Use WebGPU if available, otherwise fall back to SVG
        if (webgpuSupported && instancedRenderer) {
          // Add rectangles to WebGPU renderer
          // Scale by devicePixelRatio since WebGPU canvas uses physical pixels
          const dpr = window.devicePixelRatio || 1;
          
          for (const b of basesToRender) {
            const pos = b.pos;
            const actualSize = b.actualSize;
            const base = b.base;
            const rgba = nucleotideColorToRgba(base);
            
            let x, y, w, h;
            if (isVertical) {
              x = referenceX;
              y = pos;
              w = referenceW;
              h = actualSize - 0.5;
            } else {
              x = pos;
              y = referenceY;
              w = actualSize - 0.5;
              h = referenceH;
            }
            
            // Scale coordinates by DPR to match physical pixel canvas
            instancedRenderer.addRect(x * dpr, y * dpr, w * dpr, h * dpr, rgba);
          }
          
          // Draw base letters using SVG (text rendering can stay SVG-based)
          const fragment = document.createDocumentFragment();
          for (const b of basesToRender) {
            if (b.actualSize >= 8) {
              const base = b.base;
              const pos = b.pos;
              const actualSize = b.actualSize;
              
              if (isVertical) {
                const textEl = el("text", {
                  x: referenceX + referenceW / 2,
                  y: pos + actualSize / 2,
                  class: "svg-small",
                  "text-anchor": "middle",
                  fill: "#fff",
                  stroke: "#000",
                  "stroke-width": "0.5",
                  "font-weight": "bold",
                  "dominant-baseline": "middle",
                  transform: "rotate(-90 " + (referenceX + referenceW / 2) + " " + (pos + actualSize / 2) + ")"
                }, base);
                fragment.appendChild(textEl);
              } else {
                const textEl = el("text", {
                  x: pos + actualSize / 2,
                  y: referenceY + referenceH / 2,
                  class: "svg-small",
                  "text-anchor": "middle",
                  fill: "#fff",
                  stroke: "#000",
                  "stroke-width": "0.5",
                  "font-weight": "bold",
                  "dominant-baseline": "middle"
                }, base);
                fragment.appendChild(textEl);
              }
            }
          }
          tracksSvg.appendChild(fragment);
        } else {
          // Fallback to SVG rendering
          const fragment = document.createDocumentFragment();
          
          for (const b of basesToRender) {
            const pos = b.pos;
            const actualSize = b.actualSize;
            const base = b.base;
            const color = nucleotideColors[base] || 'rgba(127,127,127,0.8)';
            
            if (isVertical) {
              fragment.appendChild(el("rect", {
                x: referenceX,
                y: pos,
                width: referenceW,
                height: actualSize - 0.5,
                fill: color
              }));

              // Draw base letter if space allows
              if (actualSize >= 8) {
                const textEl = el("text", {
                  x: referenceX + referenceW / 2,
                  y: pos + actualSize / 2,
                  class: "svg-small",
                  "text-anchor": "middle",
                  fill: "#fff",
                  stroke: "#000",
                  "stroke-width": "0.5",
                  "font-weight": "bold",
                  "dominant-baseline": "middle",
                  transform: "rotate(-90 " + (referenceX + referenceW / 2) + " " + (pos + actualSize / 2) + ")"
                }, base);
                fragment.appendChild(textEl);
              }
            } else {
              fragment.appendChild(el("rect", {
                x: pos,
                y: referenceY,
                width: actualSize - 0.5,
                height: referenceH,
                fill: color
              }));

              // Draw base letter if space allows
              if (actualSize >= 8) {
                const textEl = el("text", {
                  x: pos + actualSize / 2,
                  y: referenceY + referenceH / 2,
                  class: "svg-small",
                  "text-anchor": "middle",
                  fill: "#fff",
                  stroke: "#000",
                  "stroke-width": "0.5",
                  "font-weight": "bold",
                  "dominant-baseline": "middle"
                }, base);
                fragment.appendChild(textEl);
              }
            }
          }
          
          // Append all elements at once (single DOM operation)
          tracksSvg.appendChild(fragment);
        }
      } else {
        // Zoomed out: show a continuous reference line with subtle pattern
        if (isVertical) {
          const topPad = 16, bottomPad = 16;
          const innerH = H - topPad - bottomPad;
          const totalGapPx = getTotalInsertionGapWidth();
          const totalGapBp = totalGapPx / state.pxPerBp;
          const effectiveSpan = span + totalGapBp;

          // Draw background
          tracksSvg.appendChild(el("rect", {
            x: referenceX,
            y: topPad,
            width: referenceW,
            height: innerH,
            fill: "rgba(127,127,127,0.08)",
            rx: 4
          }));

          // Draw a subtle pattern indicating reference sequence
          const patternHeight = 20;
          for (let y = topPad; y < topPad + innerH; y += patternHeight * 2) {
            tracksSvg.appendChild(el("rect", {
              x: referenceX,
              y: y,
              width: referenceW,
              height: Math.min(patternHeight, topPad + innerH - y),
              fill: "rgba(127,127,127,0.12)"
            }));
          }
        } else {
          const leftPad = 16, rightPad = 16;
          const innerW = W - leftPad - rightPad;
          const totalGapPx = getTotalInsertionGapWidth();
          const totalGapBp = totalGapPx / state.pxPerBp;
          const effectiveSpan = span + totalGapBp;

          // Draw background
          tracksSvg.appendChild(el("rect", {
            x: leftPad,
            y: referenceY,
            width: innerW,
            height: referenceH,
            fill: "rgba(127,127,127,0.08)",
            rx: 4
          }));

          // Draw a subtle pattern indicating reference sequence
          const patternWidth = 20;
          for (let x = leftPad; x < leftPad + innerW; x += patternWidth * 2) {
            tracksSvg.appendChild(el("rect", {
              x: x,
              y: referenceY,
              width: Math.min(patternWidth, leftPad + innerW - x),
              height: referenceH,
              fill: "rgba(127,127,127,0.12)"
            }));
          }
        }
      }

      // Separator
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: referenceX + referenceW, x2: referenceX + referenceW, y1: 0, y2: H,
          stroke: "rgba(127,127,127,0.12)"
        }));
      } else {
        tracksSvg.appendChild(el("line", {
          x1: 0, x2: W, y1: referenceY - 4, y2: referenceY - 4,
          stroke: "rgba(127,127,127,0.12)"
        }));
      }
    }

    // Note: WebGPU render pass is now done at the end of renderFlowCanvas()
    // to ensure variant columns are included after they're added
  }

  // -----------------------------
  // Canvas helpers
  // -----------------------------
  function resizeCanvasTo(el, canvas) {
    const dpr = window.devicePixelRatio || 1;
    const w = Math.floor(rectW(el) * dpr);
    const h = Math.floor(rectH(el) * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
    return dpr;
  }

  function visibleVariantWindow() {
    // Return all variants in the visible genomic range, not limited by state.K
    // state.K is just used for initial window sizing
    const visibleVariants = variants.filter(v => v.pos >= state.startBp && v.pos <= state.endBp);
    return visibleVariants;
  }

  function roundRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y,   x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x,   y+h, rr);
    ctx.arcTo(x,   y+h, x,   y,   rr);
    ctx.arcTo(x,   y,   x+w, y,   rr);
    ctx.closePath();
  }

  // -----------------------------
  // Sankey placeholder (Canvas2D)
  // -----------------------------
  function renderFlowCanvas() {
    const layout = getTrackLayout();
    const flowLayout = layout.find(l => l.track.id === "flow");
    if (!flowLayout || flowLayout.track.collapsed) {
      // Clear canvas if collapsed
      const ctx = flowCanvas.getContext("2d");
      ctx.clearRect(0, 0, flowCanvas.width, flowCanvas.height);
      // Clear WebGPU renderer instances
      if (flowInstancedRenderer) {
        flowInstancedRenderer.clear();
      }
      return;
    }

    const dpr = resizeCanvasTo(flow, flowCanvas);
    const ctx = flowCanvas.getContext("2d");
    
    // Clear and set up canvas
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,flowCanvas.width,flowCanvas.height);
    ctx.scale(dpr, dpr);
    
    // Clear WebGPU renderer instances
    if (flowInstancedRenderer) {
      flowInstancedRenderer.clear();
    }
    if (flowRibbonRenderer) {
      flowRibbonRenderer.clear();
    }

    const isVertical = isVerticalMode();
    const variantMode = getVariantLayoutMode();
    const junctionY = 40;
    const junctionX = 40;

    const W = flowWidthPx(), H = flowHeightPx();

    const colLines = cssVar("--grid");
    const colGrid  = cssVar("--grid2");
    const colText  = cssVar("--muted");
    const colBlue  = cssVar("--blue");
    const colGray  = "rgba(127,127,127,0.5)"; // Gray for non-hovered lines

    // drawRibbon: WebGPU Bezier ribbon renderer (replaces Canvas2D tessellation)
    // Note: srcInfo/dstInfo coordinates are in Canvas2D logical pixels (scaled by dpr)
    // WebGPU uses physical pixels, so we need to scale by devicePixelRatio
    const drawRibbon = (srcInfo, dstInfo, srcY0, srcY1, dstY0, dstY1, color) => {
      if (!srcInfo || !dstInfo) return;

      // Scale coordinates from logical pixels (Canvas2D) to physical pixels (WebGPU)
      const devicePixelRatio = window.devicePixelRatio || 1;

      // Clamp to node bounds so ribbons meet nodes flush
      const srcY0C = Math.max(srcInfo.top, Math.min(srcY0, srcInfo.bottom));
      const srcY1C = Math.max(srcInfo.top, Math.min(srcY1, srcInfo.bottom));
      const dstY0C = Math.max(dstInfo.top, Math.min(dstY0, dstInfo.bottom));
      const dstY1C = Math.max(dstInfo.top, Math.min(dstY1, dstInfo.bottom));

      // Ensure consistent top/bottom ordering (prevents "candy-wrapper twist")
      let sTop = Math.min(srcY0C, srcY1C);
      let sBot = Math.max(srcY0C, srcY1C);
      let dTop = Math.min(dstY0C, dstY1C);
      let dBot = Math.max(dstY0C, dstY1C);

      // Apply slight endpoint taper (classic alluvial aesthetic)
      // Shrink endpoints toward midpoint by ~6% for intentional joins
      const taperFrac = 0.06;
      const sMid = (sTop + sBot) / 2;
      const sHalfH = (sBot - sTop) / 2;
      sTop = sMid - sHalfH * (1 - taperFrac);
      sBot = sMid + sHalfH * (1 - taperFrac);
      
      const dMid = (dTop + dBot) / 2;
      const dHalfH = (dBot - dTop) / 2;
      dTop = dMid - dHalfH * (1 - taperFrac);
      dBot = dMid + dHalfH * (1 - taperFrac);

      const srcX = srcInfo.right;
      const dstX = dstInfo.left;
      const dx = dstX - srcX;
      if (!(dx > 1.0)) return;

      // Handle length: no fixed 10px minimum; clamp by dx to avoid loops when zoomed out
      const base = dx * 0.40;
      const handle = Math.max(1.0, Math.min(base, dx * 0.45));

      // Scale all coordinates to physical pixels for WebGPU
      const topP0 = [srcX * devicePixelRatio, sTop * devicePixelRatio];
      const topP3 = [dstX * devicePixelRatio, dTop * devicePixelRatio];
      const botP0 = [srcX * devicePixelRatio, sBot * devicePixelRatio];
      const botP3 = [dstX * devicePixelRatio, dBot * devicePixelRatio];

      // Horizontal tangents at endpoints (classic Sankey look)
      const topP1 = [(srcX + handle) * devicePixelRatio, sTop * devicePixelRatio];
      const topP2 = [(dstX - handle) * devicePixelRatio, dTop * devicePixelRatio];
      const botP1 = [(srcX + handle) * devicePixelRatio, sBot * devicePixelRatio];
      const botP2 = [(dstX - handle) * devicePixelRatio, dBot * devicePixelRatio];

      // Parse color string to RGBA floats (expects "rgba(r,g,b,a)" or similar)
      const m = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      let rgba = [0.47, 0.71, 1.0, 0.20];
      if (m) {
        rgba = [parseInt(m[1])/255, parseInt(m[2])/255, parseInt(m[3])/255, m[4] !== undefined ? parseFloat(m[4]) : 1.0];
      }

      if (webgpuSupported && flowRibbonRenderer) {
        flowRibbonRenderer.addRibbon(topP0, topP1, topP2, topP3, botP0, botP1, botP2, botP3, rgba);
        return;
      }

      // Fallback (optional): if you want, keep your old Canvas2D path here.
    };

    // drawRibbonVertical: WebGPU Bezier ribbon renderer for vertical mode
    // In vertical mode with inverted Y axis (bottom=start, top=end):
    // - Source (earlier variant) is at BOTTOM (higher Y)
    // - Destination (later variant) is at TOP (lower Y)
    // - Ribbons flow UPWARD from srcInfo.top to dstInfo.bottom
    const drawRibbonVertical = (srcInfo, dstInfo, srcX0, srcX1, dstX0, dstX1, color) => {
      if (!srcInfo || !dstInfo) return;

      // Scale coordinates from logical pixels (Canvas2D) to physical pixels (WebGPU)
      const devicePixelRatio = window.devicePixelRatio || 1;

      // Clamp to node bounds so ribbons meet nodes flush (using left/right for horizontal extent)
      const srcX0C = Math.max(srcInfo.left, Math.min(srcX0, srcInfo.right));
      const srcX1C = Math.max(srcInfo.left, Math.min(srcX1, srcInfo.right));
      const dstX0C = Math.max(dstInfo.left, Math.min(dstX0, dstInfo.right));
      const dstX1C = Math.max(dstInfo.left, Math.min(dstX1, dstInfo.right));

      // Ensure consistent left/right ordering (prevents "candy-wrapper twist")
      let sLeft = Math.min(srcX0C, srcX1C);
      let sRight = Math.max(srcX0C, srcX1C);
      let dLeft = Math.min(dstX0C, dstX1C);
      let dRight = Math.max(dstX0C, dstX1C);

      // Apply slight endpoint taper (classic alluvial aesthetic)
      // Shrink endpoints toward midpoint by ~6% for intentional joins
      const taperFrac = 0.06;
      const sMid = (sLeft + sRight) / 2;
      const sHalfW = (sRight - sLeft) / 2;
      sLeft = sMid - sHalfW * (1 - taperFrac);
      sRight = sMid + sHalfW * (1 - taperFrac);
      
      const dMid = (dLeft + dRight) / 2;
      const dHalfW = (dRight - dLeft) / 2;
      dLeft = dMid - dHalfW * (1 - taperFrac);
      dRight = dMid + dHalfW * (1 - taperFrac);

      // With inverted Y axis: source is at bottom (higher Y), dest is at top (lower Y)
      // Ribbons flow UPWARD: from srcInfo.top (top edge of source node) to dstInfo.bottom (bottom edge of dest node)
      const srcY = srcInfo.top;      // Top edge of source node (which is at bottom of screen)
      const dstY = dstInfo.bottom;   // Bottom edge of dest node (which is at top of screen)
      const dy = srcY - dstY;        // srcY > dstY, so this is positive
      if (!(dy > 1.0)) return;

      // Handle length: no fixed 10px minimum; clamp by dy to avoid loops when zoomed out
      const base = dy * 0.40;
      const handle = Math.max(1.0, Math.min(base, dy * 0.45));

      // Scale all coordinates to physical pixels for WebGPU
      // Ribbon flows from bottom (srcY, larger) to top (dstY, smaller)
      const leftP0 = [sLeft * devicePixelRatio, srcY * devicePixelRatio];
      const leftP3 = [dLeft * devicePixelRatio, dstY * devicePixelRatio];
      const rightP0 = [sRight * devicePixelRatio, srcY * devicePixelRatio];
      const rightP3 = [dRight * devicePixelRatio, dstY * devicePixelRatio];

      // Vertical tangents at endpoints (flowing upward: srcY decreases toward dstY)
      const leftP1 = [sLeft * devicePixelRatio, (srcY - handle) * devicePixelRatio];
      const leftP2 = [dLeft * devicePixelRatio, (dstY + handle) * devicePixelRatio];
      const rightP1 = [sRight * devicePixelRatio, (srcY - handle) * devicePixelRatio];
      const rightP2 = [dRight * devicePixelRatio, (dstY + handle) * devicePixelRatio];

      // Parse color string to RGBA floats (expects "rgba(r,g,b,a)" or similar)
      const m = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      let rgba = [0.47, 0.71, 1.0, 0.20];
      if (m) {
        rgba = [parseInt(m[1])/255, parseInt(m[2])/255, parseInt(m[3])/255, m[4] !== undefined ? parseFloat(m[4]) : 1.0];
      }

      if (webgpuSupported && flowRibbonRenderer) {
        // For vertical ribbons, we pass left/right edges as top/bottom edges to the renderer
        flowRibbonRenderer.addRibbon(leftP0, leftP1, leftP2, leftP3, rightP0, rightP1, rightP2, rightP3, rgba);
        return;
      }

      // Fallback (optional): if you want, keep your old Canvas2D path here.
    };

    // Helper function to parse rgba string and convert to hex for WebGPU
    function rgbaToHex(rgbaStr) {
      const match = rgbaStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      if (match) {
        const r = parseInt(match[1]);
        const g = parseInt(match[2]);
        const b = parseInt(match[3]);
        return (r << 16) | (g << 8) | b;
      }
      // Fallback to blue if parsing fails
      return 0x78B4FF;
    }

    // background
    ctx.fillStyle = "rgba(127,127,127,0.035)";
    ctx.fillRect(0,0,W,H);

    // connectors (diagonal lines - make them meet the ruler variant position precisely)
    const win = visibleVariantWindow();
    
    // Use WebGPU for variant columns if available, otherwise fall back to Canvas 2D
    // Use flowWebGPU instead of tracksWebGPU for variant columns
    const useWebGPU = webgpuSupported && flowInstancedRenderer;
    const devicePixelRatio = window.devicePixelRatio || 1;
    const blueHex = rgbaToHex(colBlue);
    const grayHex = rgbaToHex(colGray);
    
    if (isVertical) {
      // In vertical mode, sort variants by position for consistent ordering
      const sortedWin = [...win].sort((a, b) => a.pos - b.pos);
      
      // columns (horizontal lines in vertical mode) - shortened to end near where allele nodes start
      // Calculate where allele nodes start (left + margin + horizontal offset)
      const left = 70;
      const marginPercent = 0.1;
      const minMargin = 10;
      const flowLayoutForStems = layout.find(l => l.track.id === "flow");
      const trackWidth = flowLayoutForStems ? flowLayoutForStems.contentWidth : 300;
      const margin = Math.max(minMargin, trackWidth * marginPercent);
      // Estimate where nodes start - use a reasonable default if we can't calculate exactly
      const nodeStartX = left + margin + 20; // Add some buffer for centering offset
      const stemEndXFull = Math.min(nodeStartX + 30, W - 18); // End stem 30px after nodes start, but don't go past right edge
      // Reduce stem length by half
      const stemEndX = junctionX + (stemEndXFull - junctionX) / 2;
      
      if (useWebGPU) {
        for (let i=0;i<sortedWin.length;i++) {
          const v = sortedWin[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          const color = isHovered ? blueHex : grayHex;
          const alpha = isHovered ? 0.7 : 0.5;
          // Position column based on mode
          const y = variantMode === "genomic" 
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          const yScaled = y * devicePixelRatio;
          flowInstancedRenderer.addLine(
            junctionX * devicePixelRatio, yScaled,
            stemEndX * devicePixelRatio, yScaled,
            color, alpha
          );
        }
      } else {
        for (let i=0;i<sortedWin.length;i++) {
          const v = sortedWin[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          ctx.strokeStyle = isHovered ? colBlue : colGray;
          ctx.globalAlpha = isHovered ? 0.7 : 0.5;
          ctx.lineWidth = isHovered ? 2.5 : 1;
          // Position column based on mode
          const y = variantMode === "genomic" 
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          ctx.beginPath();
          ctx.moveTo(junctionX, y);
          ctx.lineTo(stemEndX, y);
          ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
      }

      // Text labels (still use Canvas 2D for text)
      // Group variants by position to handle multiple variants at same position
      const variantsByPos = new Map();
      for (const v of sortedWin) {
        const pos = v.pos;
        if (!variantsByPos.has(pos)) {
          variantsByPos.set(pos, []);
        }
        variantsByPos.get(pos).push(v);
      }
      
      // Helper function to draw multi-line text (for variants at same position)
      const drawMultiLineText = (text, x, y, lineHeight = 12) => {
        const lines = text.split('\n');
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], x, y + i * lineHeight);
        }
      };
      
      // Calculate if we have enough space to show all labels
      // In vertical mode, labels are rotated 90 degrees, so text width becomes vertical height
      ctx.font = "12px ui-sans-serif, system-ui";
      const uniquePositions = Array.from(variantsByPos.keys()).sort((a, b) => a - b);
      const maxLabelWidth = Math.max(...uniquePositions.map(pos => {
        const idsAtPos = variantsByPos.get(pos).map(v => v.id).join('\n');
        return ctx.measureText(idsAtPos).width;
      }), 30);
      // When rotated, the label takes up maxLabelWidth pixels vertically
      // We need spacing between labels, so add some padding
      const minSpacing = maxLabelWidth + 10; // minimum pixels between label centers
      
      // Check spacing between consecutive variant positions
      // For genomic mode, check actual Y positions; for equidistant, use calculated spacing
      let hasEnoughSpace = uniquePositions.length === 0;
      if (uniquePositions.length > 0) {
        if (variantMode === "genomic") {
          // In genomic mode, check minimum spacing between actual positions
          const positions = uniquePositions.map(pos => yGenomeCanonical(pos, H)).sort((a, b) => a - b);
          let minActualSpacing = Infinity;
          for (let i = 1; i < positions.length; i++) {
            const spacing = positions[i] - positions[i - 1];
            if (spacing < minActualSpacing) {
              minActualSpacing = spacing;
            }
          }
          hasEnoughSpace = minActualSpacing >= minSpacing;
        } else {
          // In equidistant mode, calculate spacing
          const avgSpacing = H / uniquePositions.length;
          hasEnoughSpace = avgSpacing >= minSpacing;
        }
      }
      
      // Store variant label positions for hit testing
      const variantLabelPositions = [];
      
      ctx.fillStyle = colText;
      // Iterate over unique positions
      for (let posIdx = 0; posIdx < uniquePositions.length; posIdx++) {
        const pos = uniquePositions[posIdx];
        const variantsAtPos = variantsByPos.get(pos);
        const firstVariant = variantsAtPos[0];
        const variantIdx = variants.findIndex(v2 => v2.id === firstVariant.id);
        
        // Calculate Y position for this position
        // For equidistant mode, use the position index (not variant index) so variants at same position overlap
        let y;
        if (variantMode === "genomic") {
          y = yGenomeCanonical(pos, H);
        } else {
          // Use position index so all variants at same position get same Y coordinate
          y = yColumn(posIdx, uniquePositions.length);
        }
        
        // Determine if we should show this label
        const isHovered = variantsAtPos.some(v => state.hoveredVariantIndex === variants.findIndex(v2 => v2.id === v.id));
        const isPinned = variantsAtPos.some(v => state.pinnedVariantLabels.has(v.id));
        const shouldShow = isHovered || isPinned || hasEnoughSpace;
        
        if (shouldShow) {
          // Show first ID (or count if multiple)
          const displayText = variantsAtPos.length > 1 
            ? `${variantsAtPos[0].id} (+${variantsAtPos.length - 1})`
            : variantsAtPos[0].id;
          
          ctx.save();
          ctx.translate(14, y + 6);
          ctx.rotate(-Math.PI/2);
          ctx.fillText(displayText, 0, 0);
          ctx.restore();
        }
        
        // Store position for hit testing (for click-to-pin and tooltip) - one entry per position
        const firstVariantIdx = variants.findIndex(v2 => v2.id === firstVariant.id);
        const displayText = variantsAtPos.length > 1 
          ? `${variantsAtPos[0].id} (+${variantsAtPos.length - 1})`
          : variantsAtPos[0].id;
        const labelWidth = ctx.measureText(displayText).width;
        const labelIds = (firstVariant.displayIds && firstVariant.displayIds.length > 0)
          ? firstVariant.displayIds
          : [firstVariant.id];
        variantLabelPositions.push({
          variantId: firstVariant.id, // Use first variant ID for compatibility
          variantIdx: firstVariantIdx,
          x: 14,
          y: y,
          width: labelWidth, // When rotated, this is the vertical extent
          height: labelWidth, // Same as width when rotated
          allIds: labelIds, // Store all IDs for tooltip
          position: pos
        });
      }
      
      // Store positions globally for click detection
      window._variantLabelPositions = variantLabelPositions;

      // Connector lines from ruler to columns
      const x0 = 6;
      if (useWebGPU) {
        for (let i=0; i<sortedWin.length; i++) {
          const v = sortedWin[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          const color = isHovered ? blueHex : grayHex;
          const alpha = isHovered ? 0.7 : 0.5;
          const vy = yGenomeCanonical(v.pos, H); // always use genomic position for ruler connection
          const cy = variantMode === "genomic"
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          flowInstancedRenderer.addLine(
            x0 * devicePixelRatio, vy * devicePixelRatio,
            junctionX * devicePixelRatio, cy * devicePixelRatio,
            color, alpha
          );
        }
      } else {
        for (let i=0; i<sortedWin.length; i++) {
          const v = sortedWin[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          ctx.strokeStyle = isHovered ? colBlue : colGray;
          ctx.globalAlpha = isHovered ? 0.7 : 0.5;
          ctx.lineWidth = isHovered ? 2.5 : 1;
          const vy = yGenomeCanonical(v.pos, H);
          const cy = variantMode === "genomic"
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          ctx.beginPath();
          ctx.moveTo(x0, vy);
          ctx.lineTo(junctionX, cy);
          ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
      }
    } else {
      // columns (vertical lines) - shortened to end near where allele nodes start
      // Calculate where allele nodes start (top + margin + vertical offset)
      const top = 0;
      const marginPercent = 0.1;
      const minMargin = 10;
      const flowLayoutForStems = layout.find(l => l.track.id === "flow");
      const trackHeight = flowLayoutForStems ? flowLayoutForStems.contentHeight : 300;
      const margin = Math.max(minMargin, trackHeight * marginPercent);
      // Estimate where nodes start - use a reasonable default if we can't calculate exactly
      const nodeStartY = top + margin + 20; // Add some buffer for centering offset
      const stemEndYFull = Math.min(nodeStartY + 30, H - 18); // End stem 30px after nodes start, but don't go past bottom
      // Reduce stem length by half
      const stemEndY = junctionY + (stemEndYFull - junctionY) / 2;
      
      if (useWebGPU) {
        for (let i=0;i<win.length;i++) {
          const v = win[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          const color = isHovered ? blueHex : grayHex;
          const alpha = isHovered ? 0.7 : 0.5;
          // Position column based on mode
          const x = variantMode === "genomic"
            ? xGenomeCanonical(v.pos, W)
            : xColumn(i, win.length);
          const xScaled = x * devicePixelRatio;
          flowInstancedRenderer.addLine(
            xScaled, junctionY * devicePixelRatio,
            xScaled, stemEndY * devicePixelRatio,
            color, alpha
          );
        }
      } else {
        for (let i=0;i<win.length;i++) {
          const v = win[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          ctx.strokeStyle = isHovered ? colBlue : colGray;
          ctx.globalAlpha = isHovered ? 0.7 : 0.5;
          ctx.lineWidth = isHovered ? 2.5 : 1;
          // Position column based on mode
          const x = variantMode === "genomic"
            ? xGenomeCanonical(v.pos, W)
            : xColumn(i, win.length);
          ctx.beginPath();
          ctx.moveTo(x, junctionY);
          ctx.lineTo(x, stemEndY);
          ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
      }

      // Text labels (still use Canvas 2D for text)
      // Group variants by position to handle multiple variants at same position
      const variantsByPos = new Map();
      for (const v of win) {
        const pos = v.pos;
        if (!variantsByPos.has(pos)) {
          variantsByPos.set(pos, []);
        }
        variantsByPos.get(pos).push(v);
      }
      
      // Helper function to draw multi-line text (for variants at same position)
      const drawMultiLineText = (text, x, y, lineHeight = 12) => {
        const lines = text.split('\n');
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], x, y + i * lineHeight);
        }
      };
      
      // Calculate if we have enough space to show all labels
      // Estimate label width (measure text to be more accurate)
      ctx.font = "12px ui-sans-serif, system-ui";
      const uniquePositions = Array.from(variantsByPos.keys()).sort((a, b) => a - b);
      const maxLabelWidth = Math.max(...uniquePositions.map(pos => {
        const idsAtPos = variantsByPos.get(pos).map(v => v.id).join('\n');
        return ctx.measureText(idsAtPos).width;
      }), 50);
      const minSpacing = maxLabelWidth + 20; // minimum pixels between labels
      const hasEnoughSpace = uniquePositions.length === 0 || (W / uniquePositions.length) >= minSpacing;
      
      // Store variant label positions for hit testing
      const variantLabelPositions = [];
      
      ctx.fillStyle = colText;
      // Iterate over unique positions
      for (let posIdx = 0; posIdx < uniquePositions.length; posIdx++) {
        const pos = uniquePositions[posIdx];
        const variantsAtPos = variantsByPos.get(pos);
        const firstVariant = variantsAtPos[0];
        const variantIdx = variants.findIndex(v2 => v2.id === firstVariant.id);
        
        // Calculate X position for this position
        // For equidistant mode, use the position index (not variant index) so variants at same position overlap
        let x;
        if (variantMode === "genomic") {
          x = xGenomeCanonical(pos, W);
        } else {
          // Use position index so all variants at same position get same X coordinate
          x = xColumn(posIdx, uniquePositions.length);
        }
        
        // Determine if we should show this label
        const isHovered = variantsAtPos.some(v => state.hoveredVariantIndex === variants.findIndex(v2 => v2.id === v.id));
        const isPinned = variantsAtPos.some(v => state.pinnedVariantLabels.has(v.id));
        const shouldShow = isHovered || isPinned || hasEnoughSpace;
        
        if (shouldShow) {
          // Show first ID (or count if multiple)
          const displayText = variantsAtPos.length > 1 
            ? `${variantsAtPos[0].id} (+${variantsAtPos.length - 1})`
            : variantsAtPos[0].id;
          ctx.fillText(displayText, x - 10, 14);
        }
        
        // Store position for hit testing (for click-to-pin and tooltip) - one entry per position
        const firstVariantIdx = variants.findIndex(v2 => v2.id === firstVariant.id);
        const displayText = variantsAtPos.length > 1 
          ? `${variantsAtPos[0].id} (+${variantsAtPos.length - 1})`
          : variantsAtPos[0].id;
        const labelWidth = ctx.measureText(displayText).width;
        const labelIds = (firstVariant.displayIds && firstVariant.displayIds.length > 0)
          ? firstVariant.displayIds
          : [firstVariant.id];
        variantLabelPositions.push({
          variantId: firstVariant.id, // Use first variant ID for compatibility
          variantIdx: firstVariantIdx,
          x: x - 10,
          y: 2, // Text baseline is at y=14, but text extends upward, so hit box starts at y=2
          width: labelWidth,
          height: 14, // Single line height
          allIds: labelIds, // Store all IDs for tooltip
          position: pos
        });
      }
      
      // Store positions globally for click detection
      window._variantLabelPositions = variantLabelPositions;

      // Connector lines from ruler to columns
      const y0 = 6;
      if (useWebGPU) {
        for (let i=0; i<win.length; i++) {
          const v = win[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          const color = isHovered ? blueHex : grayHex;
          const alpha = isHovered ? 0.7 : 0.5;
          const vx = xGenomeCanonical(v.pos, W);
          const cx = variantMode === "genomic"
            ? xGenomeCanonical(v.pos, W)
            : xColumn(i, win.length);
          flowInstancedRenderer.addLine(
            vx * devicePixelRatio, y0 * devicePixelRatio,
            cx * devicePixelRatio, junctionY * devicePixelRatio,
            color, alpha
          );
        }
      } else {
        for (let i=0; i<win.length; i++) {
          const v = win[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          ctx.strokeStyle = isHovered ? colBlue : colGray;
          ctx.globalAlpha = isHovered ? 0.7 : 0.5;
          ctx.lineWidth = isHovered ? 2.5 : 1;
          const vx = xGenomeCanonical(v.pos, W);
          const cx = variantMode === "genomic"
            ? xGenomeCanonical(v.pos, W)
            : xColumn(i, win.length);
          ctx.beginPath();
          ctx.moveTo(vx, y0);
          ctx.lineTo(cx, junctionY);
          ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
      }
    }

    // Helper function to format allele with length suffix
    // Make it globally accessible for drag handlers
    window.formatAlleleLabel = function formatAlleleLabel(allele) {
      if (!allele || allele === ".") {
        return ". (no-call)";
      }
      const length = allele.length;
      const lengthLabel = length === 1 ? "1 bp" : `${length} bp`;
      // Truncate to 50 bp and add "..." if longer
      const displayAllele = length > 50 ? allele.substring(0, 50) + "..." : allele;
      return `${displayAllele} (${lengthLabel})`;
    };
    
    // Helper function to extract allele string from formatted label
    function extractAlleleFromLabel(label) {
      // Label format is "ALLELE (X bp)" or ". (no-call)"
      if (label.startsWith(". (no-call)")) return ".";
      const match = label.match(/^(.+?)\s*\([^)]+\)$/);
      return match ? match[1] : label;
    }
    
    // Helper function to get node colors based on allele type
    function getAlleleNodeColors(label, variant, actualAllele, isDragging) {
      const noCallLabel = formatAlleleLabel(".");
      const opacity = 0.65; // Light translucency
      const opacityDragging = 0.85; // Slightly more opaque when dragging
      const currentOpacity = isDragging ? opacityDragging : opacity;
      
      let fillColor, strokeColor;
      
      if (label === noCallLabel) {
        // No-call allele: gray with translucency
        fillColor = `rgba(200,200,200,${currentOpacity})`;
        strokeColor = `rgba(200,200,200,${currentOpacity})`;
      } else {
        // Determine allele type based on variant context and length
        // Use actualAllele if provided (to avoid truncation issues), otherwise extract from label
        const allele = actualAllele || extractAlleleFromLabel(label);
        const refLen = variant.refAllele ? variant.refAllele.length : 0;
        const alleleLen = allele.length;
        
        // 1 bp alleles are always SNVs (blue), regardless of reference length
        if (alleleLen === 1) {
          fillColor = `rgba(100,150,255,${currentOpacity})`;
          strokeColor = `rgba(100,150,255,${currentOpacity})`;
        } else {
          // Determine variant type by comparing ref to alts
          let isDeletion = false;
          let isInsertion = false;
          
          if (variant.altAlleles && Array.isArray(variant.altAlleles) && variant.altAlleles.length > 0) {
            // Check if any alt is shorter than ref (deletion) or longer than ref (insertion)
            const hasShorterAlt = variant.altAlleles.some(alt => alt.length < refLen);
            const hasLongerAlt = variant.altAlleles.some(alt => alt.length > refLen);
            
            if (hasShorterAlt && !hasLongerAlt) {
              isDeletion = true;
            } else if (hasLongerAlt && !hasShorterAlt) {
              isInsertion = true;
            }
          }
          
          // Color based on variant type and allele length
          if (isDeletion) {
            // In deletion variants, longer alleles are deletions (yellow)
            // Shorter alleles (if > 1 bp) would also be deletions, but 1 bp is already handled above
            const maxDiff = 100;
            const normalizedDiff = Math.min((alleleLen - 1) / maxDiff, 1.0); // Compare to 1 bp minimum
            const lightness = 70 - (normalizedDiff * 40); // 70% to 30%
            fillColor = `hsla(60, 80%, ${lightness}%, ${currentOpacity})`;
            strokeColor = `hsla(60, 80%, ${lightness}%, ${currentOpacity})`;
          } else if (isInsertion) {
            // In insertion variants, longer alleles are insertions (purple)
            const lengthDiff = alleleLen - refLen;
            const maxDiff = 100;
            const normalizedDiff = Math.min(lengthDiff / maxDiff, 1.0);
            const lightness = 70 - (normalizedDiff * 40); // 70% to 30%
            fillColor = `hsla(280, 70%, ${lightness}%, ${currentOpacity})`;
            strokeColor = `hsla(280, 70%, ${lightness}%, ${currentOpacity})`;
          } else {
            // SNV or substitution (same length): blue
            fillColor = `rgba(100,150,255,${currentOpacity})`;
            strokeColor = `rgba(100,150,255,${currentOpacity})`;
          }
        }
      }
      
      return { fillColor, strokeColor };
    }
    
    // Helper function to calculate allele node sizes based on frequencies
    // Make it globally accessible for drag handlers
    window.calculateAlleleSizes = function calculateAlleleSizes(variant, totalSpace, minSize, gap, numAlleles) {
      const alleleFrequencies = variant.alleleFrequencies || {};
      
      // Add margins to make the display more comfortable
      // Use 10% margin on each side (20% total), with a minimum of 20 pixels total
      const marginPercent = 0.1;
      const minMargin = 10;
      const margin = Math.max(minMargin, totalSpace * marginPercent);
      const availableSpace = totalSpace - (2 * margin);
      
      // If no frequencies available, return equal sizes
      if (!alleleFrequencies || Object.keys(alleleFrequencies).length === 0) {
        const equalSize = Math.max(minSize, (availableSpace - (numAlleles - 1) * gap) / numAlleles);
        const sizes = {};
        const labels = [formatAlleleLabel(".")];
        if (variant.refAllele) {
          labels.push(formatAlleleLabel(variant.refAllele));
        }
        if (variant.altAlleles && Array.isArray(variant.altAlleles)) {
          for (let k = 0; k < variant.altAlleles.length; k++) {
            labels.push(formatAlleleLabel(variant.altAlleles[k]));
          }
        }
        for (const label of labels) {
          // Map label to allele key
          const noCallLabel = formatAlleleLabel(".");
          const refLabel = variant.refAllele ? formatAlleleLabel(variant.refAllele) : null;
          let key = ".";
          if (label === noCallLabel) {
            key = ".";
          } else if (label === refLabel) {
            key = "ref";
          } else {
            // Find which alt allele this is
            if (variant.altAlleles && Array.isArray(variant.altAlleles)) {
              const altIndex = variant.altAlleles.findIndex(alt => formatAlleleLabel(alt) === label);
              if (altIndex >= 0) {
                key = `a${altIndex + 1}`;
              }
            }
          }
          sizes[key] = equalSize;
        }
        return sizes;
      }
      
      // Calculate total minimum size needed
      const totalMinSize = numAlleles * minSize;
      const totalGapSize = (numAlleles - 1) * gap;
      const remainingSpace = availableSpace - totalMinSize - totalGapSize;
      
      if (remainingSpace < 0) {
        // Edge case: minimum sizes exceed available space
        // Just use minimum sizes
        const sizes = {};
        for (const key of Object.keys(alleleFrequencies)) {
          sizes[key] = minSize;
        }
        return sizes;
      }
      
      // Redistribute remaining space proportionally
      const finalSizes = {};
      for (const [allele, freq] of Object.entries(alleleFrequencies)) {
        const proportional = freq * remainingSpace;
        finalSizes[allele] = minSize + proportional;
      }
      
      return finalSizes;
    }
    
    // Get track dimensions for sizing (reuse flowLayout from earlier in function)
    const flowLayoutForSizing = layout.find(l => l.track.id === "flow");
    const trackDimension = isVertical 
      ? (flowLayoutForSizing ? flowLayoutForSizing.contentWidth : 300)
      : (flowLayoutForSizing ? flowLayoutForSizing.contentHeight : 300);
    
    // Allele nodes with drag-and-drop support
    // Define constants at function scope so they're accessible in nested functions
    const baseNodeW = 4, baseNodeH = 14, gap = 8;
    const MIN_NODE_SIZE = 4;
    
    // Make constants available globally for drag handlers
    window._alleleNodeConstants = { baseNodeW, baseNodeH, gap, MIN_NODE_SIZE };
    const nodePositions = []; // Store positions for hit testing: [{ variantId, alleleIndex, x, y, w, h }]
    
    // Store node info for ribbon drawing: Map<variantIndex, Map<alleleLabel, {x, y, w, h, top, bottom, left, right}>>
    const nodeInfoByVariant = new Map();
    
    // Collect all labels to draw at the very end (after all nodes and indicators)
    const allLabelsToDraw = [];
    
    if (isVertical) {
      const sortedWin = [...win].sort((a, b) => a.pos - b.pos);
      const left = 70;
      
      // Calculate margin for allele nodes (same as in calculateAlleleSizes)
      const marginPercent = 0.1;
      const minMargin = 10;
      const margin = Math.max(minMargin, trackDimension * marginPercent);
      
      for (let i=0;i<sortedWin.length;i++){
        const v = sortedWin[i];
        const variantIdx = variants.findIndex(v2 => v2.id === v.id);
        
        // Get allele labels with actual alleles: ['.', refAllele, altAllele1, altAllele2, ...]
        // Deduplicate alleles to avoid showing the same allele twice (e.g., when ref == alt)
        const uniqueAlleles = new Set();
        uniqueAlleles.add("."); // no-call allele
        if (v.refAllele) {
          uniqueAlleles.add(v.refAllele);
        }
        if (v.altAlleles && Array.isArray(v.altAlleles)) {
          for (let k = 0; k < v.altAlleles.length; k++) {
            uniqueAlleles.add(v.altAlleles[k]);
          }
        }
        // Convert to formatted labels array and create mapping from label to actual allele
        const labelToAllele = new Map();
        let labels = Array.from(uniqueAlleles).map(allele => {
          const label = formatAlleleLabel(allele);
          labelToAllele.set(label, allele);
          return label;
        });
        
        // Get order from state, or use default
        let order = state.variantAlleleOrder.get(v.id);
        if (!order || order.length !== labels.length) {
          order = [...labels];
          state.variantAlleleOrder.set(v.id, order);
        }
        
        // Calculate allele sizes based on frequencies
        const alleleSizes = calculateAlleleSizes(v, trackDimension, MIN_NODE_SIZE, gap, order.length);
        
        // Map labels to allele keys for size lookup
        const noCallLabel = formatAlleleLabel(".");
        const refLabel = v.refAllele ? formatAlleleLabel(v.refAllele) : null;
        function getAlleleKey(label) {
          if (label === noCallLabel) return ".";
          if (label === refLabel) return "ref";
          if (v.altAlleles && Array.isArray(v.altAlleles)) {
            const altIndex = v.altAlleles.findIndex(alt => formatAlleleLabel(alt) === label);
            if (altIndex >= 0) return `a${altIndex + 1}`;
          }
          return "."; // fallback
        }
        
        // Position based on variant layout mode
        const cy = variantMode === "genomic"
          ? yGenomeCanonical(v.pos, H)
          : yColumn(i, sortedWin.length);
        
        // Calculate total width of all nodes plus gaps
        let totalNodesWidth = 0;
        for (let j = 0; j < order.length; j++) {
          const label = order[j];
          const alleleKey = getAlleleKey(label);
          const nodeW = alleleSizes[alleleKey] || baseNodeW;
          totalNodesWidth += nodeW;
          if (j < order.length - 1) {
            totalNodesWidth += gap;
          }
        }
        
        // Center the nodes horizontally within the actual available space
        // Account for left offset and right margin to ensure nodes don't extend beyond track boundaries
        const availableWidth = W - left - margin;
        const horizontalOffset = Math.max(0, (availableWidth - totalNodesWidth) / 2);
        
        // Calculate cumulative positions for variable-width nodes, starting with left + horizontal offset
        let currentX = left + horizontalOffset;
        
        // Check if this variant column is hovered
        const isVariantHovered = state.hoveredVariantIndex === variantIdx;
        
        // Draw nodes in current order
        for (let j=0;j<order.length;j++){
          const label = order[j];
          const alleleKey = getAlleleKey(label);
          let nodeW = alleleSizes[alleleKey] || baseNodeW;
          let nodeH = baseNodeW;
          
          // Increase width when variant is hovered (vertical mode = horizontal nodes)
          if (isVariantHovered) {
            nodeH += 2;
          }
          
          const x = currentX;
          
          // Check if this node is being dragged
          const isDragging = state.alleleDragState && 
            state.alleleDragState.variantId === v.id && 
            state.alleleDragState.alleleIndex === order.indexOf(label);
          const dragOffsetX = isDragging ? state.alleleDragState.offsetX : 0;
          const dragOffsetY = isDragging ? state.alleleDragState.offsetY : 0;
          
          const nodeX = x + dragOffsetX;
          const nodeY = cy - nodeH/2 + dragOffsetY;

          // Get colors based on allele type (use actual allele from map, not extracted from label)
          const actualAllele = labelToAllele.get(label) || extractAlleleFromLabel(label);
          const colors = getAlleleNodeColors(label, v, actualAllele, isDragging);
          ctx.fillStyle = colors.fillColor;
          ctx.strokeStyle = colors.strokeColor;
          ctx.lineWidth = isDragging ? 2 : 1;
          ctx.beginPath();
          roundRect(ctx, nodeX, nodeY, nodeW, nodeH, 5);
          ctx.fill();
          ctx.stroke();

          // Store label info for drawing after all nodes
          const labelKey = `${v.id}:${order.indexOf(label)}`;
          const isHovered = state.hoveredAlleleNode && 
            state.hoveredAlleleNode.variantId === v.id && 
            state.hoveredAlleleNode.alleleIndex === order.indexOf(label);
          const isPinned = state.pinnedAlleleLabels.has(labelKey);
          
          if (isHovered || isPinned) {
            allLabelsToDraw.push({
              label: label,
              nodeX: nodeX,
              nodeY: nodeY,
              nodeW: nodeW,
              nodeH: nodeH,
              isVertical: true
            });
          }
          
          // Store position for hit testing
          nodePositions.push({
            variantId: v.id,
            alleleIndex: order.indexOf(label),
            label: label,
            x: nodeX,
            y: nodeY,
            w: nodeW,
            h: nodeH
          });
          
          // Store node info for ribbon drawing
          if (!nodeInfoByVariant.has(i)) {
            nodeInfoByVariant.set(i, new Map());
          }
          nodeInfoByVariant.get(i).set(label, {
            x: nodeX,
            y: nodeY,
            w: nodeW,
            h: nodeH,
            top: nodeY,
            bottom: nodeY + nodeH,
            left: nodeX,
            right: nodeX + nodeW
          });
          
          // Update position for next node
          currentX += nodeW + gap;
        }
        
        // Draw drop indicator if dragging this variant
        if (state.alleleDragState && state.alleleDragState.variantId === v.id && 
            state.alleleDragState.dropIndex !== null && state.alleleDragState.dropIndex !== undefined) {
          const dropIdx = state.alleleDragState.dropIndex;
          const currentIdx = order.indexOf(state.alleleDragState.label);
          
          // Only show indicator if dropping at a different position
          if (dropIdx !== currentIdx) {
            // Calculate drop position accounting for variable node widths, margin, and centering
            // Recalculate total width and horizontal offset (same as above)
            let totalNodesWidth = 0;
            for (let k = 0; k < order.length; k++) {
              const label = order[k];
              const alleleKey = getAlleleKey(label);
              const nodeW = alleleSizes[alleleKey] || baseNodeW;
              totalNodesWidth += nodeW;
              if (k < order.length - 1) {
                totalNodesWidth += gap;
              }
            }
            const availableWidth = W - left - margin;
            const horizontalOffset = Math.max(0, (availableWidth - totalNodesWidth) / 2);
            
            let indicatorX = left + horizontalOffset;
            for (let k = 0; k < dropIdx; k++) {
              const label = order[k];
              const alleleKey = getAlleleKey(label);
              const nodeW = alleleSizes[alleleKey] || baseNodeW;
              indicatorX += nodeW + gap;
            }
            // For the last position, draw after the last node
            if (dropIdx === order.length - 1) {
              const label = order[dropIdx];
              const alleleKey = getAlleleKey(label);
              const nodeW = alleleSizes[alleleKey] || baseNodeW;
              indicatorX += nodeW;
            }
            ctx.strokeStyle = "rgba(120, 180, 255, 0.8)"; // Use accent blue color
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(indicatorX, cy - baseNodeH/2 - 4);
            ctx.lineTo(indicatorX, cy + baseNodeH/2 + 4);
            ctx.stroke();
          }
        }
      }
    } else {
      for (let i=0;i<win.length;i++){
        const v = win[i];
        const variantIdx = variants.findIndex(v2 => v2.id === v.id);
        
        // Get allele labels with actual alleles: ['.', refAllele, altAllele1, altAllele2, ...]
        // Deduplicate alleles to avoid showing the same allele twice (e.g., when ref == alt)
        const uniqueAlleles = new Set();
        uniqueAlleles.add("."); // no-call allele
        if (v.refAllele) {
          uniqueAlleles.add(v.refAllele);
        }
        if (v.altAlleles && Array.isArray(v.altAlleles)) {
          for (let k = 0; k < v.altAlleles.length; k++) {
            uniqueAlleles.add(v.altAlleles[k]);
          }
        }
        // Convert to formatted labels array and create mapping from label to actual allele
        const labelToAllele = new Map();
        let labels = Array.from(uniqueAlleles).map(allele => {
          const label = formatAlleleLabel(allele);
          labelToAllele.set(label, allele);
          return label;
        });
        
        // Get order from state, or use default
        let order = state.variantAlleleOrder.get(v.id);
        if (!order || order.length !== labels.length) {
          order = [...labels];
          state.variantAlleleOrder.set(v.id, order);
        }
        
        // Calculate allele sizes based on frequencies
        const alleleSizes = calculateAlleleSizes(v, trackDimension, MIN_NODE_SIZE, gap, order.length);
        
        // Map labels to allele keys for size lookup
        const noCallLabel = formatAlleleLabel(".");
        const refLabel = v.refAllele ? formatAlleleLabel(v.refAllele) : null;
        function getAlleleKey(label) {
          if (label === noCallLabel) return ".";
          if (label === refLabel) return "ref";
          if (v.altAlleles && Array.isArray(v.altAlleles)) {
            const altIndex = v.altAlleles.findIndex(alt => formatAlleleLabel(alt) === label);
            if (altIndex >= 0) return `a${altIndex + 1}`;
          }
          return "."; // fallback
        }
        
        // Position based on variant layout mode
        const cx = variantMode === "genomic"
          ? xGenomeCanonical(win[i].pos, W)
          : xColumn(i, win.length);
        const top = 20;

        // Calculate margin for allele nodes (same as in calculateAlleleSizes)
        const marginPercent = 0.1;
        const minMargin = 10;
        const margin = Math.max(minMargin, trackDimension * marginPercent);
        
        // Calculate total height of all nodes plus gaps
        let totalNodesHeight = 0;
        for (let j = 0; j < order.length; j++) {
          const label = order[j];
          const alleleKey = getAlleleKey(label);
          const nodeH = alleleSizes[alleleKey] || baseNodeH;
          totalNodesHeight += nodeH;
          if (j < order.length - 1) {
            totalNodesHeight += gap;
          }
        }
        
        // Center the nodes vertically within the actual available space
        // Account for top offset and bottom margin to ensure nodes don't extend beyond track boundaries
        const availableHeight = H - top - margin;
        const verticalOffset = Math.max(0, (availableHeight - totalNodesHeight) / 2);

        // Calculate cumulative positions for variable-height nodes, starting with top + vertical offset
        let currentY = top + verticalOffset;

        // Check if this variant column is hovered
        const isVariantHovered = state.hoveredVariantIndex === variantIdx;
        
        // Draw nodes in current order
        for (let j=0;j<order.length;j++){
          const label = order[j];
          const alleleKey = getAlleleKey(label);
          let nodeW = baseNodeW;
          let nodeH = alleleSizes[alleleKey] || baseNodeH;
          
          // Increase height when variant is hovered (horizontal mode = vertical nodes)
          if (isVariantHovered) {
            nodeW += 2;
          }
          
          const y = currentY;
          
          // Check if this node is being dragged
          const isDragging = state.alleleDragState && 
            state.alleleDragState.variantId === v.id && 
            state.alleleDragState.alleleIndex === order.indexOf(label);
          const dragOffsetX = isDragging ? state.alleleDragState.offsetX : 0;
          const dragOffsetY = isDragging ? state.alleleDragState.offsetY : 0;
          
          const nodeX = cx - nodeW/2 + dragOffsetX;
          const nodeY = y + dragOffsetY;

          // Get colors based on allele type (use actual allele from map, not extracted from label)
          const actualAllele = labelToAllele.get(label) || extractAlleleFromLabel(label);
          const colors = getAlleleNodeColors(label, v, actualAllele, isDragging);
          ctx.fillStyle = colors.fillColor;
          ctx.strokeStyle = colors.strokeColor;
          ctx.lineWidth = isDragging ? 2 : 1;
          ctx.beginPath();
          roundRect(ctx, nodeX, nodeY, nodeW, nodeH, 5);
          ctx.fill();
          ctx.stroke();

          // Store label info for drawing after all nodes
          const labelKey = `${v.id}:${order.indexOf(label)}`;
          const isHovered = state.hoveredAlleleNode && 
            state.hoveredAlleleNode.variantId === v.id && 
            state.hoveredAlleleNode.alleleIndex === order.indexOf(label);
          const isPinned = state.pinnedAlleleLabels.has(labelKey);
          
          if (isHovered || isPinned) {
            allLabelsToDraw.push({
              label: label,
              nodeX: nodeX,
              nodeY: nodeY,
              nodeW: nodeW,
              nodeH: nodeH,
              isVertical: false
            });
          }
          
          // Store position for hit testing
          nodePositions.push({
            variantId: v.id,
            alleleIndex: order.indexOf(label),
            label: label,
            x: nodeX,
            y: nodeY,
            w: nodeW,
            h: nodeH
          });
          
          // Store node info for ribbon drawing
          if (!nodeInfoByVariant.has(i)) {
            nodeInfoByVariant.set(i, new Map());
          }
          nodeInfoByVariant.get(i).set(label, {
            x: nodeX,
            y: nodeY,
            w: nodeW,
            h: nodeH,
            top: nodeY,
            bottom: nodeY + nodeH,
            left: nodeX,
            right: nodeX + nodeW
          });
          
          // Update position for next node
          currentY += nodeH + gap;
        }
        
        // Draw drop indicator if dragging this variant
        if (state.alleleDragState && state.alleleDragState.variantId === v.id && 
            state.alleleDragState.dropIndex !== null && state.alleleDragState.dropIndex !== undefined) {
          const dropIdx = state.alleleDragState.dropIndex;
          const currentIdx = order.indexOf(state.alleleDragState.label);
          
          // Only show indicator if dropping at a different position
          if (dropIdx !== currentIdx) {
            // Calculate drop position accounting for variable node heights, margin, and centering
            // Recalculate total height and vertical offset (same as above)
            let totalNodesHeight = 0;
            for (let k = 0; k < order.length; k++) {
              const label = order[k];
              const alleleKey = getAlleleKey(label);
              const nodeH = alleleSizes[alleleKey] || baseNodeH;
              totalNodesHeight += nodeH;
              if (k < order.length - 1) {
                totalNodesHeight += gap;
              }
            }
            const availableHeight = H - top - margin;
            const verticalOffset = Math.max(0, (availableHeight - totalNodesHeight) / 2);
            
            let indicatorY = top + verticalOffset;
            for (let k = 0; k < dropIdx; k++) {
              const label = order[k];
              const alleleKey = getAlleleKey(label);
              const nodeH = alleleSizes[alleleKey] || baseNodeH;
              indicatorY += nodeH + gap;
            }
            // For the last position, draw after the last node
            if (dropIdx === order.length - 1) {
              const label = order[dropIdx];
              const alleleKey = getAlleleKey(label);
              const nodeH = alleleSizes[alleleKey] || baseNodeH;
              indicatorY += nodeH;
            }
            ctx.strokeStyle = "rgba(120, 180, 255, 0.8)"; // Use accent blue color
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx - baseNodeW/2 - 4, indicatorY);
            ctx.lineTo(cx + baseNodeW/2 + 4, indicatorY);
            ctx.stroke();
          }
        }
      }
    }
    
    // Draw ribbons between alleles based on haplotype transitions (not matching labels)
    // For each pair of adjacent variants, we compute which alleles each sample has at both variants
    // and draw ribbons proportional to the number of haplotypes making each transition
    if (nodeInfoByVariant.size > 1) {
      const sortedVariantIdxs = Array.from(nodeInfoByVariant.keys()).sort((a, b) => a - b);
      
      // Get the actual variant list (sorted for vertical mode, original order for horizontal)
      const variantList = isVertical ? [...win].sort((a, b) => a.pos - b.pos) : win;
      
      for (let i = 0; i < sortedVariantIdxs.length - 1; i++) {
        const srcIdx = sortedVariantIdxs[i];
        const dstIdx = sortedVariantIdxs[i + 1];
        const srcNodes = nodeInfoByVariant.get(srcIdx);
        const dstNodes = nodeInfoByVariant.get(dstIdx);
        
        if (!srcNodes || !dstNodes) continue;
        
        // Get the variant objects
        const srcVariant = variantList[srcIdx];
        const dstVariant = variantList[dstIdx];
        if (!srcVariant || !dstVariant) continue;
        
        // Helper to get allele label from genotype index for a variant
        function getAlleleLabelForIndex(variant, alleleIdx) {
          if (alleleIdx === null || alleleIdx === undefined || alleleIdx === "." || isNaN(alleleIdx)) {
            return formatAlleleLabel(".");
          }
          if (alleleIdx === 0) {
            // Reference allele
            return variant.refAllele ? formatAlleleLabel(variant.refAllele) : formatAlleleLabel(".");
          }
          // Alt allele (1-indexed in genotype, but 0-indexed in altAlleles array)
          if (variant.altAlleles && variant.altAlleles[alleleIdx - 1]) {
            return formatAlleleLabel(variant.altAlleles[alleleIdx - 1]);
          }
          return formatAlleleLabel(".");
        }
        
        // Helper to get actual allele string from label for a variant
        function getActualAlleleFromLabel(variant, label) {
          const noCallLabel = formatAlleleLabel(".");
          if (label === noCallLabel) return ".";
          if (variant.refAllele && label === formatAlleleLabel(variant.refAllele)) {
            return variant.refAllele;
          }
          if (variant.altAlleles && Array.isArray(variant.altAlleles)) {
            for (const alt of variant.altAlleles) {
              if (label === formatAlleleLabel(alt)) {
                return alt;
              }
            }
          }
          return ".";
        }
        
        // Compute transitions: Map<srcLabel, Map<dstLabel, count>>
        const transitions = new Map();
        const srcGenotypes = srcVariant.sampleGenotypes || {};
        const dstGenotypes = dstVariant.sampleGenotypes || {};
        
        // Get all samples that have genotype data at both variants
        const allSamples = new Set([...Object.keys(srcGenotypes), ...Object.keys(dstGenotypes)]);
        
        for (const sample of allSamples) {
          const srcGt = srcGenotypes[sample] || "./.";
          const dstGt = dstGenotypes[sample] || "./.";
          
          // Parse genotypes to get allele indices
          const srcAlleles = srcGt.replace("|", "/").split("/").map(a => {
            const trimmed = a.trim();
            return trimmed === "." || trimmed === "" ? null : parseInt(trimmed, 10);
          });
          const dstAlleles = dstGt.replace("|", "/").split("/").map(a => {
            const trimmed = a.trim();
            return trimmed === "." || trimmed === "" ? null : parseInt(trimmed, 10);
          });
          
          // For each haplotype (assuming diploid = 2 haplotypes per sample)
          const numHaplotypes = Math.min(srcAlleles.length, dstAlleles.length);
          for (let h = 0; h < numHaplotypes; h++) {
            const srcAlleleIdx = srcAlleles[h];
            const dstAlleleIdx = dstAlleles[h];
            
            const srcLabel = getAlleleLabelForIndex(srcVariant, srcAlleleIdx);
            const dstLabel = getAlleleLabelForIndex(dstVariant, dstAlleleIdx);
            
            if (!transitions.has(srcLabel)) {
              transitions.set(srcLabel, new Map());
            }
            const srcTransitions = transitions.get(srcLabel);
            srcTransitions.set(dstLabel, (srcTransitions.get(dstLabel) || 0) + 1);
          }
        }
        
        // If no transition data (no samples), fall back to connecting all src nodes to all dst nodes
        if (transitions.size === 0) {
          for (const [srcLabel, srcNode] of srcNodes) {
            for (const [dstLabel, dstNode] of dstNodes) {
              const actualAllele = getActualAlleleFromLabel(srcVariant, srcLabel);
              const colors = getAlleleNodeColors(srcLabel, srcVariant, actualAllele, false);
              const colorMatch = colors.fillColor.match(/rgba?\([^)]+,\s*([\d.]+)\)/);
              const alpha = colorMatch ? parseFloat(colorMatch[1]) : 0.65;
              const ribbonColor = colors.fillColor.replace(/[\d.]+\)$/, `${alpha * 0.3})`);
              
              if (isVertical) {
                // Draw thin connecting ribbon (vertical flow)
                const srcW = srcNode.right - srcNode.left;
                const dstW = dstNode.right - dstNode.left;
                const midSrc = srcNode.left + srcW / 2;
                const midDst = dstNode.left + dstW / 2;
                const thinW = Math.min(2, srcW * 0.1, dstW * 0.1);
                
                drawRibbonVertical(
                  srcNode, dstNode,
                  midSrc - thinW/2, midSrc + thinW/2,
                  midDst - thinW/2, midDst + thinW/2,
                  ribbonColor
                );
              } else {
                // Draw thin connecting ribbon (horizontal flow)
                const srcH = srcNode.bottom - srcNode.top;
                const dstH = dstNode.bottom - dstNode.top;
                const midSrc = srcNode.top + srcH / 2;
                const midDst = dstNode.top + dstH / 2;
                const thinH = Math.min(2, srcH * 0.1, dstH * 0.1);
                
                drawRibbon(
                  srcNode, dstNode,
                  midSrc - thinH/2, midSrc + thinH/2,
                  midDst - thinH/2, midDst + thinH/2,
                  ribbonColor
                );
              }
            }
          }
          continue;
        }
        
        // Calculate total outgoing count per source label and total incoming per dest label
        const srcTotals = new Map(); // srcLabel -> total outgoing haplotypes
        const dstTotals = new Map(); // dstLabel -> total incoming haplotypes
        let totalHaplotypes = 0; // Total haplotypes across all transitions
        
        for (const [srcLabel, dstMap] of transitions) {
          let total = 0;
          for (const [dstLabel, count] of dstMap) {
            total += count;
            totalHaplotypes += count;
            dstTotals.set(dstLabel, (dstTotals.get(dstLabel) || 0) + count);
          }
          srcTotals.set(srcLabel, total);
        }
        
        // Track current offset within each node for stacking ribbons
        // In horizontal mode: Y offset from top; in vertical mode: X offset from left
        const srcOffsets = new Map();
        const dstOffsets = new Map();
        
        // Get reference allele labels to identify background persistence flows
        const srcRefLabel = srcVariant.refAllele ? formatAlleleLabel(srcVariant.refAllele) : null;
        const dstRefLabel = dstVariant.refAllele ? formatAlleleLabel(dstVariant.refAllele) : null;
        
        // Collect all ribbon data first, then sort so reference flows draw first (background)
        const ribbonData = [];
        
        for (const [srcLabel, dstMap] of transitions) {
          const srcNode = srcNodes.get(srcLabel);
          if (!srcNode) continue;
          
          const srcTotal = srcTotals.get(srcLabel) || 1;
          
          for (const [dstLabel, count] of dstMap) {
            const dstNode = dstNodes.get(dstLabel);
            if (!dstNode) continue;
            
            const dstTotal = dstTotals.get(dstLabel) || 1;
            
            // Get current offsets (for stacking)
            const srcOffset = srcOffsets.get(srcLabel) || 0;
            const dstOffset = dstOffsets.get(dstLabel) || 0;
            
            let src0, src1, dst0, dst1;
            
            if (isVertical) {
              // Vertical mode: ribbons flow downward, width is along X axis
              const srcNodeW = srcNode.right - srcNode.left;
              const dstNodeW = dstNode.right - dstNode.left;
              
              // Calculate ribbon slice widths proportional to transition count
              const srcSliceW = (count / srcTotal) * srcNodeW;
              const dstSliceW = (count / dstTotal) * dstNodeW;
              
              // Calculate X positions
              src0 = srcNode.left + srcOffset;
              src1 = src0 + srcSliceW;
              dst0 = dstNode.left + dstOffset;
              dst1 = dst0 + dstSliceW;
              
              // Update offsets for next ribbon
              srcOffsets.set(srcLabel, srcOffset + srcSliceW);
              dstOffsets.set(dstLabel, dstOffset + dstSliceW);
            } else {
              // Horizontal mode: ribbons flow rightward, height is along Y axis
              const srcNodeH = srcNode.bottom - srcNode.top;
              const dstNodeH = dstNode.bottom - dstNode.top;
              
              // Calculate ribbon slice heights proportional to transition count
              const srcSliceH = (count / srcTotal) * srcNodeH;
              const dstSliceH = (count / dstTotal) * dstNodeH;
              
              // Calculate Y positions
              src0 = srcNode.top + srcOffset;
              src1 = src0 + srcSliceH;
              dst0 = dstNode.top + dstOffset;
              dst1 = dst0 + dstSliceH;
              
              // Update offsets for next ribbon
              srcOffsets.set(srcLabel, srcOffset + srcSliceH);
              dstOffsets.set(dstLabel, dstOffset + dstSliceH);
            }
            
            // Check if this is a reference-to-reference flow (background persistence)
            const isRefFlow = srcLabel === srcRefLabel && dstLabel === dstRefLabel;
            
            ribbonData.push({
              srcNode, dstNode, src0, src1, dst0, dst1,
              srcLabel, count, isRefFlow
            });
          }
        }
        
        // Sort ribbons: reference flows first (drawn in background), then colored flows on top
        ribbonData.sort((a, b) => (b.isRefFlow ? 1 : 0) - (a.isRefFlow ? 1 : 0));
        
        // Draw all ribbons with sqrt-scaled opacity
        for (const ribbon of ribbonData) {
          const { srcNode, dstNode, src0, src1, dst0, dst1, srcLabel, count, isRefFlow } = ribbon;
          
          // Get color from source allele
          const actualAllele = getActualAlleleFromLabel(srcVariant, srcLabel);
          const colors = getAlleleNodeColors(srcLabel, srcVariant, actualAllele, false);
          
          // Sqrt-scaled opacity: prevents dominant flows from drowning minor ones
          const frac = count / Math.max(1, totalHaplotypes);
          let alpha = 0.05 + 0.25 * Math.sqrt(frac);
          
          // De-emphasize reference flows further (lower saturation via reduced alpha)
          if (isRefFlow) {
            alpha *= 0.6; // 40% reduction for background persistence flows
          }
          
          const ribbonColor = colors.fillColor.replace(/[\d.]+\)$/, `${alpha.toFixed(3)})`);
          
          if (isVertical) {
            // Vertical mode: src0/src1/dst0/dst1 are X positions
            drawRibbonVertical(srcNode, dstNode, src0, src1, dst0, dst1, ribbonColor);
          } else {
            // Horizontal mode: src0/src1/dst0/dst1 are Y positions
            drawRibbon(srcNode, dstNode, src0, src1, dst0, dst1, ribbonColor);
          }
        }
      }
    }
    
    // Store node positions globally for hit testing
    window._alleleNodePositions = nodePositions;
    
    // Draw all labels at the very end with tooltip-style rounded rectangles (to bring them to foreground)
    ctx.font = "11px ui-monospace, 'SF Mono', Monaco, 'Consolas', 'Courier New', monospace";
    const labelPadding = 6;
    const labelBorderRadius = 4;
    const labelBgColor = "rgba(0, 0, 0, 0.85)";
    const labelBorderColor = "rgba(255, 255, 255, 0.2)";
    const labelTextColor = "rgba(255, 255, 255, 0.95)";
    
    for (const labelInfo of allLabelsToDraw) {
      const text = labelInfo.label;
      const textMetrics = ctx.measureText(text);
      const textWidth = textMetrics.width;
      const textHeight = 11; // font size
      
      if (labelInfo.isVertical) {
        // Vertical mode: rotated text
        const labelX = labelInfo.nodeX + labelInfo.nodeW/2 - gap - 5 + 12;
        const labelY = labelInfo.nodeY - 12;
        
        // Calculate dimensions for rotated tooltip
        const tooltipW = textHeight + labelPadding * 2;
        const tooltipH = textWidth + labelPadding * 2;
        const tooltipX = labelX - tooltipH / 2;
        const tooltipY = labelY - tooltipW / 2;
        
        ctx.save();
        ctx.translate(labelX, labelY);
        ctx.rotate(-Math.PI/2);
        
        // Draw tooltip background
        ctx.fillStyle = labelBgColor;
        ctx.strokeStyle = labelBorderColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        roundRect(ctx, -tooltipH/2, -tooltipW/2, tooltipH, tooltipW, labelBorderRadius);
        ctx.fill();
        ctx.stroke();
        
        // Draw text
        ctx.fillStyle = labelTextColor;
        ctx.fillText(text, -textWidth/2, textHeight/2 + 2);
        
        ctx.restore();
      } else {
        // Horizontal mode: normal text
        const labelX = labelInfo.nodeX + 12;
        const labelY = labelInfo.nodeY + 13;
        
        // Calculate dimensions for tooltip
        const tooltipW = textWidth + labelPadding * 2;
        const tooltipH = textHeight + labelPadding * 2;
        const tooltipX = labelX - labelPadding;
        const tooltipY = labelY - textHeight - labelPadding;
        
        // Draw tooltip background
        ctx.fillStyle = labelBgColor;
        ctx.strokeStyle = labelBorderColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        roundRect(ctx, tooltipX, tooltipY, tooltipW, tooltipH, labelBorderRadius);
        ctx.fill();
        ctx.stroke();
        
        // Draw text
        ctx.fillStyle = labelTextColor;
        ctx.fillText(text, labelX, labelY);
      }
    }

    // Execute WebGPU render pass after variant columns are added
    // Render to flowWebGPU canvas (separate from tracksWebGPU)
    const hasFlowInstances = flowInstancedRenderer && 
        (flowInstancedRenderer.rectInstances.length > 0 || flowInstancedRenderer.lineInstances.length > 0);
    const hasRibbonInstances = flowRibbonRenderer && flowRibbonRenderer.instances.length > 0;
    if (webgpuSupported && flowInstancedRenderer && (hasFlowInstances || hasRibbonInstances)) {
      try {
        // Update projection matrix for current canvas size
        const devicePixelRatio = window.devicePixelRatio || 1;
        const width = flowWebGPU.clientWidth * devicePixelRatio;
        const height = flowWebGPU.clientHeight * devicePixelRatio;
        
        if (flowWebGPU.width !== width || flowWebGPU.height !== height) {
          flowWebGPU.width = width;
          flowWebGPU.height = height;
          flowWebGPUCore.handleResize();
        }
        
        const encoder = flowWebGPUCore.createCommandEncoder();
        const texture = flowWebGPUCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear', // Clear canvas on each render
            storeOp: 'store',
          }],
        });
        
        if (flowRibbonRenderer) flowRibbonRenderer.render(encoder, renderPass);
        flowInstancedRenderer.render(encoder, renderPass);
        renderPass.end();
        flowWebGPUCore.submit([encoder.finish()]);
      } catch (error) {
        console.error("Flow WebGPU render error:", error);
        // Fallback: clear instances and continue with Canvas 2D only
        flowInstancedRenderer.clear();
      }
    } else if (webgpuSupported && flowInstancedRenderer) {
      // Clear WebGPU canvas if no instances to render
      try {
        const encoder = flowWebGPUCore.createCommandEncoder();
        const texture = flowWebGPUCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear',
            storeOp: 'store',
          }],
        });
        renderPass.end();
        flowWebGPUCore.submit([encoder.finish()]);
      } catch (error) {
        // Ignore errors when clearing
      }
    }
  }

  // -----------------------------
  // Reads placeholder (IGV-style area)
  // -----------------------------
  function renderReadsCanvas() {
    const layout = getTrackLayout();
    const readsLayout = layout.find(l => l.track.id === "reads");
    if (!readsLayout || readsLayout.track.collapsed) {
      return; // Don't render if collapsed
    }

    const dpr = resizeCanvasTo(reads, readsCanvas);
    const ctx = readsCanvas.getContext("2d");

    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,readsCanvas.width,readsCanvas.height);
    ctx.scale(dpr, dpr);

    const isVertical = isVerticalMode();
    const W = readsWidthPx(), H = readsHeightPx();
    const colText = cssVar("--muted");
    const grid = cssVar("--grid2");

    // soft background
    ctx.fillStyle = "rgba(127,127,127,0.02)";
    ctx.fillRect(0,0,W,H);

    if (isVertical) {
      // a few columns to suggest lanes (vertical mode)
      ctx.strokeStyle = grid;
      ctx.lineWidth = 1;
      const left = 8;
      const colW = 18;
      const cols = Math.floor((W - left - 12) / colW);
      for (let i=0; i<cols; i++) {
        const x = left + i*colW + colW/2;
        ctx.beginPath();
        ctx.moveTo(x, 16);
        ctx.lineTo(x, H-16);
        ctx.stroke();
      }

      // placeholder "reads" as rounded rects aligned in genome space
      function drawRead(bpStart, bpEnd, col, alpha=0.20) {
        const y1 = yGenomeCanonical(bpStart, H);
        const y2 = yGenomeCanonical(bpEnd, H);
        const x = left + col*colW + 2;
        const w = colW - 6;

        ctx.fillStyle = `rgba(120,180,255,${alpha})`;
        ctx.strokeStyle = `rgba(120,180,255,${alpha + 0.15})`;
        ctx.beginPath();
        roundRect(ctx, x, Math.min(y1, y2), w, Math.max(6, Math.abs(y2-y1)), 6);
        ctx.fill();
        ctx.stroke();
      }

      // a few fake reads
      drawRead(100_030, 100_160, 1, 0.10);
      drawRead(100_090, 100_240, 2, 0.12);
      drawRead(100_210, 100_420, 3, 0.10);
      drawRead(100_380, 100_610, 4, 0.11);
      drawRead(100_590, 100_820, 5, 0.10);
      drawRead(100_700, 100_900, 6, 0.11);

      // variant guide lines (gray, blue when hovered)
      for (let idx = 0; idx < variants.length; idx++) {
        const v = variants[idx];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        const isHovered = state.hoveredVariantIndex === idx;
        ctx.strokeStyle = isHovered ? cssVar("--blue") : "rgba(127,127,127,0.5)";
        ctx.globalAlpha = isHovered ? 0.7 : 0.5;
        ctx.lineWidth = isHovered ? 2.5 : 1;
        const y = yGenomeCanonical(v.pos, H);
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(W-10, y);
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
    } else {
      // a few rows to suggest lanes
      ctx.strokeStyle = grid;
      ctx.lineWidth = 1;
      const top = 8;
      const rowH = 18;
      const rows = Math.floor((H - top - 12) / rowH);
      for (let i=0; i<rows; i++) {
        const y = top + i*rowH + rowH/2;
        ctx.beginPath();
        ctx.moveTo(16, y);
        ctx.lineTo(W-16, y);
        ctx.stroke();
      }

      // placeholder "reads" as rounded rects aligned in genome space
      function drawRead(bpStart, bpEnd, row, alpha=0.20) {
        const x1 = xGenomeCanonical(bpStart, W);
        const x2 = xGenomeCanonical(bpEnd, W);
        const y = top + row*rowH + 2;
        const h = rowH - 6;

        ctx.fillStyle = `rgba(120,180,255,${alpha})`;
        ctx.strokeStyle = `rgba(120,180,255,${alpha + 0.15})`;
        ctx.beginPath();
        roundRect(ctx, x1, y, Math.max(6, x2-x1), h, 6);
        ctx.fill();
        ctx.stroke();
      }

      // a few fake reads
      drawRead(100_030, 100_160, 1, 0.10);
      drawRead(100_090, 100_240, 2, 0.12);
      drawRead(100_210, 100_420, 3, 0.10);
      drawRead(100_380, 100_610, 4, 0.11);
      drawRead(100_590, 100_820, 5, 0.10);
      drawRead(100_700, 100_900, 6, 0.11);

      // variant guide lines (gray, blue when hovered)
      for (let idx = 0; idx < variants.length; idx++) {
        const v = variants[idx];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        const isHovered = state.hoveredVariantIndex === idx;
        ctx.strokeStyle = isHovered ? cssVar("--blue") : "rgba(127,127,127,0.5)";
        ctx.globalAlpha = isHovered ? 0.7 : 0.5;
        ctx.lineWidth = isHovered ? 2.5 : 1;
        const x = xGenomeCanonical(v.pos, W);
        ctx.beginPath();
        ctx.moveTo(x, top);
        ctx.lineTo(x, H-10);
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
    }

    // connectors from Sankey columns down to Reads track (diagonal lines)
    // Disabled for now - makes display too busy
    /*
    const win = visibleVariantWindow();
    const trackLayoutForConnectors = getTrackLayout();
    const flowLayoutItem = trackLayoutForConnectors.find(l => l.track.id === "flow");
    const readsLayoutItem = trackLayoutForConnectors.find(l => l.track.id === "reads");
    
    if (flowLayoutItem && readsLayoutItem && !flowLayoutItem.track.collapsed && !readsLayoutItem.track.collapsed) {
      ctx.strokeStyle = cssVar("--blue");
      ctx.globalAlpha = 0.5;
      ctx.lineWidth = 1;
      
      // Draw diagonal lines from Sankey columns to variant positions in Reads track
      // Similar to how Locus connects to Sankey, but in reverse direction
      for (let i=0; i<win.length; i++) {
        const v = win[i];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        
        // Calculate column x position in Reads canvas coordinates
        // Use the same logic as xColumn but with Reads canvas width
        const margin = 60;
        const innerW = Math.max(10, W - 2*margin);
        let columnX;
        if (state.K <= 1) {
          columnX = margin;
        } else {
          columnX = margin + (i / (state.K - 1)) * innerW;
        }
        
        // Variant position x in Reads track (genomic coordinate mapping)
        const variantX = xGenomeCanonical(v.pos, W);
        
        // Draw diagonal line from column position to variant position
        ctx.beginPath();
        ctx.moveTo(columnX, 0); // top of reads canvas, at column x position
        ctx.lineTo(variantX, top); // connect to variant position at top of read lanes
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
    }
    */

    // Execute WebGPU render pass after variant columns are added
    if (webgpuSupported && instancedRenderer && 
        (instancedRenderer.rectInstances.length > 0 || instancedRenderer.lineInstances.length > 0)) {
      try {
        // Update projection matrix for current canvas size
        const devicePixelRatio = window.devicePixelRatio || 1;
        const width = tracksWebGPU.clientWidth * devicePixelRatio;
        const height = tracksWebGPU.clientHeight * devicePixelRatio;
        
        if (tracksWebGPU.width !== width || tracksWebGPU.height !== height) {
          tracksWebGPU.width = width;
          tracksWebGPU.height = height;
          webgpuCore.handleResize();
        }
        
        const encoder = webgpuCore.createCommandEncoder();
        const texture = webgpuCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear', // Clear canvas on each render
            storeOp: 'store',
          }],
        });
        
        instancedRenderer.render(encoder, renderPass);
        renderPass.end();
        webgpuCore.submit([encoder.finish()]);
      } catch (error) {
        console.error("WebGPU render error:", error);
        // Fallback: clear instances and continue with SVG only
        instancedRenderer.clear();
      }
    } else if (webgpuSupported && instancedRenderer) {
      // Clear WebGPU canvas if no instances to render
      try {
        const encoder = webgpuCore.createCommandEncoder();
        const texture = webgpuCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear',
            storeOp: 'store',
          }],
        });
        renderPass.end();
        webgpuCore.submit([encoder.finish()]);
      } catch (error) {
        // Ignore errors when clearing
      }
    }
  }

  // -----------------------------
  // Track controls rendering
  // -----------------------------
  const trackControls = document.getElementById("trackControls");
  function renderTrackControls() {
    trackControls.innerHTML = "";
    const layout = getTrackLayout();
    const isVertical = isVerticalMode();

    for (const item of layout) {
      const track = item.track;
      const container = document.createElement("div");
      container.className = "track-control-container";
      
      if (isVertical) {
        container.style.position = "absolute";
        container.style.left = `${item.left}px`;
        container.style.width = `${item.width}px`;
        container.style.top = "0";
        container.style.height = "100%";
      } else {
        container.style.position = "absolute";
        container.style.left = "0";
        container.style.right = "0";
        container.style.top = `${item.top}px`;
        container.style.height = `${item.height}px`;
      }
      container.dataset.trackId = track.id;

      const controls = document.createElement("div");
      controls.className = "track-controls";
      controls.dataset.trackId = track.id;

      const collapseBtn = document.createElement("button");
      collapseBtn.className = "track-collapse-btn";
      if (isVertical) {
        collapseBtn.textContent = track.collapsed ? "▲" : "▶";
      } else {
        collapseBtn.textContent = track.collapsed ? "▶" : "▼";
      }
      collapseBtn.type = "button";
      collapseBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        e.preventDefault();
        track.collapsed = !track.collapsed;
        updateTracksHeight();
        renderAll();
      });

      const label = document.createElement("div");
      label.className = "track-label";
      // For the Locus track, append the extent in parentheses
      if (track.id === "ruler") {
        const extent = Math.floor(state.endBp) - Math.floor(state.startBp);
        label.textContent = `${track.label} (${extent.toLocaleString()} bp)`;
      } else {
        label.textContent = track.label;
      }

      // In vertical mode, reverse order: label on top, button on bottom
      if (isVertical) {
        controls.appendChild(label);
        controls.appendChild(collapseBtn);
        container.appendChild(controls);
        // After appending, measure the label's width and adjust transform
        // With transform-origin: left center, the first character stays at bottom
        // We need to translate right by half width to center it horizontally
        setTimeout(() => {
          try {
            const width = label.offsetWidth || label.getBoundingClientRect().width;
            if (width > 0) {
              // After -90deg rotation:
              // - translateX moves vertically (negative = up, positive = down)
              // - translateY moves horizontally (negative = left, positive = right)
              // Use translateX(12px) to position vertically and translateY(0.0px) for horizontal
              label.style.transform = `rotate(-90deg) translateX(12px) translateY(0.0px)`;
            }
          } catch (e) {
            console.error('Error adjusting label transform:', e);
          }
        }, 10);
      } else {
        controls.appendChild(collapseBtn);
        controls.appendChild(label);
        container.appendChild(controls);
      }

      if (!track.collapsed) {
        const resizeHandle = document.createElement("div");
        resizeHandle.className = "track-resize-handle";
        resizeHandle.dataset.trackId = track.id;
        container.appendChild(resizeHandle);
      }

      trackControls.appendChild(container);
    }
  }

  // -----------------------------
  // HUD + renderAll
  // -----------------------------
  let hudHideTimeout = null;

  function renderHUD() {
    const locusText = `${state.contig}:${Math.floor(state.startBp).toLocaleString()}-${Math.floor(state.endBp).toLocaleString()}`;

    // Preserve lazy loading status if it exists
    if (window._genomeshaderLazyStatus) {
      const status = window._genomeshaderLazyStatus;
      const statusColor = status.type === 'error' ? 'var(--accent)' : 'var(--text)';
      hud.innerHTML = `<span style="color: ${statusColor}; font-weight: 500;">${status.message}</span> | ${locusText}`;
    } else {
      hud.textContent = locusText;
    }

    // In inline mode, show HUD and auto-hide after 3 seconds
    if (hostMode === 'inline') {
      hud.classList.add('visible');

      // Clear any existing timeout
      if (hudHideTimeout) {
        clearTimeout(hudHideTimeout);
      }

      // Set new timeout to hide HUD after 3 seconds
      hudHideTimeout = setTimeout(() => {
        hud.classList.remove('visible');
        hudHideTimeout = null;
      }, 3000);
    }
  }

  function updateTooltip() {
    if (state.hoveredRepeatTooltip) {
      tooltip.textContent = state.hoveredRepeatTooltip.text;
      tooltip.style.left = state.hoveredRepeatTooltip.x + 'px';
      tooltip.style.top = state.hoveredRepeatTooltip.y + 'px';
      tooltip.classList.add('visible');
    } else if (state.hoveredVariantLabelTooltip) {
      tooltip.textContent = state.hoveredVariantLabelTooltip.text;
      tooltip.style.left = state.hoveredVariantLabelTooltip.x + 'px';
      tooltip.style.top = state.hoveredVariantLabelTooltip.y + 'px';
      tooltip.classList.add('visible');
    } else {
      tooltip.classList.remove('visible');
    }
  }

  function renderAll() {
    updateDerived();
    updateTracksHeight();
    renderTracks();
    renderTrackControls();
    updateFlowAndReadsPosition();
    renderFlowCanvas();
    renderReadsCanvas();
    renderHUD();
    updateTooltip();
    setupCanvasHover();
    updateDocumentTitle();
  }

  // Hit testing for WebGPU-rendered repeats (only add listeners once)
  if (tracksWebGPU && !tracksWebGPU._tooltipListenersAdded) {
    tracksWebGPU._tooltipListenersAdded = true;
    tracksWebGPU.addEventListener('mousemove', (e) => {
      if (!webgpuSupported || repeatHitTestData.length === 0) return;
      
      const rect = tracksWebGPU.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const isVertical = isVerticalMode();
      
      // Get RepeatMasker track layout to restrict hit testing to track bounds
      const layout = getTrackLayout();
      const repeatsLayout = layout.find(l => l.track.id === "repeats");
      if (!repeatsLayout || repeatsLayout.track.collapsed) return;
      
      let repeatsY, repeatsH;
      if (isVertical) {
        repeatsY = 16;
        repeatsH = tracksWidthPx() - 32; // W - 32 in vertical mode
      } else {
        repeatsY = repeatsLayout.contentTop + 8;
        repeatsH = 22;
      }
      
      // Only do hit testing if mouse is within RepeatMasker track bounds
      if (isVertical) {
        // In vertical mode, check X coordinate (genomic axis is vertical)
        const repeatsX = repeatsLayout.contentLeft + 8;
        const repeatsW = 22;
        if (x < repeatsX || x > repeatsX + repeatsW) {
          state.hoveredRepeatTooltip = null;
          updateTooltip();
          return;
        }
      } else {
        // In horizontal mode, check Y coordinate
        if (y < repeatsY || y > repeatsY + repeatsH) {
          state.hoveredRepeatTooltip = null;
          updateTooltip();
          return;
        }
      }
      
      // Convert mouse coordinates to genome position
      let bp;
      if (isVertical) {
        const H = tracksHeightPx();
        bp = bpFromYGenome(y, H);
      } else {
        const W = tracksWidthPx();
        bp = bpFromXGenome(x, W);
      }
      
      // Find overlapping repeat (check against original coordinates)
      const hitRepeat = repeatHitTestData.find(r => 
        bp >= r.start && bp <= r.end
      );
      
      if (hitRepeat) {
        state.hoveredRepeatTooltip = {
          text: `${hitRepeat.cls} repeat\n${Math.floor(hitRepeat.start).toLocaleString()} - ${Math.floor(hitRepeat.end).toLocaleString()}`,
          x: e.clientX + 10,
          y: e.clientY + 10
        };
      } else {
        state.hoveredRepeatTooltip = null;
      }
      updateTooltip();
    });
    
    tracksWebGPU.addEventListener('mouseleave', () => {
      state.hoveredRepeatTooltip = null;
      updateTooltip();
    });
  }

  // Setup hover detection for canvas elements
  let flowHoverHandler = null;
  let flowLeaveHandler = null;
  let readsHoverHandler = null;
  let readsLeaveHandler = null;

  function setupCanvasHover() {
    // Remove existing listeners to avoid duplicates
    if (flowHoverHandler) {
      flow.removeEventListener("mousemove", flowHoverHandler);
      flow.removeEventListener("mouseleave", flowLeaveHandler);
    }
    if (readsHoverHandler) {
      reads.removeEventListener("mousemove", readsHoverHandler);
      reads.removeEventListener("mouseleave", readsLeaveHandler);
    }

    // Flow canvas hover detection
    flowHoverHandler = (e) => {
      const rect = flow.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const isVertical = isVerticalMode();
      const variantMode = getVariantLayoutMode();
      const win = visibleVariantWindow();
      
      if (isVertical) {
        const junctionX = 40;
        const H = flowHeightPx();
        const sortedWin = [...win].sort((a, b) => a.pos - b.pos);
        
        // Check if mouse is over a variant label
        if (window._variantLabelPositions && window._variantLabelPositions.length > 0) {
          for (const labelPos of window._variantLabelPositions) {
            // In vertical mode, labels are rotated 90 degrees at x=14
            // Check if mouse is near the label position (y coordinate) and in the label area (x < 30)
            const labelY = labelPos.y;
            const labelHeight = labelPos.height; // This is the font size (12px)
            if (Math.abs(y - labelY) < labelHeight && x >= 0 && x <= 30) {
              // Show tooltip with all IDs (comma-delimited)
              if (labelPos.allIds && labelPos.allIds.length > 0) {
                state.hoveredVariantLabelTooltip = {
                  text: labelPos.allIds.join(', '),
                  x: e.clientX + 10,
                  y: e.clientY + 10
                };
                updateTooltip();
              } else {
                state.hoveredVariantLabelTooltip = null;
                updateTooltip();
              }
              return;
            }
          }
        }
        
        // Check if mouse is near a column line (horizontal in vertical mode)
        for (let i = 0; i < sortedWin.length; i++) {
          const v = sortedWin[i];
          // Position based on variant layout mode
          const cy = variantMode === "genomic"
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          
          if (Math.abs(y - cy) < 10 && x >= junctionX) {
            if (state.hoveredVariantIndex !== variantIdx) {
              state.hoveredVariantIndex = variantIdx;
              renderAll();
            }
            // Clear variant label tooltip when hovering column
            state.hoveredVariantLabelTooltip = null;
            updateTooltip();
            return;
          }
        }
        
        // Check if mouse is near a diagonal connector
        const x0 = 6;
        for (let i = 0; i < sortedWin.length; i++) {
          const v = sortedWin[i];
          if (v.pos < state.startBp || v.pos > state.endBp) continue;
          const vy = yGenomeCanonical(v.pos, H); // always genomic for ruler connection
          const cy = variantMode === "genomic"
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          
          const dist = Math.abs((x - x0) * (cy - vy) / (junctionX - x0) + vy - y);
          if (dist < 5 && x >= x0 && x <= junctionX) {
            if (state.hoveredVariantIndex !== variantIdx) {
              state.hoveredVariantIndex = variantIdx;
              renderAll();
            }
            // Clear variant label tooltip when hovering connector
            state.hoveredVariantLabelTooltip = null;
            updateTooltip();
            return;
          }
        }
      } else {
        const junctionY = 40;
        const W = flowWidthPx();
        
        // Check if mouse is over a variant label
        if (window._variantLabelPositions && window._variantLabelPositions.length > 0) {
          for (const labelPos of window._variantLabelPositions) {
            // In horizontal mode, labels are at the top (y=14)
            if (x >= labelPos.x && x <= labelPos.x + labelPos.width &&
                y >= labelPos.y && y <= labelPos.y + labelPos.height) {
              // Show tooltip with all IDs (comma-delimited)
              if (labelPos.allIds && labelPos.allIds.length > 0) {
                state.hoveredVariantLabelTooltip = {
                  text: labelPos.allIds.join(', '),
                  x: e.clientX + 10,
                  y: e.clientY + 10
                };
                updateTooltip();
              } else {
                state.hoveredVariantLabelTooltip = null;
                updateTooltip();
              }
              return;
            }
          }
        }
        
        // Check if mouse is near a column line
        for (let i = 0; i < win.length; i++) {
          // Position based on variant layout mode
          const cx = variantMode === "genomic"
            ? xGenomeCanonical(win[i].pos, W)
            : xColumn(i, win.length);
          const variantIdx = state.firstVariantIndex + i;
          
          if (Math.abs(x - cx) < 10 && y >= junctionY) {
            if (state.hoveredVariantIndex !== variantIdx) {
              state.hoveredVariantIndex = variantIdx;
              renderAll();
            }
            // Clear variant label tooltip when hovering column
            state.hoveredVariantLabelTooltip = null;
            updateTooltip();
            return;
          }
        }
        
        // Check if mouse is near a diagonal connector
        const y0 = 6;
        for (let i = 0; i < win.length; i++) {
          const v = win[i];
          if (v.pos < state.startBp || v.pos > state.endBp) continue;
          const vx = xGenomeCanonical(v.pos, W); // always genomic for ruler connection
          const cx = variantMode === "genomic"
            ? xGenomeCanonical(v.pos, W)
            : xColumn(i, win.length);
          const variantIdx = state.firstVariantIndex + i;
          
          const dist = Math.abs((y - y0) * (cx - vx) / (junctionY - y0) + vx - x);
          if (dist < 5 && y >= y0 && y <= junctionY) {
            if (state.hoveredVariantIndex !== variantIdx) {
              state.hoveredVariantIndex = variantIdx;
              renderAll();
            }
            return;
          }
        }
      }
      
      // No variant hovered
      if (state.hoveredVariantIndex !== null) {
        state.hoveredVariantIndex = null;
        renderAll();
      }
      // Clear variant label tooltip when not hovering anything
      if (state.hoveredVariantLabelTooltip !== null) {
        state.hoveredVariantLabelTooltip = null;
        updateTooltip();
      }
    };
    
    flowLeaveHandler = () => {
      if (state.hoveredVariantIndex !== null || state.hoveredAlleleNode !== null) {
        state.hoveredVariantIndex = null;
        state.hoveredAlleleNode = null;
        renderAll();
      }
      // Clear variant label tooltip when leaving flow canvas
      if (state.hoveredVariantLabelTooltip !== null) {
        state.hoveredVariantLabelTooltip = null;
        updateTooltip();
      }
    };
    
    flow.addEventListener("mousemove", flowHoverHandler);
    flow.addEventListener("mouseleave", flowLeaveHandler);
    
    // Variant label click-to-pin handler
    let variantLabelClickHandler = null;
    function setupVariantLabelClick() {
      if (variantLabelClickHandler) {
        flow.removeEventListener("click", variantLabelClickHandler);
        if (flowWebGPU) flowWebGPU.removeEventListener("click", variantLabelClickHandler);
      }
      
      variantLabelClickHandler = (e) => {
        // Only handle clicks if not dragging alleles
        if (state.alleleDragState) return;
        
        const rect = flow.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Check if we clicked on a variant label
        if (!window._variantLabelPositions || window._variantLabelPositions.length === 0) return;
        
        const isVertical = isVerticalMode();
        
        for (const labelPos of window._variantLabelPositions) {
          let clicked = false;
          if (isVertical) {
            // In vertical mode, labels are rotated 90 degrees at x=14
            // Check if click is near the label position (y coordinate) and in the label area (x < 30)
            const labelY = labelPos.y;
            const labelHeight = labelPos.height; // This is the font size (12px)
            if (Math.abs(y - labelY) < labelHeight && x >= 0 && x <= 30) {
              clicked = true;
            }
          } else {
            // In horizontal mode, labels are at the top (y=14)
            if (x >= labelPos.x && x <= labelPos.x + labelPos.width &&
                y >= labelPos.y && y <= labelPos.y + labelPos.height) {
              clicked = true;
            }
          }
          
          if (clicked) {
            // Toggle pinned state
            if (state.pinnedVariantLabels.has(labelPos.variantId)) {
              state.pinnedVariantLabels.delete(labelPos.variantId);
            } else {
              state.pinnedVariantLabels.add(labelPos.variantId);
            }
            renderFlowCanvas();
            e.stopPropagation();
            return;
          }
        }
      };
      
      flow.addEventListener("click", variantLabelClickHandler);
      if (flowWebGPU) flowWebGPU.addEventListener("click", variantLabelClickHandler);
    }
    
    setupVariantLabelClick();
    
    // Allele node drag-and-drop handlers
    let alleleMouseDownHandler = null;
    let alleleMouseMoveHandler = null;
    let alleleMouseUpHandler = null;
    
    function setupAlleleDragDrop() {
      // Remove existing listeners
      if (alleleMouseDownHandler) {
        const oldTarget = flowWebGPU || flow;
        oldTarget.removeEventListener("mousedown", alleleMouseDownHandler);
        document.removeEventListener("mousemove", alleleMouseMoveHandler);
        document.removeEventListener("mouseup", alleleMouseUpHandler);
      }
      
      alleleMouseDownHandler = (e) => {
        if (!window._alleleNodePositions || window._alleleNodePositions.length === 0) return;
        
        // Use flow container for coordinates (same coordinate system as flowCanvas)
        const rect = flow.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Find which node was clicked
        for (const node of window._alleleNodePositions) {
          if (x >= node.x && x <= node.x + node.w && 
              y >= node.y && y <= node.y + node.h) {
            e.preventDefault();
            e.stopPropagation();
            state.alleleDragState = {
              variantId: node.variantId,
              alleleIndex: node.alleleIndex,
              label: node.label,
              startX: x,
              startY: y,
              offsetX: 0,
              offsetY: 0,
              isClick: true // Track if this might be a click (not a drag)
            };
            flowCanvas.style.cursor = "grabbing";
            if (flowWebGPU) flowWebGPU.style.cursor = "grabbing";
            return;
          }
        }
      };
      
      alleleMouseMoveHandler = (e) => {
        const rect = flow.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (state.alleleDragState) {
          // Handle drag
          state.alleleDragState.offsetX = x - state.alleleDragState.startX;
          state.alleleDragState.offsetY = y - state.alleleDragState.startY;
          
          // If moved more than 5 pixels, it's a drag, not a click
          const dragDistance = Math.sqrt(
            Math.pow(state.alleleDragState.offsetX, 2) + 
            Math.pow(state.alleleDragState.offsetY, 2)
          );
          if (dragDistance > 5) {
            state.alleleDragState.isClick = false;
          }
        
        // Calculate drop position to show indicator
        const dragState = state.alleleDragState;
        const order = state.variantAlleleOrder.get(dragState.variantId);
        if (order) {
          const isVertical = isVerticalMode();
          const variantMode = getVariantLayoutMode();
          const win = visibleVariantWindow();
          const constants = window._alleleNodeConstants || { baseNodeW: 4, baseNodeH: 14, gap: 8, MIN_NODE_SIZE: 4 };
          const gap = constants.gap;
          const MIN_NODE_SIZE = constants.MIN_NODE_SIZE;
          const baseNodeW = constants.baseNodeW;
          const baseNodeH = constants.baseNodeH;
          
          // Find the variant to get its allele frequencies
          const v = isVertical 
            ? [...win].sort((a, b) => a.pos - b.pos).find(v => v.id === dragState.variantId)
            : win.find(v => v.id === dragState.variantId);
          
          if (v) {
            // Get track dimension for size calculation
            const layout = getTrackLayout();
            const flowLayout = layout.find(l => l.track.id === "flow");
            const trackDimension = isVertical 
              ? (flowLayout ? flowLayout.contentWidth : 300)
              : (flowLayout ? flowLayout.contentHeight : 300);
            
            // Calculate allele sizes for this variant
            const calculateAlleleSizesFn = window.calculateAlleleSizes;
            const alleleSizes = calculateAlleleSizesFn 
              ? calculateAlleleSizesFn(v, trackDimension, MIN_NODE_SIZE, gap, order.length)
              : {}; // Fallback to empty if function not available
            
            // Map labels to allele keys
            const formatAlleleLabelFn = window.formatAlleleLabel || function(allele) {
              if (!allele || allele === ".") return ". (no-call)";
              const length = allele.length;
              const lengthLabel = length === 1 ? "1 bp" : `${length} bp`;
              return `${allele} (${lengthLabel})`;
            };
            const noCallLabel = formatAlleleLabelFn(".");
            const refLabel = v.refAllele ? formatAlleleLabelFn(v.refAllele) : null;
            function getAlleleKey(label) {
              if (label === noCallLabel) return ".";
              if (label === refLabel) return "ref";
              if (v.altAlleles && Array.isArray(v.altAlleles)) {
                const altIndex = v.altAlleles.findIndex(alt => formatAlleleLabelFn(alt) === label);
                if (altIndex >= 0) return `a${altIndex + 1}`;
              }
              return ".";
            }
            
            // Calculate margin (same as in calculateAlleleSizes)
            const marginPercent = 0.1;
            const minMargin = 10;
            const margin = Math.max(minMargin, trackDimension * marginPercent);
            
            let newIndex = -1;
            if (isVertical) {
              const left = 70;
              const W = flowWidthPx();
              const cy = variantMode === "genomic"
                ? yGenomeCanonical(v.pos, flowHeightPx())
                : yColumn(isVertical ? [...win].sort((a, b) => a.pos - b.pos).findIndex(v2 => v2.id === v.id) : win.findIndex(v2 => v2.id === v.id), isVertical ? [...win].sort((a, b) => a.pos - b.pos).length : win.length);
              
              // Calculate total width and horizontal offset for centering
              let totalNodesWidth = 0;
              for (let j = 0; j < order.length; j++) {
                const label = order[j];
                const alleleKey = getAlleleKey(label);
                const nodeW = alleleSizes[alleleKey] || baseNodeW;
                totalNodesWidth += nodeW;
                if (j < order.length - 1) {
                  totalNodesWidth += gap;
                }
              }
              const availableWidth = W - left - margin;
              const horizontalOffset = Math.max(0, (availableWidth - totalNodesWidth) / 2);
              
              // Calculate cumulative positions for variable-width nodes, starting with left + horizontal offset
              let currentX = left + horizontalOffset;
              for (let j = 0; j < order.length; j++) {
                const label = order[j];
                const alleleKey = getAlleleKey(label);
                const nodeW = alleleSizes[alleleKey] || baseNodeW;
                const nodeCenterX = currentX + nodeW / 2;
                
                if (Math.abs(x - nodeCenterX) < (nodeW + gap) / 2 && 
                    Math.abs(y - cy) < baseNodeH / 2) {
                  newIndex = j;
                  break;
                }
                currentX += nodeW + gap;
              }
              
              // If no match found, check if mouse is beyond the last node
              if (newIndex === -1 && Math.abs(y - cy) < baseNodeH / 2) {
                let lastX = left + horizontalOffset;
                for (let j = 0; j < order.length; j++) {
                  const label = order[j];
                  const alleleKey = getAlleleKey(label);
                  const nodeW = alleleSizes[alleleKey] || baseNodeW;
                  lastX += nodeW + (j < order.length - 1 ? gap : 0);
                }
                if (x > lastX - (baseNodeW + gap) / 2 && x < lastX + baseNodeW + gap) {
                  newIndex = order.length - 1;
                }
              }
            } else {
              const cx = variantMode === "genomic"
                ? xGenomeCanonical(v.pos, flowWidthPx())
                : xColumn(win.findIndex(v2 => v2.id === v.id), win.length);
              const top = 20;
              const H = flowHeightPx();
              
              // Calculate total height and vertical offset for centering
              let totalNodesHeight = 0;
              for (let j = 0; j < order.length; j++) {
                const label = order[j];
                const alleleKey = getAlleleKey(label);
                const nodeH = alleleSizes[alleleKey] || baseNodeH;
                totalNodesHeight += nodeH;
                if (j < order.length - 1) {
                  totalNodesHeight += gap;
                }
              }
              const availableHeight = H - top - margin;
              const verticalOffset = Math.max(0, (availableHeight - totalNodesHeight) / 2);
              
              // Calculate cumulative positions for variable-height nodes, starting with top + vertical offset
              let currentY = top + verticalOffset;
              for (let j = 0; j < order.length; j++) {
                const label = order[j];
                const alleleKey = getAlleleKey(label);
                const nodeH = alleleSizes[alleleKey] || baseNodeH;
                const nodeCenterY = currentY + nodeH / 2;
                
                if (Math.abs(x - cx) < baseNodeW / 2 && 
                    Math.abs(y - nodeCenterY) < (nodeH + gap) / 2) {
                  newIndex = j;
                  break;
                }
                currentY += nodeH + gap;
              }
              
              // If no match found, check if mouse is below the last node
              if (newIndex === -1 && Math.abs(x - cx) < baseNodeW / 2) {
                let lastY = top + verticalOffset;
                for (let j = 0; j < order.length; j++) {
                  const label = order[j];
                  const alleleKey = getAlleleKey(label);
                  const nodeH = alleleSizes[alleleKey] || baseNodeH;
                  lastY += nodeH + (j < order.length - 1 ? gap : 0);
                }
                if (y > lastY - (baseNodeH + gap) / 2 && y < lastY + baseNodeH + gap) {
                  newIndex = order.length - 1;
                }
              }
            }
          }
          
          // Store drop index for rendering indicator
          state.alleleDragState.dropIndex = newIndex >= 0 ? newIndex : null;
        } else {
          state.alleleDragState.dropIndex = null;
        }
        
        renderFlowCanvas();
        } else {
          // Handle hover detection when not dragging
          if (!window._alleleNodePositions || window._alleleNodePositions.length === 0) {
            if (state.hoveredAlleleNode) {
              state.hoveredAlleleNode = null;
              renderFlowCanvas();
            }
            return;
          }
          
          // Find which node is hovered
          let hoveredNode = null;
          for (const node of window._alleleNodePositions) {
            if (x >= node.x && x <= node.x + node.w && 
                y >= node.y && y <= node.y + node.h) {
              hoveredNode = { variantId: node.variantId, alleleIndex: node.alleleIndex };
              break;
            }
          }
          
          // Update hover state if changed
          const currentHover = state.hoveredAlleleNode;
          if ((hoveredNode && (!currentHover || currentHover.variantId !== hoveredNode.variantId || currentHover.alleleIndex !== hoveredNode.alleleIndex)) ||
              (!hoveredNode && currentHover)) {
            state.hoveredAlleleNode = hoveredNode;
            renderFlowCanvas();
          }
        }
      };
      
      alleleMouseUpHandler = (e) => {
        if (!state.alleleDragState) return;
        
        const rect = flow.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const dragState = state.alleleDragState;
        
        // Check if this was a click (not a drag)
        if (dragState.isClick) {
          // Toggle pinned state for this label
          const labelKey = `${dragState.variantId}:${dragState.alleleIndex}`;
          if (state.pinnedAlleleLabels.has(labelKey)) {
            state.pinnedAlleleLabels.delete(labelKey);
          } else {
            state.pinnedAlleleLabels.add(labelKey);
          }
          state.alleleDragState = null;
          flowCanvas.style.cursor = "";
          if (flowWebGPU) flowWebGPU.style.cursor = "";
          renderFlowCanvas();
          return;
        }
        
        // Otherwise, handle as a drag/drop
        const order = state.variantAlleleOrder.get(dragState.variantId);
        if (!order) {
          state.alleleDragState = null;
          flowCanvas.style.cursor = "";
          if (flowWebGPU) flowWebGPU.style.cursor = "";
          renderFlowCanvas();
          return;
        }
        
        const isVertical = isVerticalMode();
        const variantMode = getVariantLayoutMode();
        const win = visibleVariantWindow();
        const constants = window._alleleNodeConstants || { baseNodeW: 4, baseNodeH: 14, gap: 8, MIN_NODE_SIZE: 4 };
        const nodeW = constants.baseNodeW;
        const nodeH = constants.baseNodeH;
        const gap = constants.gap;
        
        let newIndex = -1;
        if (isVertical) {
          const sortedWin = [...win].sort((a, b) => a.pos - b.pos);
          const v = sortedWin.find(v => v.id === dragState.variantId);
          if (!v) {
            state.alleleDragState = null;
            flowCanvas.style.cursor = "";
            if (flowWebGPU) flowWebGPU.style.cursor = "";
            renderFlowCanvas();
            return;
          }
          const left = 70;
          const cy = variantMode === "genomic"
            ? yGenomeCanonical(v.pos, flowHeightPx())
            : yColumn(sortedWin.findIndex(v2 => v2.id === v.id), sortedWin.length);
          
          // Check if dropped near a node position
          for (let j = 0; j < order.length; j++) {
            const nodeX = left + j * (nodeW + gap);
            if (Math.abs(x - nodeX) < (nodeW + gap) / 2 && 
                Math.abs(y - cy) < nodeH / 2) {
              newIndex = j;
              break;
            }
          }
          
          // If no match found, check if mouse is beyond the last node (for dropping at last position)
          if (newIndex === -1 && Math.abs(y - cy) < nodeH / 2) {
            const lastNodeX = left + (order.length - 1) * (nodeW + gap);
            // Check if mouse is to the right of the last node (within reasonable distance)
            if (x > lastNodeX - (nodeW + gap) / 2 && x < lastNodeX + nodeW + gap + (nodeW + gap) / 2) {
              newIndex = order.length - 1;
            }
          }
        } else {
          const v = win.find(v => v.id === dragState.variantId);
          if (!v) {
            state.alleleDragState = null;
            flowCanvas.style.cursor = "";
            if (flowWebGPU) flowWebGPU.style.cursor = "";
            renderFlowCanvas();
            return;
          }
          const cx = variantMode === "genomic"
            ? xGenomeCanonical(v.pos, flowWidthPx())
            : xColumn(win.findIndex(v2 => v2.id === v.id), win.length);
          const top = 20;
          
          // Check if dropped near a node position
          for (let j = 0; j < order.length; j++) {
            const nodeY = top + j * (nodeH + gap);
            if (Math.abs(x - cx) < nodeW / 2 && 
                Math.abs(y - nodeY) < (nodeH + gap) / 2) {
              newIndex = j;
              break;
            }
          }
          
          // If no match found, check if mouse is below the last node (for dropping at last position)
          if (newIndex === -1 && Math.abs(x - cx) < nodeW / 2) {
            const lastNodeY = top + (order.length - 1) * (nodeH + gap);
            // Check if mouse is below the last node (within reasonable distance)
            if (y > lastNodeY - (nodeH + gap) / 2 && y < lastNodeY + nodeH + gap + (nodeH + gap) / 2) {
              newIndex = order.length - 1;
            }
          }
        }
        
        // Reorder if dropped at a valid position
        if (newIndex >= 0 && newIndex !== order.indexOf(dragState.label)) {
          const currentIndex = order.indexOf(dragState.label);
          order.splice(currentIndex, 1);
          order.splice(newIndex, 0, dragState.label);
          state.variantAlleleOrder.set(dragState.variantId, order);
        }
        
        state.alleleDragState = null;
        flowCanvas.style.cursor = "";
        if (flowWebGPU) flowWebGPU.style.cursor = "";
        renderFlowCanvas();
      };
      
      // Attach to flowWebGPU canvas (which is on top) or flow container
      // Both flowCanvas and flowWebGPU are inside flow, so coordinates are relative to flow
      const targetElement = flowWebGPU || flow;
      targetElement.addEventListener("mousedown", alleleMouseDownHandler, { passive: false });
      document.addEventListener("mousemove", alleleMouseMoveHandler);
      document.addEventListener("mouseup", alleleMouseUpHandler);
    }
    
    setupAlleleDragDrop();

    // Reads canvas hover detection
    readsHoverHandler = (e) => {
      const rect = reads.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const isVertical = isVerticalMode();
      
      if (isVertical) {
        const H = readsHeightPx();
        const left = 8;
        
        // Check if mouse is near a variant line (horizontal in vertical mode)
        for (let idx = 0; idx < variants.length; idx++) {
          const v = variants[idx];
          if (v.pos < state.startBp || v.pos > state.endBp) continue;
          const vy = yGenomeCanonical(v.pos, H);
          
          if (Math.abs(y - vy) < 10 && x >= left) {
            if (state.hoveredVariantIndex !== idx) {
              state.hoveredVariantIndex = idx;
              renderAll();
            }
            return;
          }
        }
      } else {
        const W = readsWidthPx();
        const top = 8;
        
        // Check if mouse is near a variant line
        for (let idx = 0; idx < variants.length; idx++) {
          const v = variants[idx];
          if (v.pos < state.startBp || v.pos > state.endBp) continue;
          const vx = xGenomeCanonical(v.pos, W);
          
          if (Math.abs(x - vx) < 10 && y >= top) {
            if (state.hoveredVariantIndex !== idx) {
              state.hoveredVariantIndex = idx;
              renderAll();
            }
            return;
          }
        }
      }
      
      // No variant hovered
      if (state.hoveredVariantIndex !== null) {
        state.hoveredVariantIndex = null;
        renderAll();
      }
    };
    
    readsLeaveHandler = () => {
      if (state.hoveredVariantIndex !== null) {
        state.hoveredVariantIndex = null;
        renderAll();
      }
    };
    
    reads.addEventListener("mousemove", readsHoverHandler);
    reads.addEventListener("mouseleave", readsLeaveHandler);
  }

  function updateFlowAndReadsPosition() {
    const layout = getTrackLayout();
    const isVertical = isVerticalMode();
    
    const flowLayout = layout.find(l => l.track.id === "flow");
    if (flowLayout) {
      if (isVertical) {
        flow.style.left = `${flowLayout.contentLeft}px`;
        flow.style.width = flowLayout.track.collapsed ? "0px" : `${flowLayout.contentWidth}px`;
        flow.style.top = "0";
        flow.style.height = "100%";
      } else {
        flow.style.top = `${flowLayout.contentTop}px`;
        flow.style.height = flowLayout.track.collapsed ? "0px" : `${flowLayout.contentHeight}px`;
        flow.style.left = "0";
        flow.style.width = "100%";
      }
      flow.style.display = flowLayout.track.collapsed ? "none" : "block";
    }
    
    const readsLayout = layout.find(l => l.track.id === "reads");
    if (readsLayout) {
      if (isVertical) {
        reads.style.left = `${readsLayout.contentLeft}px`;
        // Extend Reads track to the right edge of the main container
        const mainWidth = rectW(main);
        reads.style.width = readsLayout.track.collapsed ? "0px" : `${mainWidth - readsLayout.contentLeft}px`;
        reads.style.top = "0";
        reads.style.height = "100%";
      } else {
        reads.style.top = `${readsLayout.contentTop}px`;
        reads.style.height = readsLayout.track.collapsed ? "0px" : `${readsLayout.contentHeight}px`;
        reads.style.left = "0";
        reads.style.width = "100%";
      }
      reads.style.display = readsLayout.track.collapsed ? "none" : "block";
    }
  }

  // -----------------------------
  // Pan + Zoom helpers
  // -----------------------------
  function clampSpan(span) {
    const MIN_SPAN = 50;
    const MAX_SPAN = 5_000_000;
    return Math.max(MIN_SPAN, Math.min(MAX_SPAN, span));
  }

  function zoomByFactor(factor, anchorBp) {
    const oldSpan = state.endBp - state.startBp;
    const newSpan = clampSpan(oldSpan / factor);

    const leftFrac = (anchorBp - state.startBp) / oldSpan;
    const newStart = anchorBp - leftFrac * newSpan;

    state.startBp = newStart;
    state.endBp = newStart + newSpan;

    // Clamp to chromosome boundaries
    clampToChromosomeBounds();

    renderAll();
  }

  function panByPixels(dxPx, dyPx) {
    const isVertical = isVerticalMode();
    const deltaPx = isVertical ? (dyPx !== undefined ? dyPx : 0) : (dxPx !== undefined ? dxPx : 0);
    const deltaBp = deltaPx / state.pxPerBp;
    // In vertical mode: down = lower locus (increase), up = higher locus (decrease)
    // In horizontal mode: right = higher locus (increase), left = lower locus (decrease)
    if (isVertical) {
      state.startBp += deltaBp;
      state.endBp   += deltaBp;
    } else {
      state.startBp -= deltaBp;
      state.endBp   -= deltaBp;
    }

    // Clamp to chromosome boundaries
    clampToChromosomeBounds();

    // Placeholder heuristic for shifting the variant window
    const win = visibleVariantWindow();
    if (win.length > 0) {
      const first = win[0].pos;
      while (state.firstVariantIndex > 0 && first > state.endBp) state.firstVariantIndex--;
      while (state.firstVariantIndex + 1 < variants.length &&
             first < state.startBp - (state.endBp-state.startBp)*0.25) {
        state.firstVariantIndex++;
        if (state.firstVariantIndex + state.K > variants.length) break;
      }
      state.firstVariantIndex = Math.max(0, Math.min(state.firstVariantIndex, Math.max(0, variants.length - state.K)));
    }

    renderAll();
  }

  function anchorBpFromClientX(clientX) {
    const rect = tracksSvg.getBoundingClientRect();
    const xInPane = clientX - rect.left;
    return bpFromXGenome(xInPane, tracksWidthPx());
  }
  function anchorBpFromClientY(clientY) {
    const rect = tracksSvg.getBoundingClientRect();
    const yInPane = clientY - rect.top;
    return bpFromYGenome(yInPane, tracksHeightPx());
  }
  function anchorBpFromClient(clientX, clientY) {
    const isVertical = isVerticalMode();
    if (isVertical) {
      return anchorBpFromClientY(clientY);
    } else {
      return anchorBpFromClientX(clientX);
    }
  }

  // -----------------------------
  // Interaction (right pane)
  // -----------------------------
  
  // Bind wheel, pointer, and dblclick events to main element
  // Returns a destroy function to clean up listeners
  function bindInteractions(root, state, main) {
    if (!main) {
      return { destroy() {} };
    }

    // Wheel: pan/zoom gestures
    // Use composedPath() as primary gate to ensure event is over viewport
    function shouldHandleWheel(e) {
      const path = e.composedPath ? e.composedPath() : [];
      return path.includes(main); // main is the viewport element that should pan/zoom
    }

    const onWheel = (e) => {
      // Extra safety: ignore wheel not originating inside this viewer
      const path = e.composedPath ? e.composedPath() : [];
      if (!path.includes(main)) return;

      const isPinchZoom = e.ctrlKey === true || e.metaKey === true;
      const isVertical = isVerticalMode();
      const dx = e.deltaX;
      const dy = e.deltaY;

      if (isPinchZoom) {
        // Handle pinch-to-zoom (trackpad gesture with ctrl/meta)
        e.preventDefault();
        e.stopPropagation(); // Prevent bubbling to window/document
        const zoomIntensity = 0.0018;
        // Use vertical delta for pinch zoom (standard trackpad convention)
        const factor = Math.exp(-dy * zoomIntensity);
        const anchorBp = isVertical 
          ? anchorBpFromClientY(e.clientY)
          : anchorBpFromClientX(e.clientX);
        zoomByFactor(factor, anchorBp);
        return;
      }
      
      if (isVertical) {
        // In vertical mode: vertical wheel = pan, horizontal wheel = zoom
        const wantPan = e.shiftKey || Math.abs(dy) > Math.abs(dx);
        
        if (wantPan) {
          e.preventDefault();
          e.stopPropagation(); // Prevent bubbling to window/document
          const panDy = e.shiftKey ? dx : dy;
          panByPixels(0, panDy);
          return;
        }

        e.preventDefault();
        e.stopPropagation(); // Prevent bubbling to window/document
        const zoomIntensity = 0.0018;
        const factor = Math.exp(-dx * zoomIntensity);

        const anchorBp = anchorBpFromClientY(e.clientY);
        zoomByFactor(factor, anchorBp);
      } else {
        // In horizontal mode: horizontal wheel = pan, vertical wheel = zoom
        const wantPan = e.shiftKey || Math.abs(dx) > Math.abs(dy);

        if (wantPan) {
          e.preventDefault();
          e.stopPropagation(); // Prevent bubbling to window/document
          const panDx = e.shiftKey ? dy : dx;
          panByPixels(panDx, 0);
          return;
        }

        e.preventDefault();
        e.stopPropagation(); // Prevent bubbling to window/document
        const zoomIntensity = 0.0018;
        const factor = Math.exp(-dy * zoomIntensity);

        const anchorBp = anchorBpFromClientX(e.clientX);
        zoomByFactor(factor, anchorBp);
      }
    };

    const onPointerDown = (e) => {
      // Don't start drag if clicking on a variant (for insertion expansion)
      // Check if clicking on SVG elements that are variants
      const target = e.target;
      if (target && target.tagName && (target.tagName === "line" || target.tagName === "circle" || target.tagName === "rect")) {
        // Check if this is a variant element (has blue stroke or is in the variant area)
        const stroke = target.getAttribute ? target.getAttribute("stroke") : null;
        if (stroke && (stroke === "var(--blue)" || stroke === cssVar("--blue") || stroke.includes("blue"))) {
          // This might be a variant - don't start dragging, let click handler work
          return;
        }
        // Also check if it's the invisible click area for insertions
        if (target.getAttribute && target.getAttribute("fill") === "transparent" && target.getAttribute("width") === "10") {
          return;
        }
      }
      
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      main.setPointerCapture(e.pointerId);

      if (state.pointers.size === 1) {
        state.dragging = true;
        state.lastX = e.clientX;
        state.lastY = e.clientY;
      } else {
        state.dragging = false;
      }
    };

    const onPointerMove = (e) => {
      if (!state.pointers.has(e.pointerId)) return;
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (state.pointers.size === 2) {
        const pts = Array.from(state.pointers.values());
        const dx = pts[0].x - pts[1].x;
        const dy = pts[0].y - pts[1].y;
        const dist = Math.hypot(dx, dy);

        if (state.pinchStartDist == null) {
          state.pinchStartDist = dist;
          state.pinchStartSpan = (state.endBp - state.startBp);

          const midX = (pts[0].x + pts[1].x) / 2;
          const midY = (pts[0].y + pts[1].y) / 2;
          state.pinchAnchorBp = anchorBpFromClient(midX, midY);
        } else {
          const scale = dist / state.pinchStartDist; // >1 apart => zoom in
          const oldSpan = state.pinchStartSpan;
          const newSpan = clampSpan(oldSpan / scale);

          const anchorBp = state.pinchAnchorBp ?? (state.startBp + (state.endBp-state.startBp)/2);
          const leftFrac = (anchorBp - state.startBp) / (state.endBp - state.startBp);
          const newStart = anchorBp - leftFrac * newSpan;

          state.startBp = newStart;
          state.endBp = newStart + newSpan;

          // Clamp to chromosome boundaries
          clampToChromosomeBounds();

          renderAll();
        }
        return;
      }

      if (state.dragging) {
        const isVertical = isVerticalMode();
        const dx = e.clientX - state.lastX;
        const dy = e.clientY - state.lastY;
        state.lastX = e.clientX;
        state.lastY = e.clientY;
        if (isVertical) {
          panByPixels(0, -dy);
        } else {
          panByPixels(-dx, 0);
        }
      }
    };

    function endPointer(e) {
      state.pointers.delete(e.pointerId);
      if (state.pointers.size < 2) {
        state.pinchStartDist = null;
        state.pinchStartSpan = null;
        state.pinchAnchorBp = null;
      }
      if (state.pointers.size === 0) state.dragging = false;
    }

    const onPointerUp = endPointer;
    const onPointerCancel = endPointer;

    const onDblClick = (e) => {
      const anchorBp = anchorBpFromClient(e.clientX, e.clientY);
      zoomByFactor(1.6, anchorBp);
    };

    // Attach event listeners
    main.addEventListener("wheel", onWheel, { passive: false });
    main.addEventListener("pointerdown", onPointerDown);
    main.addEventListener("pointermove", onPointerMove);
    main.addEventListener("pointerup", onPointerUp);
    main.addEventListener("pointercancel", onPointerCancel);
    main.addEventListener("dblclick", onDblClick);

    // Return destroy function
    return {
      destroy() {
        main.removeEventListener("wheel", onWheel, { passive: false });
        main.removeEventListener("pointerdown", onPointerDown);
        main.removeEventListener("pointermove", onPointerMove);
        main.removeEventListener("pointerup", onPointerUp);
        main.removeEventListener("pointercancel", onPointerCancel);
        main.removeEventListener("dblclick", onDblClick);
      }
    };
  }

  // Remove any wheel listeners on window/document that could cause global behavior
  // Note: getEventListeners is a DevTools-only function, so this only works when DevTools is open
  function removeGlobalWheelListeners() {
    if (typeof getEventListeners === 'function') {
      try {
        const windowWheel = getEventListeners(window).wheel;
        const docWheel = getEventListeners(document).wheel;
        if (windowWheel && windowWheel.length > 0) {
          windowWheel.forEach(listener => {
            try {
              window.removeEventListener("wheel", listener.listener, listener.useCapture);
            } catch (e) {
              console.warn("[gs] Failed to remove window wheel listener:", e);
            }
          });
        }
        if (docWheel && docWheel.length > 0) {
          docWheel.forEach(listener => {
            try {
              document.removeEventListener("wheel", listener.listener, listener.useCapture);
            } catch (e) {
              console.warn("[gs] Failed to remove document wheel listener:", e);
            }
          });
        }
      } catch (e) {
        console.warn("[gs] Error checking for global wheel listeners:", e);
      }
    }
  }
  
  // Remove global wheel listeners before binding our scoped ones
  removeGlobalWheelListeners();

  // Bind interactions and store destroy function
  interactionBinding = bindInteractions(root, state, main);

  // -----------------------------
  // Track interactions (drag, resize)
  // -----------------------------
  if (trackControls) {
  trackControls.addEventListener("pointerdown", (e) => {
    // Don't start drag if clicking on collapse button
    if (e.target.closest(".track-collapse-btn")) {
      e.stopPropagation();
      return;
    }
    
    const controls = e.target.closest(".track-controls");
    const resizeHandle = e.target.closest(".track-resize-handle");
    
    if (resizeHandle) {
      // Start resizing
      e.stopPropagation();
      const trackId = resizeHandle.dataset.trackId;
      const track = state.tracks.find(t => t.id === trackId);
      if (!track) return;
      
      e.preventDefault();
      const isVertical = isVerticalMode();
      state.trackResizeState = {
        trackId,
        startX: e.clientX,
        startY: e.clientY,
        startHeight: track.height
      };
      trackControls.setPointerCapture(e.pointerId);
    } else if (controls) {
      // Start dragging for reorder
      e.stopPropagation();
      const trackId = controls.dataset.trackId;
      e.preventDefault();
      const isVertical = isVerticalMode();
      state.trackDragState = {
        trackId,
        startX: e.clientX,
        startY: e.clientY,
        offsetX: 0,
        offsetY: 0
      };
      trackControls.setPointerCapture(e.pointerId);
    }
  });

  trackControls.addEventListener("pointermove", (e) => {
    if (state.trackResizeState) {
      // Resizing
      const track = state.tracks.find(t => t.id === state.trackResizeState.trackId);
      if (!track) return;
      
      e.preventDefault();
      const isVertical = isVerticalMode();
      let delta;
      if (isVertical) {
        // In vertical mode, resize based on horizontal movement
        delta = e.clientX - state.trackResizeState.startX;
      } else {
        // In horizontal mode, resize based on vertical movement
        delta = e.clientY - state.trackResizeState.startY;
      }
      const newHeight = Math.max(track.minHeight, state.trackResizeState.startHeight + delta);
      track.height = newHeight;
      updateTracksHeight();
      renderAll();
    } else if (state.trackDragState) {
      // Dragging for reorder
      e.preventDefault();
      const isVertical = isVerticalMode();
      const dx = e.clientX - state.trackDragState.startX;
      const dy = e.clientY - state.trackDragState.startY;
      
      if (isVertical) {
        state.trackDragState.offsetX = dx;
      } else {
        state.trackDragState.offsetY = dy;
      }
      
      // Visual feedback: move the dragged track
      const layout = getTrackLayout();
      const draggedItem = layout.find(l => l.track.id === state.trackDragState.trackId);
      if (draggedItem) {
        const container = trackControls.querySelector(`[data-track-id="${state.trackDragState.trackId}"]`);
        if (container) {
          if (isVertical) {
            container.style.transform = `translateX(${dx}px)`;
          } else {
            container.style.transform = `translateY(${dy}px)`;
          }
          container.style.zIndex = "100";
          container.style.opacity = "0.8";
        }
      }
    }
  });

  function endTrackInteraction(e) {
    // Only process if we have an active interaction
    if (!state.trackResizeState && !state.trackDragState) return;
    
    // Release pointer capture
    if (e.target.releasePointerCapture) {
      try {
        e.target.releasePointerCapture(e.pointerId);
      } catch (err) {
        // Ignore if already released
      }
    }
    
    if (state.trackResizeState) {
      state.trackResizeState = null;
    } else if (state.trackDragState) {
      // Handle reordering
      const layout = getTrackLayout();
      const draggedItem = layout.find(l => l.track.id === state.trackDragState.trackId);
      if (draggedItem) {
        const container = trackControls.querySelector(`[data-track-id="${state.trackDragState.trackId}"]`);
        if (container) {
          container.style.transform = "";
          container.style.zIndex = "";
          container.style.opacity = "";
        }
        
        // Find new position based on orientation
        const isVertical = isVerticalMode();
        let newIndex = 0;
        if (isVertical) {
          const newX = draggedItem.left + state.trackDragState.offsetX;
          for (let i = 0; i < layout.length; i++) {
            if (newX > layout[i].left + layout[i].width / 2) {
              newIndex = i + 1;
            }
          }
        } else {
          const newY = draggedItem.top + state.trackDragState.offsetY;
          for (let i = 0; i < layout.length; i++) {
            if (newY > layout[i].top + layout[i].height / 2) {
              newIndex = i + 1;
            }
          }
        }
        newIndex = Math.max(0, Math.min(newIndex, layout.length - 1));
        
        // Reorder tracks
        const currentIndex = state.tracks.findIndex(t => t.id === state.trackDragState.trackId);
        if (currentIndex !== newIndex && currentIndex !== -1) {
          const [track] = state.tracks.splice(currentIndex, 1);
          state.tracks.splice(newIndex, 0, track);
          renderAll();
        } else {
          // Just re-render to reset visual state
          renderAll();
        }
      }
      state.trackDragState = null;
    }
  }

  trackControls.addEventListener("pointerup", endTrackInteraction);
  trackControls.addEventListener("pointercancel", endTrackInteraction);
  
  // Also listen on document to catch pointerup events that might occur outside
  document.addEventListener("pointerup", (e) => {
    if (state.trackResizeState || state.trackDragState) {
      endTrackInteraction(e);
    }
  });
  document.addEventListener("pointercancel", (e) => {
    if (state.trackResizeState || state.trackDragState) {
      endTrackInteraction(e);
    }
  });
  }

  // Resize
  new ResizeObserver(() => {
    // Handle WebGPU canvas resize
    if (webgpuCore && webgpuSupported) {
      try {
        webgpuCore.handleResize();
      } catch (error) {
        console.error("WebGPU resize error:", error);
      }
    }
    renderAll();
  }).observe(flow);
  new ResizeObserver(() => renderAll()).observe(reads);
  new ResizeObserver(() => {
    // Handle WebGPU canvas resize when tracks container resizes
    if (webgpuCore && webgpuSupported) {
      try {
        webgpuCore.handleResize();
      } catch (error) {
        console.error("WebGPU resize error:", error);
      }
    }
    renderAll();
  }).observe(tracksSvg);
  window.addEventListener("resize", () => {
    // Handle WebGPU canvas resize
    if (webgpuCore && webgpuSupported) {
      try {
        webgpuCore.handleResize();
      } catch (error) {
        console.error("WebGPU resize error:", error);
      }
    }
    renderAll();
  });

  renderAll();
</script>
</body>
</html>