<!doctype html>
<html lang="en" data-theme="auto">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Genomeshader Prototype (SVG scaffolding)</title>

  <!--__GENOMESHADER_BOOTSTRAP__-->

  <style>
    :root {
      --sidebar-w: 240px;
      --tracks-h: 280px;   /* ideogram + genes + repeats + ruler */
      --flow-h: 500px;     /* sankey placeholder */
      --reads-h: 220px;    /* IGV-style reads area placeholder */

      --bg: #0b0d10;
      --panel: #11151b;
      --panel2: rgba(255,255,255,0.03);

      --border: rgba(255,255,255,0.10);
      --border2: rgba(255,255,255,0.08);

      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --muted2: rgba(255,255,255,0.45);

      --grid: rgba(255,255,255,0.12);
      --grid2: rgba(255,255,255,0.07);

      --accent: #ff4d4d;

      --blue: rgba(120,180,255,0.9);
      --blueFill: rgba(120,180,255,0.18);

      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --hudBg: rgba(0,0,0,0.35);
    }

    html[data-theme="light"] {
      --bg: #f7f8fb;
      --panel: #ffffff;
      --panel2: rgba(0,0,0,0.03);

      --border: rgba(0,0,0,0.12);
      --border2: rgba(0,0,0,0.10);

      --text: rgba(0,0,0,0.90);
      --muted: rgba(0,0,0,0.62);
      --muted2: rgba(0,0,0,0.45);

      --grid: rgba(0,0,0,0.12);
      --grid2: rgba(0,0,0,0.07);

      --accent: #d81b1b;

      --blue: rgba(18, 110, 255, 0.85);
      --blueFill: rgba(18, 110, 255, 0.14);

      --shadow: 0 10px 30px rgba(0,0,0,0.12);
      --hudBg: rgba(255,255,255,0.78);
    }

    @media (prefers-color-scheme: light) {
      html[data-theme="auto"] {
        --bg: #f7f8fb;
        --panel: #ffffff;
        --panel2: rgba(0,0,0,0.03);

        --border: rgba(0,0,0,0.12);
        --border2: rgba(0,0,0,0.10);

        --text: rgba(0,0,0,0.90);
        --muted: rgba(0,0,0,0.62);
        --muted2: rgba(0,0,0,0.45);

        --grid: rgba(0,0,0,0.12);
        --grid2: rgba(0,0,0,0.07);

        --accent: #d81b1b;

        --blue: rgba(18, 110, 255, 0.85);
        --blueFill: rgba(18, 110, 255, 0.14);

        --shadow: 0 10px 30px rgba(0,0,0,0.12);
        --hudBg: rgba(255,255,255,0.78);
      }
    }
    @media (prefers-color-scheme: dark) {
      html[data-theme="auto"] {
        --bg: #0b0d10;
        --panel: #11151b;
        --panel2: rgba(255,255,255,0.03);

        --border: rgba(255,255,255,0.10);
        --border2: rgba(255,255,255,0.08);

        --text: rgba(255,255,255,0.92);
        --muted: rgba(255,255,255,0.65);
        --muted2: rgba(255,255,255,0.45);

        --grid: rgba(255,255,255,0.12);
        --grid2: rgba(255,255,255,0.07);

        --accent: #ff4d4d;

        --blue: rgba(120,180,255,0.9);
        --blueFill: rgba(120,180,255,0.18);

        --shadow: 0 10px 30px rgba(0,0,0,0.35);
        --hudBg: rgba(0,0,0,0.35);
      }
    }

    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui; }
    * { box-sizing: border-box; }

    .app {
      display: grid;
      grid-template-columns: var(--sidebar-w) 1fr;
      height: 100%;
      overflow: hidden;
      transition: grid-template-columns 0.2s ease;
    }
    .app.sidebar-collapsed {
      grid-template-columns: 12px 1fr;
    }
    .app.sidebar-collapsed .sidebar {
      width: 12px !important;
      min-width: 12px;
    }

    .sidebar {
      position: relative;
      background: var(--panel);
      border-right: 1px solid var(--border2);
      padding: 0;
      overflow: hidden;
      transition: opacity 0.2s ease;
      display: flex;
      flex-direction: column;
    }
    .sidebarContent {
      flex: 1;
      overflow-y: auto;
      overflow-x: visible;
      padding: 12px;
      padding-bottom: 12px;
    }
    .sidebar::after {
      content: "";
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease, width 0.2s ease, box-shadow 0.2s ease;
      z-index: 10;
    }
    .sidebar:hover::after {
      background: var(--blue);
      width: 6px;
      box-shadow: 0 0 8px rgba(120, 180, 255, 0.4);
    }
    .app.sidebar-collapsed .sidebar {
      padding: 0;
      overflow: visible;
    }
    .app.sidebar-collapsed .sidebar > * {
      opacity: 0;
      pointer-events: none;
    }
    .app.sidebar-collapsed .sidebarContent {
      opacity: 0;
      pointer-events: none;
    }
    .app.sidebar-collapsed .sidebar::after {
      pointer-events: auto;
      opacity: 1 !important;
      right: 0;
      width: 12px;
      background: rgba(127, 127, 127, 0.08);
      border-right: 1px solid var(--border2);
    }
    .app.sidebar-collapsed .sidebar:hover::after {
      width: 14px;
      background: var(--blue);
      border-right: none;
      box-shadow: 0 0 12px rgba(120, 180, 255, 0.5);
    }
    /* Adjust main panel position when sidebar is collapsed */
    .app.sidebar-collapsed .main {
      left: 12px !important;
    }

    .sidebarHeader {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      margin-bottom: 10px;
      gap: 8px;
    }
    
    .sidebarToggle {
      width: 24px;
      height: 24px;
      border: 1px solid var(--border2);
      background: var(--panel2);
      color: var(--text);
      border-radius: 6px;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      padding: 0;
      flex-shrink: 0;
      transition: all 0.15s ease;
    }
    .sidebarToggle:hover {
      background: var(--panel);
      border-color: var(--border);
    }
    .sidebarToggle:active {
      transform: scale(0.95);
    }
    
    .sidebarHeader h3 {
      margin: 0;
      font-size: 13px;
      color: var(--muted);
      font-weight: 650;
      letter-spacing: 0.02em;
    }

    .group {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 9px 10px;
      margin: 7px 0;
      border-radius: 10px;
      background: var(--panel2);
      cursor: pointer;
      user-select: none;
      border: 1px solid transparent;
    }
    .group:hover { border-color: var(--border2); }
    .pill { font-size: 12px; padding: 2px 8px; border-radius: 999px; background: rgba(127,127,127,0.16); color: var(--muted); }

    /* Gear button bottom-left (requested) */
    .gearBtn {
      position: absolute !important;
      left: 12px !important;
      bottom: 12px !important;
      z-index: 10 !important;
      border: 1px solid var(--border2);
      background: var(--panel2);
      color: var(--text);
      width: 36px;
      height: 36px;
      border-radius: 12px;
      cursor: pointer;
      user-select: none;
      display: grid;
      place-items: center;
      font-size: 18px;
      line-height: 1;
    }
    .gearBtn:hover { filter: brightness(1.06); }
    .gearBtn:active { transform: translateY(1px); }

    /* Context menu */
    .menu {
      position: absolute;
      min-width: 220px;
      padding: 8px;
      border-radius: 12px;
      background: var(--panel);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      z-index: 50;
      display: none;
    }
    .menu.open { display: block; }
    .menuTitle {
      font-size: 11px;
      color: var(--muted2);
      padding: 6px 8px 4px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }
    .menuItem {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 10px;
      border-radius: 10px;
      cursor: pointer;
      user-select: none;
      color: var(--text);
      font-size: 13px;
    }
    .menuItem:hover { background: var(--panel2); }
    .menuRight { color: var(--muted); font-size: 12px; }
    .menuHotkey {
      color: var(--muted2);
      font-size: 11px;
      font-family: monospace;
      background: var(--panel2);
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 8px;
    }
    
    /* Selection controls in sidebar */
    .selectionBtn {
      padding: 9px 10px;
      border-radius: 10px;
      background: var(--panel2);
      border: 1px solid var(--border2);
      color: var(--text);
      font-size: 12px;
      cursor: pointer;
      user-select: none;
      transition: all 0.2s ease;
      text-align: left;
    }
    .selectionBtn:hover {
      background: var(--panel);
      border-color: var(--border);
    }
    .selectionBtn:active {
      transform: scale(0.98);
    }
    .selectionBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* Combine toggle (AND/OR) */
    .combineToggle.active {
      background: var(--blue) !important;
      color: white !important;
    }
    
    /* Sample search results */
    #sampleSearchResults {
      font-size: 11px;
    }
    .sampleSearchResult {
      padding: 6px 8px;
      cursor: pointer;
      border-bottom: 1px solid var(--border2);
    }
    .sampleSearchResult:last-child {
      border-bottom: none;
    }
    .sampleSearchResult:hover {
      background: var(--panel2);
    }
    
    /* Ensure all form elements in sidebar are clickable and interactive */
    .sidebar select,
    .sidebar input,
    .sidebar button,
    .sidebar label {
      pointer-events: auto !important;
      position: relative !important;
      z-index: 200 !important;
    }
    
    /* Style for select dropdown to ensure it's visible */
    .sidebar select {
      -webkit-appearance: menulist !important;
      -moz-appearance: menulist !important;
      appearance: menulist !important;
      cursor: pointer !important;
    }
    
    /* Style for range input to ensure it's interactive */
    .sidebar input[type="range"] {
      -webkit-appearance: auto !important;
      appearance: auto !important;
      cursor: pointer !important;
    }
    
    /* Style for number input */
    .sidebar input[type="number"] {
      -webkit-appearance: auto !important;
      appearance: auto !important;
    }
    
    /* Style for text input */
    .sidebar input[type="text"] {
      -webkit-appearance: auto !important;
      appearance: auto !important;
      cursor: text !important;
    }
    
    /* Fix for nested elements in sample selection section */
    #sampleStrategySection,
    #sampleStrategySection *,
    #sampleSearchSection,
    #sampleSearchSection *,
    #sampleContext,
    #sampleContext * {
      pointer-events: auto !important;
    }
    
    /* Ensure sample strategy section has proper stacking context */
    #sampleStrategySection {
      position: relative !important;
      z-index: 200 !important;
    }
    #sampleSearchSection {
      position: relative !important;
      z-index: 200 !important;
    }
    /* Ensure sidebar content is above any potential overlays */
    .sidebar .sidebarHeader,
    .sidebar .group {
      position: relative !important;
      z-index: 200 !important;
    }

    .main {
      position: relative;
      overflow: hidden;
      touch-action: none; /* we own pan/zoom gestures on right pane */
    }

    .tracks {
      position: absolute;
      left: 0; top: 0; right: 0;
      height: var(--tracks-h);
      border-bottom: 1px solid var(--border);
      background: linear-gradient(to bottom, rgba(127,127,127,0.08), rgba(127,127,127,0.00));
    }
    #trackControls {
      position: absolute;
      inset: 0;
      z-index: 20;
      pointer-events: none;
    }

    .flow {
      position: absolute;
      left: 0; right: 0;
      background: rgba(127,127,127,0.04);
    }

    .reads {
      position: absolute;
      left: 0; right: 0;
      background: rgba(127,127,127,0.02);
    }

    /* Vertical mode: tracks laid out side-by-side */
    .main.vertical .tracks {
      display: flex;
      flex-direction: row;
      height: 100%;
      width: 100%;
      left: 0;
      top: 0;
      right: auto;
      bottom: 0;
      border-bottom: none;
      border-right: 1px solid var(--border);
    }

    .main.vertical .flow,
    .main.vertical .reads {
      position: absolute;
      top: 0;
      bottom: 0;
      height: 100%;
    }

    canvas.canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    canvas.webgpu-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      pointer-events: auto;
      z-index: 1; /* Above SVG, below controls */
    }

    svg.overlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    /* Locus indicator lower-right */
    .hud {
      position: absolute;
      right: 10px;
      bottom: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      background: var(--hudBg);
      border: 1px solid var(--border2);
      font-size: 12px;
      color: var(--muted);
      backdrop-filter: blur(6px);
      pointer-events: none;
      white-space: nowrap;
      box-shadow: var(--shadow);
      display: none;
      transition: opacity 0.3s ease;
    }
    /* In vertical mode, position HUD in upper right */
    .main.vertical .hud {
      bottom: auto;
      top: 10px;
    }
    .hud.visible {
      display: block;
    }

    /* Tooltip */
    .tooltip {
      position: fixed;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--panel);
      border: 1px solid var(--border);
      font-size: 12px;
      color: var(--text);
      pointer-events: none;
      z-index: 1000;
      white-space: pre-line;
      box-shadow: var(--shadow);
      display: none;
      line-height: 1.4;
    }
    .tooltip.visible {
      display: block;
    }

    /* SVG text classes */
    .svg-label { fill: var(--muted); font-size: 12px; font-weight: 600; }
    .svg-small { fill: var(--muted2); font-size: 10px; }
    .svg-chr   { fill: var(--text); font-size: 12px; font-weight: 650; }

    .svg-geneName { fill: rgba(180,220,255,0.92); font-size: 11px; font-weight: 650; }
    html[data-theme="light"] .svg-geneName { fill: rgba(18, 110, 255, 0.92); }
    @media (prefers-color-scheme: light) {
      html[data-theme="auto"] .svg-geneName { fill: rgba(18, 110, 255, 0.92); }
    }
    @media (prefers-color-scheme: dark) {
      html[data-theme="auto"] .svg-geneName { fill: rgba(180,220,255,0.92); }
    }

    .svg-trackHint { fill: var(--muted2); font-size: 11px; }

    /* Track controls */
    .track-controls {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      height: 24px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 12px;
      background: rgba(127,127,127,0.03);
      border-bottom: 1px solid var(--border2);
      z-index: 10;
      cursor: move;
    }
    /* Smart track controls should allow button clicks */
    .track-controls button,
    .track-controls select {
      pointer-events: auto;
      z-index: 20;
    }
    .main.vertical .track-controls {
      top: auto;
    }
    .track-controls:hover { background: rgba(127,127,127,0.06); }

    .track-collapse-btn {
      width: 18px;
      height: 18px;
      border: none;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      padding: 0;
      border-radius: 4px;
      flex-shrink: 0;
    }
    .track-collapse-btn:hover { background: var(--panel2); color: var(--text); }
    .track-collapse-btn:active { transform: scale(0.95); }

    .track-label {
      flex: 1;
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
      user-select: none;
      pointer-events: none;
    }
    /* Smart track labels are clickable */
    .track-controls[data-track-id^="smart-track-"] .track-label {
      pointer-events: auto;
      cursor: text;
    }
    .track-controls[data-track-id^="smart-track-"] .track-label:hover {
      color: var(--text);
    }

    /* Vertical mode: track controls at bottom, vertically oriented */
    .main.vertical .track-control-container {
      position: absolute;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      align-items: flex-start;
    }
    .main.vertical .track-controls {
      width: 24px;
      height: 100%;
      flex-direction: column;
      padding: 0;
      border-bottom: none;
      border-right: 1px solid var(--border2);
      position: relative;
      left: 0;
      right: auto;
      transform: none;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      margin-bottom: 0;
    }
    .main.vertical .track-label {
      order: 1;
      white-space: nowrap;
      writing-mode: horizontal-tb;
      margin: 0;
      position: absolute;
      bottom: 0;
      left: 50%;
      transform-origin: left center;
      flex-shrink: 0;
      /* Default transform to prevent flash of unstyled content */
      transform: rotate(-90deg) translateX(12px) translateY(0.0px);
    }
    .main.vertical .track-collapse-btn {
      align-self: center;
      order: 2;
      margin-top: 0;
      margin-bottom: 0;
    }

    /* Smart track controls */
    .smart-track-label-input {
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
      background: var(--panel);
      border: 1px solid var(--border2);
      border-radius: 4px;
      padding: 2px 4px;
      outline: none;
    }
    .smart-track-label-input:focus {
      border-color: var(--blue);
      color: var(--text);
    }
    
    .smart-track-strategy-select {
      font-size: 11px;
      padding: 2px 4px;
      border: 1px solid var(--border2);
      border-radius: 4px;
      background: var(--panel);
      color: var(--text);
      cursor: pointer;
      outline: none;
    }
    .smart-track-strategy-select:hover {
      background: var(--panel2);
      border-color: var(--border);
    }
    .smart-track-strategy-select:focus {
      border-color: var(--blue);
    }
    
    .smart-track-reload-btn,
    .smart-track-shuffle-btn,
    .smart-track-close-btn {
      font-size: 16px;
      padding: 0;
      border: none;
      border-radius: 0;
      background: transparent;
      color: var(--muted);
      cursor: pointer;
      outline: none;
      transition: color 0.15s ease;
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    .smart-track-reload-btn:hover,
    .smart-track-shuffle-btn:hover {
      color: var(--text);
    }
    .smart-track-close-btn:hover {
      color: var(--text);
    }
    .smart-track-reload-btn:active,
    .smart-track-shuffle-btn:active {
      transform: scale(0.95);
    }
    .smart-track-close-btn:active {
      opacity: 0.7;
    }
    
    .smart-track-container {
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .smart-track-container canvas {
      pointer-events: none;
    }

    .track-resize-handle {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 6px;
      cursor: ns-resize;
      z-index: 15;
      background: transparent;
      pointer-events: auto;
    }
    .track-resize-handle:hover {
      background: var(--accent);
      opacity: 0.3;
    }
    .track-resize-handle:active {
      background: var(--accent);
      opacity: 0.6;
    }
    .main.vertical .track-resize-handle {
      left: auto;
      right: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      height: 100%;
      cursor: ew-resize;
    }

    .track-content {
      position: absolute;
      left: 0;
      right: 0;
      top: 24px;
      bottom: 0;
      overflow: hidden;
    }

    .track-control-container {
      pointer-events: none;
    }
    .track-control-container .track-controls,
    .track-control-container .track-resize-handle {
      pointer-events: auto;
    }

  </style>
</head>

<body>
  <div class="app" style="position: relative; display: block;">
    <div class="sidebar" id="sidebar" style="position: absolute; left: 0; top: 0; bottom: 0; width: 240px; z-index: 100; pointer-events: auto;">
      <div class="sidebarContent">
      <div style="display: none;">
        <div class="sidebarHeader">
          <h3>Participant groups</h3>
        </div>

        <div class="group"><span>AFR</span><span class="pill">2634</span></div>
        <div class="group"><span>AMR</span><span class="pill">603</span></div>
        <div class="group"><span>EAS</span><span class="pill">1095</span></div>
        <div class="group"><span>EUR</span><span class="pill">5340</span></div>
        <div class="group"><span>SAS</span><span class="pill">328</span></div>
      </div>

      <!-- Sample Search Section -->
      <div class="sidebarHeader" style="margin-top: 20px;">
        <h3>Sample Search</h3>
      </div>

      <div id="sampleSearchSection" style="padding: 9px 10px; margin: 7px 0; border-radius: 10px; background: var(--panel2); margin-bottom: 20px;">
        <input type="text" id="sampleSearchInput" placeholder="Load sample by ID…" style="width: 100%; padding: 6px 8px; border: 1px solid var(--border2); border-radius: 6px; background: var(--panel); color: var(--text); font-size: 12px; box-sizing: border-box;">
        <div id="sampleSearchResults" style="display: none; margin-top: 4px; max-height: 200px; overflow-y: auto; border: 1px solid var(--border2); border-radius: 6px; background: var(--panel);"></div>
      </div>

      <div class="sidebarHeader" style="margin-top: 20px;">
        <h3>Selection</h3>
      </div>

      <!-- Context Indicator -->
      <div id="sampleContext" style="padding: 9px 10px; margin: 7px 0; border-radius: 10px; background: var(--panel2); font-size: 11px; color: var(--muted); display: none;">
      </div>

      <!-- Strategy Selection Section -->
      <div id="sampleStrategySection" style="padding: 9px 10px; margin: 7px 0; border-radius: 10px; background: var(--panel2); display: none;">
        <!-- Strategy Dropdown -->
        <div style="margin-bottom: 8px;">
          <label style="display: block; font-size: 11px; color: var(--muted); margin-bottom: 4px;">Strategy</label>
          <select id="sampleStrategy" disabled style="width: 100%; padding: 6px 8px; border: 1px solid var(--border2); border-radius: 6px; background: var(--panel); color: var(--text); font-size: 12px;">
            <option value="best_evidence">Best evidence</option>
            <option value="most_diverse">Most diverse</option>
            <option value="compare_branches">Compare branches</option>
            <option value="carriers_controls">Carriers + controls</option>
            <option value="random">Random</option>
          </select>
        </div>
        
        <!-- Combine Selection Toggle (AND/OR) -->
        <div style="margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
          <label style="font-size: 11px; color: var(--muted);">Combine selection:</label>
          <div style="display: flex; gap: 4px; background: var(--panel); border: 1px solid var(--border2); border-radius: 6px; padding: 2px;">
            <button id="combineAnd" class="combineToggle active" style="padding: 4px 8px; font-size: 11px; border: none; background: transparent; color: var(--text); border-radius: 4px; cursor: pointer;">AND</button>
            <button id="combineOr" class="combineToggle" style="padding: 4px 8px; font-size: 11px; border: none; background: transparent; color: var(--muted); border-radius: 4px; cursor: pointer;">OR</button>
          </div>
        </div>
        
        <!-- Number of Samples Input -->
        <div style="margin-bottom: 8px;">
          <label style="display: block; font-size: 11px; color: var(--muted); margin-bottom: 4px;"># samples</label>
          <div style="display: flex; gap: 8px; align-items: center;">
            <input type="range" id="sampleCountSlider" min="1" max="20" value="1" disabled style="flex: 1;">
            <input type="number" id="sampleCountInput" min="1" max="20" value="1" disabled style="width: 50px; padding: 4px 6px; border: 1px solid var(--border2); border-radius: 4px; background: var(--panel); color: var(--text); font-size: 12px; text-align: center;">
          </div>
        </div>
        
        <!-- Load Buttons -->
        <div style="display: flex; gap: 6px; margin-bottom: 8px;">
          <button id="loadSamplesReplace" disabled class="selectionBtn" style="flex: 1; padding: 6px 10px; font-size: 12px;">Load</button>
          <button id="loadSamplesAdd" disabled class="selectionBtn" style="flex: 1; padding: 6px 10px; font-size: 12px; display: none;">Load (add)</button>
        </div>
        
        <!-- Preview -->
        <div id="samplePreview" style="font-size: 11px; color: var(--muted); padding-top: 8px; border-top: 1px solid var(--border2); display: none;">
          <div style="margin-bottom: 4px; color: var(--text);">Will load:</div>
          <div id="samplePreviewList" style="color: var(--text);"></div>
        </div>
      </div>

      <div class="menu" id="ctxMenu" role="menu" aria-hidden="true">
        <div class="menuTitle">Display</div>
        <div class="menuItem" id="themeItem" role="menuitem">
          <span>Theme<span class="menuHotkey">T</span></span>
          <span class="menuRight" id="themeLabel">Auto</span>
        </div>

        <div class="menuItem" id="orientationItem" role="menuitem">
          <span>Orientation<span class="menuHotkey">O</span></span>
          <span class="menuRight" id="orientationLabel">Horizontal</span>
        </div>

        <div class="menuItem" id="variantLayoutModeItem" role="menuitem">
          <span>Variant Layout<span class="menuHotkey">V</span></span>
          <span class="menuRight" id="variantLayoutModeLabel">Equidistant</span>
        </div>

        <div class="menuItem" id="fullscreenItem" role="menuitem">
          <span>Full screen<span class="menuHotkey">F</span></span>
          <span class="menuRight" id="fullscreenLabel">Enter full screen</span>
        </div>

        <div class="menuTitle">Grouping</div>
        <div class="menuItem" role="menuitem">
          <span>Variable</span>
          <span class="menuRight">Super-pop</span>
        </div>

        <div class="menuTitle">Data</div>
        <div class="menuItem" id="loadReadsItem" role="menuitem">
          <span>Load Reads<span class="menuHotkey">R</span></span>
          <span class="menuRight" id="loadReadsLabel">▶</span>
        </div>
      </div>
      </div>

      <button class="gearBtn" id="menuBtn" title="Settings" aria-label="Settings">⚙︎</button>
    </div>

    <div class="main" id="main" style="position: absolute; left: 240px; top: 0; right: 0; bottom: 0; z-index: 1;">
      <div class="tracks" id="tracksContainer">
        <svg id="tracksSvg" width="100%" height="100%"></svg>
        <canvas id="tracksWebGPU" class="webgpu-canvas" width="100%" height="100%"></canvas>
        <div id="trackControls"></div>
      </div>

      <div class="flow" id="flow">
        <canvas class="canvas" id="flowCanvas"></canvas>
        <canvas id="flowWebGPU" class="webgpu-canvas" width="100%" height="100%"></canvas>
        <svg class="overlay" id="flowOverlay"></svg>
      </div>

      <div class="reads" id="reads">
        <canvas class="canvas" id="readsCanvas"></canvas>
        <canvas id="readsWebGPU" class="webgpu-canvas" width="100%" height="100%"></canvas>
        <svg class="overlay" id="readsOverlay"></svg>
      </div>

      <div class="hud" id="hud"></div>
      <div class="tooltip" id="tooltip"></div>
    </div>
  </div>

<script type="module">
  // -----------------------------
  // Clean up any stale overlays from previous sessions
  // -----------------------------
  (function cleanupStaleOverlays() {
    const staleOverlays = document.querySelectorAll('[id^="genomeshader-overlay-"]');
    staleOverlays.forEach(overlay => {
      console.log(`Cleaning up stale overlay: ${overlay.id}`);
      overlay.remove();
    });
  })();

  // -----------------------------
  // WebGPU Classes (inlined to avoid module import issues with blob URLs)
  // -----------------------------
  class WebGPUCore {
    constructor() {
      this.device = null;
      this.context = null;
      this.canvas = null;
      this.format = null;
      this.projectionMatrix = null;
      this.screenSize = null;
      this.projectionBuffer = null;
    }

    async init(canvas) {
      if (!navigator.gpu) {
        throw new Error('WebGPU is not supported in this browser');
      }

      this.canvas = canvas;
      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) {
        throw new Error('Failed to get WebGPU adapter');
      }

      this.device = await adapter.requestDevice();
      this.format = navigator.gpu.getPreferredCanvasFormat();
      
      this.context = canvas.getContext('webgpu');
      if (!this.context) {
        throw new Error('Failed to get WebGPU context');
      }

      const devicePixelRatio = window.devicePixelRatio || 1;
      const width = canvas.clientWidth * devicePixelRatio;
      const height = canvas.clientHeight * devicePixelRatio;

      this.context.configure({
        device: this.device,
        format: this.format,
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
        alphaMode: 'premultiplied',
      });

      // Create projection matrix buffer (orthographic 2D projection)
      this.projectionMatrix = new Float32Array([
        2.0 / width, 0, 0, 0,
        0, -2.0 / height, 0, 0,
        0, 0, 1, 0,
        -1, 1, 0, 1
      ]);
      
      // Pad vec2 to vec4 for 16-byte alignment (vec2 = 8 bytes, needs padding to 16)
      this.screenSize = new Float32Array([width, height, 0, 0]);

      this.projectionBuffer = this.device.createBuffer({
        size: (16 + 4) * 4, // mat4x4 (16 floats) + vec4 padded (4 floats) = 20 floats * 4 bytes = 80 bytes
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      });

      // Write projection matrix and screen size to buffer
      this.device.queue.writeBuffer(this.projectionBuffer, 0, this.projectionMatrix);
      this.device.queue.writeBuffer(this.projectionBuffer, 16 * 4, this.screenSize);

      // Handle resize
      window.addEventListener('resize', () => this.handleResize());
    }

    handleResize() {
      if (!this.canvas || !this.context) return;

      const devicePixelRatio = window.devicePixelRatio || 1;
      const width = this.canvas.clientWidth * devicePixelRatio;
      const height = this.canvas.clientHeight * devicePixelRatio;

      // Update canvas size
      this.canvas.width = width;
      this.canvas.height = height;

      // Update projection matrix
      this.projectionMatrix[0] = 2.0 / width;
      this.projectionMatrix[5] = -2.0 / height;
      this.projectionMatrix[12] = -1;
      this.projectionMatrix[13] = 1;
      
      // Update screen size (vec4 padded)
      this.screenSize[0] = width;
      this.screenSize[1] = height;
      this.screenSize[2] = 0;
      this.screenSize[3] = 0;

      this.device.queue.writeBuffer(this.projectionBuffer, 0, this.projectionMatrix);
      this.device.queue.writeBuffer(this.projectionBuffer, 16 * 4, this.screenSize);
    }

    getCurrentTexture() {
      return this.context.getCurrentTexture();
    }

    createCommandEncoder() {
      return this.device.createCommandEncoder();
    }

    submit(commands) {
      this.device.queue.submit(commands);
    }
  }

  class InstancedRenderer {
    constructor(webgpuCore) {
      this.core = webgpuCore;
      this.device = webgpuCore.device;
      
      // Rectangle rendering
      this.rectPipeline = null;
      this.rectInstances = [];
      this.rectBuffer = null;
      this.rectVertexBuffer = null;
      
      // Triangle rendering
      this.trianglePipeline = null;
      this.triangleInstances = [];
      this.triangleBuffer = null;
      this.triangleVertexBuffer = null;
      
      // Line rendering
      this.linePipeline = null;
      this.lineInstances = [];
      this.lineBuffer = null;
      
      this.init();
    }

    init() {
      this.createRectPipeline();
      this.createTrianglePipeline();
      this.createLinePipeline();
      this.createGeometryBuffers();
    }

    // Convert hex color to normalized RGBA
    hexToRgba(hex, alpha = 1.0) {
      if (typeof hex === 'string') {
        if (hex.startsWith('#')) {
          hex = hex.slice(1);
        }
        const r = parseInt(hex.slice(0, 2), 16) / 255;
        const g = parseInt(hex.slice(2, 4), 16) / 255;
        const b = parseInt(hex.slice(4, 6), 16) / 255;
        return [r, g, b, alpha];
      } else {
        // Assume it's a number (0xRRGGBB)
        const r = ((hex >> 16) & 0xFF) / 255;
        const g = ((hex >> 8) & 0xFF) / 255;
        const b = (hex & 0xFF) / 255;
        return [r, g, b, alpha];
      }
    }

    createRectPipeline() {
      const vertexShader = `
        struct Uniforms {
          projection: mat4x4<f32>,
          screenSize: vec2<f32>,
          _padding: vec2<f32>, // Padding for 16-byte alignment
        }
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        struct VertexOutput {
          @builtin(position) position: vec4<f32>,
          @location(1) @interpolate(flat) instanceMin: vec2<f32>,
          @location(2) @interpolate(flat) instanceMax: vec2<f32>,
          @location(3) @interpolate(flat) color: vec4<f32>,
        }

        @vertex
        fn vs_main(
          @builtin(vertex_index) vertexIndex: u32,
          @builtin(instance_index) instanceIndex: u32,
          @location(0) position: vec2<f32>,
          @location(1) size: vec2<f32>,
          @location(2) color: vec4<f32>
        ) -> VertexOutput {
          // Quad vertices: (-0.5, -0.5), (0.5, -0.5), (-0.5, 0.5), (0.5, 0.5)
          var quadPos = vec2<f32>(0.0);
          if (vertexIndex == 0u) {
            quadPos = vec2<f32>(-0.5, -0.5);
          } else if (vertexIndex == 1u) {
            quadPos = vec2<f32>(0.5, -0.5);
          } else if (vertexIndex == 2u) {
            quadPos = vec2<f32>(-0.5, 0.5);
          } else {
            quadPos = vec2<f32>(0.5, 0.5);
          }
          
          var worldPos = position + quadPos * size;
          var halfSize = size * 0.5;
          var output: VertexOutput;
          output.position = uniforms.projection * vec4<f32>(worldPos, 0.0, 1.0);
          output.instanceMin = position - halfSize;
          output.instanceMax = position + halfSize;
          output.color = color;
          return output;
        }
      `;

      const fragmentShader = `
        struct Uniforms {
          projection: mat4x4<f32>,
          screenSize: vec2<f32>,
          _padding: vec2<f32>, // Padding for 16-byte alignment
        }
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        @fragment
        fn fs_main(
          @builtin(position) fragCoord: vec4<f32>,
          @location(1) @interpolate(flat) instanceMin: vec2<f32>,
          @location(2) @interpolate(flat) instanceMax: vec2<f32>,
          @location(3) @interpolate(flat) color: vec4<f32>
        ) -> @location(0) vec4<f32> {
          // fragCoord.xy is in framebuffer pixel coordinates (not NDC)
          // This directly matches our world coordinates since we use an orthographic projection
          let worldPos = fragCoord.xy;
          
          // Get rectangle dimensions and center
          let size = instanceMax - instanceMin;
          let center = (instanceMin + instanceMax) * 0.5;
          let halfSize = size * 0.5;
          let minDim = min(size.x, size.y);
          
          // For very small rectangles (< 6px), don't apply rounding or stroke
          if (minDim < 6.0) {
            // Still need premultiplied alpha for correct blending
            return vec4<f32>(color.rgb * color.a, color.a);
          }
          
          // Apply rounded corners with radius 4 pixels (matching SVG rx=4)
          let radius = 4.0;
          let actualRadius = min(radius, minDim * 0.5);
          
          // Proper rounded rectangle SDF
          // Calculate position relative to center
          let p = abs(worldPos - center);
          // Shrink the half-size by radius to get the inner rectangle
          let q = p - halfSize + actualRadius;
          // Distance to rounded rectangle: negative inside, positive outside
          let d = length(max(q, vec2<f32>(0.0))) + min(max(q.x, q.y), 0.0) - actualRadius;
          
          // Stroke width of 1 pixel
          let strokeWidth = 1.0;
          
          // Determine if we're in stroke region or fill region
          // d < -strokeWidth: inside fill region
          // -strokeWidth <= d < 0: in stroke region
          // d >= 0: outside
          
          // Check if this is a "stroke-enabled" rectangle by looking at alpha
          // If alpha > 0.5, it's a stroke rectangle (higher opacity = stroke color)
          // If alpha <= 0.5, it's a fill rectangle (lower opacity = fill color)
          let isStrokeRect = color.a > 0.5;
          
          if (isStrokeRect) {
            // This is a stroke-only rectangle: only render pixels in the stroke band
            // Stroke band is from d = -strokeWidth to d = 0
            let strokeAlpha = smoothstep(-strokeWidth - 0.5, -strokeWidth + 0.5, d) * (1.0 - smoothstep(-0.5, 0.5, d));
            let finalAlpha = color.a * strokeAlpha;
            return vec4<f32>(color.rgb * finalAlpha, finalAlpha);
          } else {
            // This is a fill rectangle: render the interior (up to but not including stroke)
            // Fill region is where d < -strokeWidth
            let fillAlpha = 1.0 - smoothstep(-strokeWidth - 0.5, -strokeWidth + 0.5, d);
            let finalAlpha = color.a * fillAlpha;
            return vec4<f32>(color.rgb * finalAlpha, finalAlpha);
          }
        }
      `;

      const vertexModule = this.device.createShaderModule({ code: vertexShader });
      const fragmentModule = this.device.createShaderModule({ code: fragmentShader });

      this.rectPipeline = this.device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: vertexModule,
          entryPoint: 'vs_main',
          buffers: [
            {
              arrayStride: 8 * 4, // position(8) + size(8) + color(16) = 32 bytes
              stepMode: 'instance',
              attributes: [
                { shaderLocation: 0, offset: 0, format: 'float32x2' }, // position
                { shaderLocation: 1, offset: 8, format: 'float32x2' }, // size
                { shaderLocation: 2, offset: 16, format: 'float32x4' }, // color
              ],
            },
          ],
        },
        fragment: {
          module: fragmentModule,
          entryPoint: 'fs_main',
          targets: [{
            format: this.core.format,
            blend: {
              color: {
                srcFactor: 'one',
                dstFactor: 'one-minus-src-alpha',
                operation: 'add',
              },
              alpha: {
                srcFactor: 'one',
                dstFactor: 'one-minus-src-alpha',
                operation: 'add',
              },
            },
          }],
        },
        primitive: {
          topology: 'triangle-strip',
        },
      });
    }

    createTrianglePipeline() {
      const vertexShader = `
        struct Uniforms {
          projection: mat4x4<f32>,
        }
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        struct VertexOutput {
          @builtin(position) position: vec4<f32>,
          @location(3) @interpolate(flat) color: vec4<f32>,
        }

        @vertex
        fn vs_main(
          @builtin(vertex_index) vertexIndex: u32,
          @builtin(instance_index) instanceIndex: u32,
          @location(0) v0: vec2<f32>,
          @location(1) v1: vec2<f32>,
          @location(2) v2: vec2<f32>,
          @location(3) color: vec4<f32>
        ) -> VertexOutput {
          var pos: vec2<f32>;
          if (vertexIndex == 0u) {
            pos = v0;
          } else if (vertexIndex == 1u) {
            pos = v1;
          } else {
            pos = v2;
          }
          var output: VertexOutput;
          output.position = uniforms.projection * vec4<f32>(pos, 0.0, 1.0);
          output.color = color;
          return output;
        }
      `;

      const fragmentShader = `
        @fragment
        fn fs_main(
          @location(3) @interpolate(flat) color: vec4<f32>
        ) -> @location(0) vec4<f32> {
          return color;
        }
      `;

      const vertexModule = this.device.createShaderModule({ code: vertexShader });
      const fragmentModule = this.device.createShaderModule({ code: fragmentShader });

      this.trianglePipeline = this.device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: vertexModule,
          entryPoint: 'vs_main',
          buffers: [
            {
              arrayStride: 10 * 4, // v0(8) + v1(8) + v2(8) + color(16) = 40 bytes = 10 floats
              stepMode: 'instance',
              attributes: [
                { shaderLocation: 0, offset: 0, format: 'float32x2' }, // v0
                { shaderLocation: 1, offset: 8, format: 'float32x2' }, // v1
                { shaderLocation: 2, offset: 16, format: 'float32x2' }, // v2
                { shaderLocation: 3, offset: 24, format: 'float32x4' }, // color
              ],
            },
          ],
        },
        fragment: {
          module: fragmentModule,
          entryPoint: 'fs_main',
          targets: [{
            format: this.core.format,
            blend: {
              color: {
                srcFactor: 'src-alpha',
                dstFactor: 'one-minus-src-alpha',
                operation: 'add',
              },
              alpha: {
                srcFactor: 'one',
                dstFactor: 'one-minus-src-alpha',
                operation: 'add',
              },
            },
          }],
        },
        primitive: {
          topology: 'triangle-list',
        },
      });
    }

    createLinePipeline() {
      const vertexShader = `
        struct Uniforms {
          projection: mat4x4<f32>,
        }
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        struct VertexOutput {
          @builtin(position) position: vec4<f32>,
          @location(2) @interpolate(flat) color: vec4<f32>,
        }

        @vertex
        fn vs_main(
          @builtin(vertex_index) vertexIndex: u32,
          @builtin(instance_index) instanceIndex: u32,
          @location(0) start: vec2<f32>,
          @location(1) end: vec2<f32>,
          @location(2) color: vec4<f32>
        ) -> VertexOutput {
          var pos: vec2<f32>;
          if (vertexIndex == 0u) {
            pos = start;
          } else {
            pos = end;
          }
          var output: VertexOutput;
          output.position = uniforms.projection * vec4<f32>(pos, 0.0, 1.0);
          output.color = color;
          return output;
        }
      `;

      const fragmentShader = `
        @fragment
        fn fs_main(
          @location(2) @interpolate(flat) color: vec4<f32>
        ) -> @location(0) vec4<f32> {
          return color;
        }
      `;

      const vertexModule = this.device.createShaderModule({ code: vertexShader });
      const fragmentModule = this.device.createShaderModule({ code: fragmentShader });

      this.linePipeline = this.device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: vertexModule,
          entryPoint: 'vs_main',
          buffers: [
            {
              arrayStride: 8 * 4, // start(8) + end(8) + color(16) = 32 bytes
              stepMode: 'instance',
              attributes: [
                { shaderLocation: 0, offset: 0, format: 'float32x2' }, // start
                { shaderLocation: 1, offset: 8, format: 'float32x2' }, // end
                { shaderLocation: 2, offset: 16, format: 'float32x4' }, // color
              ],
            },
          ],
        },
        fragment: {
          module: fragmentModule,
          entryPoint: 'fs_main',
          targets: [{
            format: this.core.format,
            blend: {
              color: {
                srcFactor: 'src-alpha',
                dstFactor: 'one-minus-src-alpha',
                operation: 'add',
              },
              alpha: {
                srcFactor: 'one',
                dstFactor: 'one-minus-src-alpha',
                operation: 'add',
              },
            },
          }],
        },
        primitive: {
          topology: 'line-list',
        },
      });
    }

    createGeometryBuffers() {
      // Rectangle uses triangle-strip, no vertex buffer needed (generated in shader)
      // Triangle uses triangle-list, no vertex buffer needed (generated in shader)
      // Line uses line-list, no vertex buffer needed (generated in shader)
    }

    // Add rectangle instance
    // color can be: hex string (e.g., "#FF0000"), hex number, or rgba array [r, g, b, a]
    addRect(x, y, width, height, color, alpha = 1.0) {
      let rgba;
      if (Array.isArray(color) && color.length >= 3) {
        // Already an rgba array
        rgba = color.length === 4 ? color : [...color, alpha];
      } else {
        // Convert hex to rgba
        rgba = this.hexToRgba(color, alpha);
      }
      this.rectInstances.push({
        position: [x + width / 2, y + height / 2], // center position
        size: [width, height],
        color: rgba,
      });
    }

    // Add triangle instance
    addTriangle(x0, y0, x1, y1, x2, y2, color, alpha = 1.0) {
      const rgba = this.hexToRgba(color, alpha);
      this.triangleInstances.push({
        v0: [x0, y0],
        v1: [x1, y1],
        v2: [x2, y2],
        color: rgba,
      });
    }

    // Add line instance
    addLine(x0, y0, x1, y1, color, alpha = 1.0) {
      const rgba = this.hexToRgba(color, alpha);
      this.lineInstances.push({
        start: [x0, y0],
        end: [x1, y1],
        color: rgba,
      });
    }

    // Clear all instances
    clear() {
      this.rectInstances = [];
      this.triangleInstances = [];
      this.lineInstances = [];
    }

    // Render all instances
    render(encoder, renderPass) {
      // Create uniform bind group (same layout for all pipelines)
      const uniformBindGroupLayout = this.rectPipeline.getBindGroupLayout(0);
      const uniformBindGroup = this.device.createBindGroup({
        layout: uniformBindGroupLayout,
        entries: [
          {
            binding: 0,
            resource: {
              buffer: this.core.projectionBuffer,
            },
          },
        ],
      });

      // Render rectangles
      if (this.rectInstances.length > 0) {
        const instanceData = new Float32Array(this.rectInstances.length * 8);
        for (let i = 0; i < this.rectInstances.length; i++) {
          const inst = this.rectInstances[i];
          const offset = i * 8;
          instanceData[offset + 0] = inst.position[0];
          instanceData[offset + 1] = inst.position[1];
          instanceData[offset + 2] = inst.size[0];
          instanceData[offset + 3] = inst.size[1];
          instanceData[offset + 4] = inst.color[0];
          instanceData[offset + 5] = inst.color[1];
          instanceData[offset + 6] = inst.color[2];
          instanceData[offset + 7] = inst.color[3];
        }

        if (!this.rectBuffer || this.rectBuffer.size < instanceData.byteLength) {
          if (this.rectBuffer) this.rectBuffer.destroy();
          this.rectBuffer = this.device.createBuffer({
            size: instanceData.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          });
        }

        this.device.queue.writeBuffer(this.rectBuffer, 0, instanceData);

        renderPass.setPipeline(this.rectPipeline);
        renderPass.setBindGroup(0, uniformBindGroup);
        renderPass.setVertexBuffer(0, this.rectBuffer);
        renderPass.draw(4, this.rectInstances.length); // 4 vertices per quad
      }

      // Render triangles
      if (this.triangleInstances.length > 0) {
        // v0(2) + v1(2) + v2(2) + color(4) = 10 floats per instance
        const instanceData = new Float32Array(this.triangleInstances.length * 10);
        for (let i = 0; i < this.triangleInstances.length; i++) {
          const inst = this.triangleInstances[i];
          const offset = i * 10;
          instanceData[offset + 0] = inst.v0[0];
          instanceData[offset + 1] = inst.v0[1];
          instanceData[offset + 2] = inst.v1[0];
          instanceData[offset + 3] = inst.v1[1];
          instanceData[offset + 4] = inst.v2[0];
          instanceData[offset + 5] = inst.v2[1];
          instanceData[offset + 6] = inst.color[0];
          instanceData[offset + 7] = inst.color[1];
          instanceData[offset + 8] = inst.color[2];
          instanceData[offset + 9] = inst.color[3];
        }

        if (!this.triangleBuffer || this.triangleBuffer.size < instanceData.byteLength) {
          if (this.triangleBuffer) this.triangleBuffer.destroy();
          this.triangleBuffer = this.device.createBuffer({
            size: instanceData.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          });
        }

        this.device.queue.writeBuffer(this.triangleBuffer, 0, instanceData);

        const triangleUniformBindGroup = this.device.createBindGroup({
          layout: this.trianglePipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: this.core.projectionBuffer,
              },
            },
          ],
        });
        
        renderPass.setPipeline(this.trianglePipeline);
        renderPass.setBindGroup(0, triangleUniformBindGroup);
        renderPass.setVertexBuffer(0, this.triangleBuffer);
        renderPass.draw(3, this.triangleInstances.length); // 3 vertices per triangle
      }

      // Render lines
      if (this.lineInstances.length > 0) {
        const instanceData = new Float32Array(this.lineInstances.length * 8);
        for (let i = 0; i < this.lineInstances.length; i++) {
          const inst = this.lineInstances[i];
          const offset = i * 8;
          instanceData[offset + 0] = inst.start[0];
          instanceData[offset + 1] = inst.start[1];
          instanceData[offset + 2] = inst.end[0];
          instanceData[offset + 3] = inst.end[1];
          instanceData[offset + 4] = inst.color[0];
          instanceData[offset + 5] = inst.color[1];
          instanceData[offset + 6] = inst.color[2];
          instanceData[offset + 7] = inst.color[3];
        }

        if (!this.lineBuffer || this.lineBuffer.size < instanceData.byteLength) {
          if (this.lineBuffer) this.lineBuffer.destroy();
          this.lineBuffer = this.device.createBuffer({
            size: instanceData.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          });
        }

        this.device.queue.writeBuffer(this.lineBuffer, 0, instanceData);

        const lineUniformBindGroup = this.device.createBindGroup({
          layout: this.linePipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: this.core.projectionBuffer,
              },
            },
          ],
        });
        
        renderPass.setPipeline(this.linePipeline);
        renderPass.setBindGroup(0, lineUniformBindGroup);
        renderPass.setVertexBuffer(0, this.lineBuffer);
        renderPass.draw(2, this.lineInstances.length); // 2 vertices per line
      }
    }

    // Get rendering statistics
    getStats() {
      return {
        rectangles: this.rectInstances.length,
        triangles: this.triangleInstances.length,
        lines: this.lineInstances.length,
        totalPolygons: this.rectInstances.length + this.triangleInstances.length + this.lineInstances.length,
      };
    }
  }

  // ------------------------------------------------------------
  // WebGPU: Instanced cubic Bezier ribbon renderer (Sankey ribbons)
  // ------------------------------------------------------------
  class BezierRibbonRenderer {
    constructor(webgpuCore, opts = {}) {
      this.core = webgpuCore;
      this.device = webgpuCore.device;

      this.segments = Math.max(8, Math.min(128, opts.segments ?? 40)); // smooth, not too heavy
      this.pipeline = null;
      this.bindGroup = null;

      this.instances = [];
      this.instanceBuffer = null;

      this._init();
    }

    clear() {
      this.instances.length = 0;
    }

    // Instance layout (Float32):
    // topP0.xy topP1.xy topP2.xy topP3.xy  (8 floats)
    // botP0.xy botP1.xy botP2.xy botP3.xy  (8 floats)
    // color.rgba (4 floats)
    addRibbon(topP0, topP1, topP2, topP3, botP0, botP1, botP2, botP3, colorRgba) {
      // Basic validity guard
      if (!isFinite(topP0[0]) || !isFinite(topP0[1]) || !isFinite(topP3[0]) || !isFinite(topP3[1])) return;
      if (!isFinite(botP0[0]) || !isFinite(botP0[1]) || !isFinite(botP3[0]) || !isFinite(botP3[1])) return;

      this.instances.push({
        topP0, topP1, topP2, topP3,
        botP0, botP1, botP2, botP3,
        color: colorRgba,
      });
    }

    _init() {
      const wgsl = `
        struct Uniforms {
          projection: mat4x4<f32>,
          screenSize: vec2<f32>,
          _pad: vec2<f32>,
        };
        @group(0) @binding(0) var<uniform> uniforms: Uniforms;

        struct VSOut {
          @builtin(position) position: vec4<f32>,
          @location(0) color: vec4<f32>,
        };

        fn bezier(p0: vec2<f32>, p1: vec2<f32>, p2: vec2<f32>, p3: vec2<f32>, t: f32) -> vec2<f32> {
          let omt = 1.0 - t;
          return (omt*omt*omt)*p0 +
                 (3.0*omt*omt*t)*p1 +
                 (3.0*omt*t*t)*p2 +
                 (t*t*t)*p3;
        }

        @vertex
        fn vs_main(
          @builtin(vertex_index) vid: u32,
          @builtin(instance_index) iid: u32,

          // Top boundary control points
          @location(0) topP0: vec2<f32>,
          @location(1) topP1: vec2<f32>,
          @location(2) topP2: vec2<f32>,
          @location(3) topP3: vec2<f32>,

          // Bottom boundary control points
          @location(4) botP0: vec2<f32>,
          @location(5) botP1: vec2<f32>,
          @location(6) botP2: vec2<f32>,
          @location(7) botP3: vec2<f32>,

          // Premultiplied-alpha color is done in FS
          @location(8) color: vec4<f32>,
        ) -> VSOut {
          // Triangle strip: for each segment s, emit [top(s), bottom(s)]
          // vid: 0 top(0), 1 bot(0), 2 top(1), 3 bot(1), ...
          let side: u32 = vid & 1u;         // 0 = top, 1 = bottom
          let s: u32 = vid >> 1u;           // segment index
          let denom: f32 = f32(${this.segments - 1});
          let t: f32 = select(0.0, f32(s) / denom, denom > 0.0);

          var p: vec2<f32>;
          if (side == 0u) {
            p = bezier(topP0, topP1, topP2, topP3, t);
          } else {
            p = bezier(botP0, botP1, botP2, botP3, t);
          }

          var out: VSOut;
          out.position = uniforms.projection * vec4<f32>(p, 0.0, 1.0);
          out.color = color;
          return out;
        }

        @fragment
        fn fs_main(in: VSOut) -> @location(0) vec4<f32> {
          // premultiply for correct blending
          let a = in.color.a;
          return vec4<f32>(in.color.rgb * a, a);
        }
      `;

      const module = this.device.createShaderModule({ code: wgsl });

      this.pipeline = this.device.createRenderPipeline({
        layout: "auto",
        vertex: {
          module,
          entryPoint: "vs_main",
          buffers: [
            {
              stepMode: "instance",
              arrayStride: (8 + 8 + 4) * 4, // 20 floats
              attributes: [
                { shaderLocation: 0, offset:  0 * 4, format: "float32x2" }, // topP0
                { shaderLocation: 1, offset:  2 * 4, format: "float32x2" }, // topP1
                { shaderLocation: 2, offset:  4 * 4, format: "float32x2" }, // topP2
                { shaderLocation: 3, offset:  6 * 4, format: "float32x2" }, // topP3

                { shaderLocation: 4, offset:  8 * 4, format: "float32x2" }, // botP0
                { shaderLocation: 5, offset: 10 * 4, format: "float32x2" }, // botP1
                { shaderLocation: 6, offset: 12 * 4, format: "float32x2" }, // botP2
                { shaderLocation: 7, offset: 14 * 4, format: "float32x2" }, // botP3

                { shaderLocation: 8, offset: 16 * 4, format: "float32x4" }, // color
              ],
            },
          ],
        },
        fragment: {
          module,
          entryPoint: "fs_main",
          targets: [{
            format: this.core.format,
            blend: {
              color: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
              alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
            },
          }],
        },
        primitive: { topology: "triangle-strip" },
      });

      this.bindGroup = this.device.createBindGroup({
        layout: this.pipeline.getBindGroupLayout(0),
        entries: [{ binding: 0, resource: { buffer: this.core.projectionBuffer } }],
      });
    }

    _ensureInstanceBuffer() {
      const neededFloats = this.instances.length * 20;
      const neededBytes = neededFloats * 4;
      if (!this.instanceBuffer || this.instanceBuffer.size < neededBytes) {
        // Over-allocate a bit to reduce realloc churn
        const allocBytes = Math.max(neededBytes, (this.instanceBuffer?.size ?? 0) * 2, 64 * 1024);
        this.instanceBuffer = this.device.createBuffer({
          size: allocBytes,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });
      }
    }

    render(encoder, renderPass) {
      if (!this.pipeline || this.instances.length === 0) return;

      this._ensureInstanceBuffer();

      // Pack instances -> Float32Array
      const data = new Float32Array(this.instances.length * 20);
      let o = 0;
      for (const inst of this.instances) {
        const push2 = (p) => { data[o++] = p[0]; data[o++] = p[1]; };
        push2(inst.topP0); push2(inst.topP1); push2(inst.topP2); push2(inst.topP3);
        push2(inst.botP0); push2(inst.botP1); push2(inst.botP2); push2(inst.botP3);
        data[o++] = inst.color[0]; data[o++] = inst.color[1]; data[o++] = inst.color[2]; data[o++] = inst.color[3];
      }

      this.device.queue.writeBuffer(this.instanceBuffer, 0, data);

      renderPass.setPipeline(this.pipeline);
      renderPass.setBindGroup(0, this.bindGroup);
      renderPass.setVertexBuffer(0, this.instanceBuffer);

      const vertexCount = this.segments * 2;
      renderPass.draw(vertexCount, this.instances.length, 0, 0);
    }
  }

  // -----------------------------
  // Genomeshader bootstrap
  // -----------------------------
  // Determine host mode (inline or popup)
  const hostMode = (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.hostMode) || 'inline';

  // -----------------------------
  // Jupyter Comms (Classic Notebook) - Optimized
  // -----------------------------
  // Python registers a comm target 'genomeshader'
  // We create a comm from JS to connect to it (lazy initialization)
  
  let genomeshaderComm = null;
  let jupyterKernel = null; // Cache kernel reference
  const pendingCommRequests = new Map();
  let commInitialized = false;
  
  // Lazy initialization: only set up comm when actually needed
  function ensureCommReady() {
    if (commInitialized || genomeshaderComm) {
      return Promise.resolve(genomeshaderComm);
    }
    
    return new Promise(function(resolve, reject) {
      const commAvailable = window.GENOMESHADER_CONFIG?.comm_available;
      if (!commAvailable) {
        reject(new Error('Comms not available'));
        return;
      }
      
      // Use cached kernel if available
      if (jupyterKernel) {
        setupComm(jupyterKernel).then(resolve).catch(reject);
        return;
      }
      
      // Try to get kernel (cached or load)
      if (typeof Jupyter !== 'undefined' && Jupyter.notebook && Jupyter.notebook.kernel) {
        jupyterKernel = Jupyter.notebook.kernel;
        setupComm(jupyterKernel).then(resolve).catch(reject);
      } else if (typeof require !== 'undefined') {
        // Load Jupyter namespace once and cache it
        require(['base/js/namespace'], function(Jupyter) {
          if (Jupyter && Jupyter.notebook && Jupyter.notebook.kernel) {
            jupyterKernel = Jupyter.notebook.kernel;
            setupComm(jupyterKernel).then(resolve).catch(reject);
          } else {
            reject(new Error('Kernel not available'));
          }
        }, reject);
      } else {
        reject(new Error('Jupyter not available'));
      }
    });
  }
  
  function setupComm(kernel) {
    return new Promise(function(resolve, reject) {
      try {
        const comm = kernel.comm_manager.new_comm('genomeshader', {
          view_id: window.GENOMESHADER_VIEW_ID
        });
        
        comm.on_msg(function(msg) {
          const data = msg.content.data;
          
          // Handle pending requests
          const request = pendingCommRequests.get(data.request_id);
          if (request) {
            pendingCommRequests.delete(data.request_id);
            request.resolve(data);
          }
          
          // Dispatch event for other listeners
          document.dispatchEvent(new CustomEvent('genomeshader_msg', { detail: data }));
        });
        
        genomeshaderComm = comm;
        commInitialized = true;
        resolve(comm);
      } catch (err) {
        reject(err);
      }
    });
  }
  
  function sendCommMessage(type, data, timeoutMs) {
    return ensureCommReady().then(function(comm) {
      return new Promise(function(resolve, reject) {
        const requestId = 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        pendingCommRequests.set(requestId, { resolve: resolve, reject: reject });
        
        comm.send({
          type: type,
          request_id: requestId,
          ...data
        });
        
        // Timeout - use longer timeout for fetch_reads (120 seconds), default 30 seconds
        const timeout = timeoutMs || (type === 'fetch_reads' ? 120000 : 30000);
        setTimeout(function() {
          if (pendingCommRequests.has(requestId)) {
            pendingCommRequests.delete(requestId);
            reject(new Error('Request timeout'));
          }
        }, timeout);
      });
    });
  }
  
  // Defer comm initialization until after visualization renders
  // Use requestAnimationFrame to ensure rendering happens first
  function initCommLazy() {
    // Wait for visualization to render first
    requestAnimationFrame(function() {
      requestAnimationFrame(function() {
        // Initialize comm in background (non-blocking)
        ensureCommReady().catch(function() {
          // Silently fail - comm is optional
        });
      });
    });
  }
  
  // Start lazy initialization after a short delay
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(initCommLazy, 1000); // Wait 1s for visualization to render
    });
  } else {
    setTimeout(initCommLazy, 1000);
  }
  
  // -----------------------------
  // On-demand Read Loading
  // -----------------------------
  // Reads data storage
  let readsData = null;           // Raw reads from Python (array of read objects)
  let loadedReadsLayout = null;   // Processed layout with row assignments
  let readsLoading = false;       // Loading state
  
  // Process raw reads data into a layout structure
  function processReadsData(rawReads) {
    if (!rawReads || !rawReads.query_name) return null;
    
    // Convert column-oriented data to row-oriented
    const numRows = rawReads.query_name.length;
    const reads = [];
    
    // Group by query_name to get unique reads (element_type 0 = READ)
    const readMap = new Map();
    for (let i = 0; i < numRows; i++) {
      if (rawReads.element_type[i] === 0) { // READ element
        const name = rawReads.query_name[i];
        if (!readMap.has(name)) {
          readMap.set(name, {
            name: name,
            start: rawReads.reference_start[i],
            end: rawReads.reference_end[i],
            isForward: rawReads.is_forward[i],
            haplotype: rawReads.haplotype[i],
            sample: rawReads.sample_name[i],
            elements: []
          });
        }
      }
    }
    
    // Add non-read elements (insertions, deletions, etc.)
    for (let i = 0; i < numRows; i++) {
      const name = rawReads.query_name[i];
      const read = readMap.get(name);
      if (read && rawReads.element_type[i] !== 0) {
        read.elements.push({
          type: rawReads.element_type[i],
          start: rawReads.reference_start[i],
          end: rawReads.reference_end[i],
          sequence: rawReads.sequence[i]
        });
      }
    }
    
    // Convert to array and sort by start position
    const readArray = Array.from(readMap.values());
    readArray.sort((a, b) => a.start - b.start);
    
    // Improved greedy packing: assign reads to rows, checking if read fits anywhere in each row
    const rows = [];
    for (const read of readArray) {
      let placed = false;
      // Try to place in existing rows
      for (let r = 0; r < rows.length; r++) {
        // Check if read can fit in this row (doesn't overlap with any existing read)
        let canFit = true;
        for (const existingRead of rows[r]) {
          // Check for overlap: read overlaps if it starts before existing ends and ends after existing starts
          if (!(read.end < existingRead.start - 10 || read.start > existingRead.end + 10)) {
            canFit = false;
            break;
          }
        }
        if (canFit) {
          read.row = r;
          rows[r].push(read);
          // Keep row sorted by start position for better packing
          rows[r].sort((a, b) => a.start - b.start);
          placed = true;
          break;
        }
      }
      if (!placed) {
        read.row = rows.length;
        rows.push([read]);
      }
    }
    
    // Only log in debug mode or for first few calls to avoid console spam
    // console.log('Genomeshader: Processed ' + readArray.length + ' reads into ' + rows.length + ' rows');
    return { reads: readArray, rowCount: rows.length };
  }
  
  // Request reads from Python for the current locus
  function fetchReadsFromPython() {
    readsLoading = true;
    renderAll(); // Show loading state
    
    return sendCommMessage('fetch_reads', {})
      .then(function(response) {
        readsLoading = false;
        if (response.type === 'fetch_reads_response') {
          console.log('Genomeshader: Received ' + response.count + ' read elements for locus ' + response.locus);
          if (response.reads_file) {
            console.log('Genomeshader: Loading reads from: ' + response.reads_file);
          }
          readsData = response.reads;
          loadedReadsLayout = processReadsData(readsData);
          renderAll(); // Re-render with new data
          return loadedReadsLayout;
        } else if (response.type === 'fetch_reads_error') {
          throw new Error(response.error);
        }
        return null;
      })
      .catch(function(err) {
        readsLoading = false;
        console.error('Genomeshader: Failed to fetch reads:', err);
        renderAll();
        throw err;
      });
  }
  
  // Expose for testing from console
  window.genomeshader_fetchReads = fetchReadsFromPython;

  // -----------------------------
  // Smart Tracks
  // -----------------------------
  
  // Create a new Smart track
  function createSmartTrack(strategy, selectedAlleles) {
    const timestamp = Date.now();
    const index = state.smartTracks.length;
    const trackId = `smart-track-${timestamp}-${index}`;
    
    // Check if track with this ID already exists (shouldn't happen, but guard against it)
    if (state.smartTracks.find(t => t.id === trackId)) {
      console.warn(`Smart track ${trackId} already exists, skipping creation`);
      return state.smartTracks.find(t => t.id === trackId);
    }
    
    // console.log(`Creating Smart track ${trackId} (total tracks: ${state.smartTracks.length})`);
    
    // Create track object
    const track = {
      id: trackId,
      label: `Smart Track ${index + 1}`,
      collapsed: false,
      height: 220,
      minHeight: 50,
      strategy: strategy,
      selectedAlleles: new Set(selectedAlleles),
      sampleId: null,
      readsData: null,
      readsLayout: null,
      loading: false
    };
    
    // Add to smartTracks array
    state.smartTracks.push(track);
    
    // Find Reads track index and insert after it
    const readsIndex = state.tracks.findIndex(t => t.id === "reads");
    const insertIndex = readsIndex >= 0 ? readsIndex + 1 : state.tracks.length;
    state.tracks.splice(insertIndex, 0, track);
    
    // Initialize WebGPU renderer (async, but don't await - it will complete in background)
    initSmartTrackWebGPU(trackId);
    
    // Update layout
    updateTracksHeight();
    renderAll();
    
    return track;
  }
  
  // Initialize WebGPU renderer for a Smart track
  async function initSmartTrackWebGPU(trackId) {
    // Check if renderer already exists - prevent re-initialization
    if (state.smartTrackRenderers.has(trackId)) {
      // console.log(`Smart track ${trackId}: WebGPU already initialized, skipping`);
      return;
    }
    
    if (!webgpuSupported || !navigator.gpu) {
      console.warn('WebGPU not supported, Smart track will use Canvas2D fallback');
      return;
    }
    
    const track = state.smartTracks.find(t => t.id === trackId);
    if (!track) return;
    
    // Find tracks container
    const tracksContainer = document.getElementById('tracksContainer');
    if (!tracksContainer) return;
    
    // Create container div for this Smart track
    const container = document.createElement('div');
    container.className = 'smart-track-container';
    container.id = `smart-track-container-${trackId}`;
    container.dataset.trackId = trackId;
    container.style.position = 'absolute';
    container.style.width = '100%';
    container.style.height = '100%';
    container.style.pointerEvents = 'none';
    
    // Create Canvas2D canvas
    const canvas = document.createElement('canvas');
    canvas.className = 'canvas';
    canvas.id = `smart-track-canvas-${trackId}`;
    canvas.style.position = 'absolute';
    canvas.style.top = '0';
    canvas.style.left = '0';
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.pointerEvents = 'none';
    
    // Create WebGPU canvas
    const webgpuCanvas = document.createElement('canvas');
    webgpuCanvas.className = 'webgpu-canvas';
    webgpuCanvas.id = `smart-track-webgpu-${trackId}`;
    webgpuCanvas.style.position = 'absolute';
    webgpuCanvas.style.top = '0';
    webgpuCanvas.style.left = '0';
    webgpuCanvas.style.width = '100%';
    webgpuCanvas.style.height = '100%';
    webgpuCanvas.style.pointerEvents = 'none';
    
    container.appendChild(canvas);
    container.appendChild(webgpuCanvas);
    tracksContainer.appendChild(container);
    
    try {
      // Wait for canvas to have dimensions
      const checkDimensions = () => {
        const rect = webgpuCanvas.getBoundingClientRect();
        return rect.width > 0 && rect.height > 0;
      };
      
      // Wait up to 2 seconds for dimensions
      for (let i = 0; i < 40; i++) {
        if (checkDimensions()) break;
        await new Promise(resolve => setTimeout(resolve, 50));
      }
      
      if (!checkDimensions()) {
        console.warn(`Smart track ${trackId}: Canvas dimensions not ready`);
        return;
      }
      
      // Initialize WebGPU
      const webgpuCore = new WebGPUCore();
      await webgpuCore.init(webgpuCanvas);
      const instancedRenderer = new InstancedRenderer(webgpuCore);
      
      // Store renderer objects
      state.smartTrackRenderers.set(trackId, {
        webgpuCore,
        instancedRenderer,
        canvas,
        webgpuCanvas,
        container
      });
      
      // Add scroll event listener for horizontal mode
      container.addEventListener("scroll", () => {
        renderSmartTrack(trackId);
      });
      
      console.log(`Smart track ${trackId}: WebGPU initialized`);
    } catch (error) {
      console.warn(`Smart track ${trackId}: Failed to initialize WebGPU:`, error);
      // Continue without WebGPU - will use Canvas2D fallback
      
      // Still store the renderer objects (without WebGPU)
      state.smartTrackRenderers.set(trackId, {
        webgpuCore: null,
        instancedRenderer: null,
        canvas,
        webgpuCanvas: null,
        container
      });
      
      // Add scroll event listener even without WebGPU
      container.addEventListener("scroll", () => {
        renderSmartTrack(trackId);
      });
    }
  }
  
  // Remove WebGPU renderer for a Smart track
  function removeSmartTrackWebGPU(trackId) {
    const renderer = state.smartTrackRenderers.get(trackId);
    if (renderer) {
      // Clean up WebGPU resources
      if (renderer.webgpuCore && renderer.webgpuCore.device) {
        // WebGPU cleanup is handled automatically when canvas is removed
      }
      
      // Remove DOM elements
      if (renderer.container) {
        if (renderer.container.parentNode) {
          renderer.container.parentNode.removeChild(renderer.container);
        }
        // Also try to remove by ID as fallback
        const containerById = document.getElementById(`smart-track-container-${trackId}`);
        if (containerById && containerById.parentNode) {
          containerById.parentNode.removeChild(containerById);
        }
      }
      
      // Remove from Map
      state.smartTrackRenderers.delete(trackId);
    }
  }
  
  // Fetch reads for a Smart track
  function fetchReadsForSmartTrack(trackId, strategy, selectedAlleles, sampleId) {
    const track = state.smartTracks.find(t => t.id === trackId);
    if (!track) {
      console.error(`Smart track ${trackId} not found`);
      return Promise.reject(new Error('Track not found'));
    }
    
    track.loading = true;
    renderAll();
    
    // Convert selectedAlleles Set to array
    const allelesArray = Array.from(selectedAlleles);
    
    return sendCommMessage('fetch_reads', {
      strategy: strategy,
      selected_alleles: allelesArray,
      sample_id: sampleId || null
    })
      .then(function(response) {
        track.loading = false;
        if (response.type === 'fetch_reads_response') {
          // console.log(`Smart track ${trackId}: Received ${response.count} read elements`);
          track.readsData = response.reads;
          track.readsLayout = processReadsData(response.reads);
          track.sampleId = sampleId || response.sample_id || null;
          renderAll();
          return track.readsLayout;
        } else if (response.type === 'fetch_reads_error') {
          throw new Error(response.error);
        }
        return null;
      })
      .catch(function(err) {
        track.loading = false;
        console.error(`Smart track ${trackId}: Failed to fetch reads:`, err);
        renderAll();
        throw err;
      });
  }
  
  // Remove a Smart track
  function removeSmartTrack(trackId) {
    // Remove from tracks array
    const trackIndex = state.tracks.findIndex(t => t.id === trackId);
    if (trackIndex >= 0) {
      state.tracks.splice(trackIndex, 1);
    }
    
    // Remove from smartTracks array
    const smartIndex = state.smartTracks.findIndex(t => t.id === trackId);
    if (smartIndex >= 0) {
      state.smartTracks.splice(smartIndex, 1);
    }
    
    // Clean up WebGPU renderer
    removeSmartTrackWebGPU(trackId);
    
    // Update layout and re-render
    updateTracksHeight();
    renderAll();
  }
  
  // Update Smart track strategy and reload
  function updateSmartTrackStrategy(trackId, newStrategy) {
    const track = state.smartTracks.find(t => t.id === trackId);
    if (!track) return;
    
    track.strategy = newStrategy;
    
    // Get candidate samples based on new strategy
    const candidates = state.sampleSelection.candidateSamples;
    const sampleId = candidates && candidates.length > 0 ? candidates[0] : null;
    
    // Fetch reads with new strategy
    fetchReadsForSmartTrack(trackId, newStrategy, track.selectedAlleles, sampleId)
      .catch(err => {
        console.error(`Failed to update strategy for track ${trackId}:`, err);
      });
  }
  
  // Reload Smart track (reload with current sample)
  function reloadSmartTrack(trackId) {
    const track = state.smartTracks.find(t => t.id === trackId);
    if (!track) return;
    
    // Reload with the same sample ID
    fetchReadsForSmartTrack(trackId, track.strategy, track.selectedAlleles, track.sampleId)
      .catch(err => {
        console.error(`Failed to reload track ${trackId}:`, err);
      });
  }
  
  // Shuffle Smart track (choose a new/different sample)
  function shuffleSmartTrack(trackId) {
    const track = state.smartTracks.find(t => t.id === trackId);
    if (!track) return;
    
    // Recompute candidate samples based on current strategy
    const candidates = state.sampleSelection.candidateSamples;
    let sampleId = null;
    
    if (candidates && candidates.length > 0) {
      if (candidates.length === 1) {
        // Only one candidate, use it
        sampleId = candidates[0];
      } else {
        // If we have a current sample, try to get a different one
        if (track.sampleId && candidates.includes(track.sampleId)) {
          const currentIndex = candidates.indexOf(track.sampleId);
          // Pick a random different sample
          let nextIndex;
          do {
            nextIndex = Math.floor(Math.random() * candidates.length);
          } while (nextIndex === currentIndex && candidates.length > 1);
          sampleId = candidates[nextIndex];
        } else {
          // No current sample or it's not in candidates, pick a random one
          sampleId = candidates[Math.floor(Math.random() * candidates.length)];
        }
      }
    }
    
    // Fetch reads with new sample
    fetchReadsForSmartTrack(trackId, track.strategy, track.selectedAlleles, sampleId)
      .catch(err => {
        console.error(`Failed to shuffle track ${trackId}:`, err);
      });
  }
  
  // Update Smart track label
  function editSmartTrackLabel(trackId, newLabel) {
    const track = state.smartTracks.find(t => t.id === trackId);
    if (!track) return;
    
    // Also update in tracks array
    const trackInArray = state.tracks.find(t => t.id === trackId);
    if (trackInArray) {
      trackInArray.label = newLabel;
    }
    
    track.label = newLabel;
    renderAll();
  }

  // -----------------------------
  // Theme + menu
  // -----------------------------
  // Find root container for scoping event handlers in inline mode
  const root = document.querySelector('[id^="genomeshader-root-"]') ||
                (document.querySelector('.app')?.closest('[id^="genomeshader-root-"]')) ||
                document.body; // Fallback to body if not found
  
  // Dynamic root lookup - finds the current container (overlay modal or original root)
  // This is needed because the viewer moves to an overlay modal in full-screen mode
  function getCurrentRoot() {
    // Check if we're in overlay mode by looking for the app element in an overlay
    const appEl = document.querySelector('.app');
    if (appEl) {
      // Check if app is inside an overlay modal
      const overlayModal = appEl.closest('[id^="genomeshader-modal-"]');
      if (overlayModal) {
        return overlayModal;
      }
      // Check if app is inside a genomeshader-root
      const gsRoot = appEl.closest('[id^="genomeshader-root-"]');
      if (gsRoot) {
        return gsRoot;
      }
    }
    return root;
  }
  
  // Root-scoped element lookup helpers
  function byId(rootEl, id) {
    const el = rootEl.querySelector(`#${CSS.escape(id)}`);
    return el;
  }

  function $(rootEl, selector) {
    const el = rootEl.querySelector(selector);
    return el;
  }
  
  // Dynamic version that uses current root
  function byIdDynamic(id) {
    return byId(getCurrentRoot(), id);
  }
  
  // Use root-scoped queries in inline mode, document queries in popup mode
  const querySelector = (selector) => {
    if (hostMode === 'inline' && root && root !== document.body) {
      return root.querySelector(selector) || document.querySelector(selector);
    }
    return document.querySelector(selector);
  };
  const getElementById = (id) => {
    if (hostMode === 'inline' && root && root !== document.body) {
      return root.getElementById ? root.getElementById(id) : root.querySelector(`#${id}`) || document.getElementById(id);
    }
    return document.getElementById(id);
  };
  
  const app = querySelector(".app");
  const sidebar = getElementById("sidebar");
  const menuBtn = getElementById("menuBtn");
  const ctxMenu = getElementById("ctxMenu");
  const themeItem = getElementById("themeItem");
  const themeLabel = getElementById("themeLabel");
  const orientationItem = getElementById("orientationItem");
  const orientationLabel = getElementById("orientationLabel");
  
  // Debug: Check if elements are found
  
  // In inline mode, keep menu in root initially, but we'll move it to body when opening
  // This ensures fixed positioning works relative to viewport, not container
  if (hostMode === 'inline' && root && ctxMenu && !root.contains(ctxMenu)) {
    root.appendChild(ctxMenu);
  }

  // Sidebar collapse/expand
  function getSidebarCollapsed() {
    return localStorage.getItem("genomeshader.sidebarCollapsed") === "true";
  }
  function setSidebarCollapsed(collapsed) {
    localStorage.setItem("genomeshader.sidebarCollapsed", String(collapsed));
    updateSidebarState();
  }
  function updateSidebarState() {
    const collapsed = getSidebarCollapsed();
    if (!app) {
      return;
    }
    if (collapsed) {
      app.classList.add("sidebar-collapsed");
    } else {
      app.classList.remove("sidebar-collapsed");
    }
    // Trigger resize after CSS transition completes to ensure tracks re-render
    // The CSS transition is 0.2s, so wait for it to complete
    setTimeout(() => {
      window.dispatchEvent(new Event('resize'));
    }, 220);
  }
  
  // Make sidebar border clickable - always bind regardless of hostMode
  if (sidebar) {
    const handleSidebarToggle = (e) => {
      // Don't toggle if clicking on menu button or menu
      if ((menuBtn && (menuBtn === e.target || menuBtn.contains(e.target))) ||
          (ctxMenu && (ctxMenu === e.target || ctxMenu.contains(e.target)))) {
        return; // Let menu button handler fire
      }
      
      // Don't intercept clicks on form elements or their containers
      const target = e.target;
      if (target.closest('select, input, button, label, .sampleStrategyControls, .sampleSearchControls, #samplePreview, #sampleContext')) {
        return; // Let form element handlers fire
      }
      
      const collapsed = getSidebarCollapsed();
      const rect = sidebar.getBoundingClientRect();
      const clickX = e.clientX - rect.left;

      // Check if click is within 12px of the right edge (or anywhere if collapsed)
      if (collapsed) {
        // When collapsed, the entire 12px strip is clickable
        e.preventDefault();
        e.stopPropagation();
        setSidebarCollapsed(false);
      } else if (clickX >= rect.width - 12) {
        // When open, only the right 12px edge is clickable
        e.preventDefault();
        e.stopPropagation();
        setSidebarCollapsed(true);
      }
      // For clicks elsewhere in the sidebar, don't stop propagation
    };
    
    // Use multiple event types with capturing phase (like debug buttons)
    sidebar.addEventListener("click", handleSidebarToggle, true);
    sidebar.addEventListener("pointerdown", handleSidebarToggle, true);
    sidebar.addEventListener("pointerup", handleSidebarToggle, true);
    sidebar.addEventListener("mousedown", handleSidebarToggle, true);
    
    // Ensure sidebar is clickable
    sidebar.style.pointerEvents = "auto";
  }
  
  updateSidebarState();

  function getStoredTheme() {
    return localStorage.getItem("genomeshader.theme"); // "dark" | "light" | "auto" | null
  }
  function setTheme(theme) {
    document.documentElement.setAttribute("data-theme", theme);
    localStorage.setItem("genomeshader.theme", theme);
    updateThemeLabel();
  }
  function updateThemeLabel() {
    const t = document.documentElement.getAttribute("data-theme") || "auto";
    themeLabel.textContent = t === "auto" ? "Auto" : (t === "light" ? "Light" : "Dark");
  }
  function getStoredOrientation() {
    return localStorage.getItem("genomeshader.orientation"); // "horizontal" | "vertical" | null
  }
  function setOrientation(o) {
    localStorage.setItem("genomeshader.orientation", o);
    updateOrientationState();
  }
  function updateOrientationState() {
    const o = getStoredOrientation() ?? "horizontal";
    // Apply on the main pane so CSS can target all track contents
    main.classList.toggle("vertical", o === "vertical");
    orientationLabel.textContent = (o === "vertical") ? "Vertical" : "Horizontal";
  }
  function isVerticalMode() {
    return (getStoredOrientation() ?? "horizontal") === "vertical";
  }
  function getStoredVariantLayoutMode() {
    return localStorage.getItem("genomeshader.variantLayoutMode"); // "equidistant" | "genomic" | null
  }
  function setVariantLayoutMode(mode) {
    localStorage.setItem("genomeshader.variantLayoutMode", mode);
    state.variantLayoutMode = mode;
    updateVariantLayoutModeLabel();
  }
  function updateVariantLayoutModeLabel() {
    const mode = state.variantLayoutMode || "equidistant";
    const labelEl = document.getElementById("variantLayoutModeLabel");
    if (labelEl) {
      labelEl.textContent = mode === "equidistant" ? "Equidistant" : "Genomic";
    }
  }
  function getVariantLayoutMode() {
    return state.variantLayoutMode || "equidistant";
  }

  const stored = getStoredTheme();
  document.documentElement.setAttribute("data-theme", stored ?? "auto");
  updateThemeLabel();

  function openMenu() {
    // In inline mode, move menu to body so fixed positioning works relative to viewport
    if (hostMode === 'inline' && ctxMenu.parentElement !== document.body) {
      document.body.appendChild(ctxMenu);
    }
    
    // Temporarily show menu to measure its actual dimensions
    ctxMenu.style.position = 'fixed';
    ctxMenu.style.visibility = 'hidden';
    ctxMenu.style.display = 'block';
    ctxMenu.classList.add("open");
    ctxMenu.setAttribute("aria-hidden", "false");
    
    // Get actual menu dimensions
    const menuRect = ctxMenu.getBoundingClientRect();
    const menuHeight = menuRect.height;
    const menuWidth = menuRect.width;
    
    // Use fixed positioning so menu appears over everything (including Jupyter UI)
    const r = menuBtn.getBoundingClientRect();
    const padding = 8;
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;
    
    // Calculate positions for above and below the button
    const spaceAbove = r.top;
    const spaceBelow = viewportHeight - r.bottom;
    const topIfAbove = r.top - menuHeight - padding;
    const topIfBelow = r.bottom + padding;
    
    // Determine best position: prefer above, but use below if not enough space above
    // However, if below would extend off screen, position above even with limited space
    let top, left = r.left;
    
    // Check if positioning below would extend off screen
    const wouldExtendBelow = (topIfBelow + menuHeight) > (viewportHeight - padding);
    
    if (spaceAbove >= menuHeight + padding && !wouldExtendBelow) {
      // Enough space above, position above
      top = topIfAbove;
    } else if (spaceBelow >= menuHeight + padding && !wouldExtendBelow) {
      // Not enough space above, but enough below, position below
      top = topIfBelow;
    } else {
      // Not enough space in either direction, position above and adjust to fit
      // This ensures menu never extends below viewport
      top = Math.max(padding, viewportHeight - menuHeight - padding);
    }
    
    // Ensure menu doesn't go off right edge
    if (left + menuWidth > viewportWidth - padding) {
      left = Math.max(padding, viewportWidth - menuWidth - padding);
    }
    
    // Final check: ensure menu never extends below viewport
    if (top + menuHeight > viewportHeight - padding) {
      top = Math.max(padding, viewportHeight - menuHeight - padding);
    }
    
    // Apply final positioning
    ctxMenu.style.left = `${left}px`;
    ctxMenu.style.top = `${top}px`;
    ctxMenu.style.zIndex = '2147483647';
    ctxMenu.style.visibility = 'visible';
    ctxMenu.style.pointerEvents = 'auto';
    ctxMenu.style.opacity = '1';

    // Update variant layout mode label when menu opens
    updateVariantLayoutModeLabel();
  }
  function closeMenu() {
    ctxMenu.classList.remove("open");
    ctxMenu.setAttribute("aria-hidden", "true");
    ctxMenu.style.display = 'none';
    ctxMenu.style.visibility = 'hidden';
    ctxMenu.style.pointerEvents = 'none';
    
    // In inline mode, move menu back to root when closed
    if (hostMode === 'inline' && root && ctxMenu.parentElement === document.body) {
      root.appendChild(ctxMenu);
    }
  }
  function toggleMenu() {
    ctxMenu.classList.contains("open") ? closeMenu() : openMenu();
  }

  if (menuBtn && ctxMenu) {
    // Track if we've already handled this interaction to prevent double-toggle
    let menuButtonHandled = false;
    
    const handleMenuButtonClick = (e) => {
      // If we already handled this interaction (e.g., pointerdown), ignore subsequent events (click)
      if (menuButtonHandled && e.type !== 'pointerdown') {
        return;
      }
      e.stopPropagation(); 
      e.preventDefault();
      
      // Mark as handled and reset after a short delay
      menuButtonHandled = true;
      setTimeout(() => { menuButtonHandled = false; }, 300);
      
      toggleMenu(); 
    };
    
    // Use pointerdown as primary handler (fires first), click as fallback
    menuBtn.addEventListener("pointerdown", handleMenuButtonClick, true);
    menuBtn.addEventListener("click", handleMenuButtonClick, true);
    menuBtn.addEventListener("mousedown", handleMenuButtonClick, true);
    
    // Ensure menu button is clickable
    menuBtn.style.pointerEvents = "auto";
    menuBtn.style.cursor = "pointer";
    menuBtn.style.zIndex = "150";
    // Keep absolute positioning for bottom-left placement
    menuBtn.style.position = "absolute";
    
    // Also set onclick as fallback
    menuBtn.onclick = handleMenuButtonClick;

    // Close menu when clicking outside, but check if click is outside menu/button
    // In inline mode, use root-scoped handler to avoid Jupyter wrapper interference
    if (hostMode === 'inline' && root) {
      // Track when menu was just opened to avoid immediate close
      let menuJustOpened = false;
      const originalToggleMenu = toggleMenu;
      toggleMenu = function() {
        menuJustOpened = true;
        originalToggleMenu();
        // Reset flag after a short delay
        setTimeout(() => { menuJustOpened = false; }, 100);
      };
      
      // Use pointerdown with capturing to catch events before they bubble
      const onPointerDown = (e) => {
        // Don't close if menu was just opened (same click event)
        if (menuJustOpened) {
          return;
        }
        // Only close if menu is open and click is outside menu/button
        if (ctxMenu.classList.contains("open") && 
            !ctxMenu.contains(e.target) && 
            !menuBtn.contains(e.target)) {
          closeMenu();
        }
      };
      root.addEventListener("pointerdown", onPointerDown, true);
    } else {
      // Popup mode: use document-level handler
      document.addEventListener("click", (e) => {
        if (!ctxMenu.contains(e.target) && !menuBtn.contains(e.target)) {
          closeMenu();
        }
      });
    }
  }
  ctxMenu.addEventListener("click", (e) => e.stopPropagation());

  themeItem.addEventListener("click", () => {
    const cur = document.documentElement.getAttribute("data-theme") || "auto";
    const next = cur === "dark" ? "light" : (cur === "light" ? "auto" : "dark");
    setTheme(next);
    renderAll();
  });

  orientationItem.addEventListener("click", () => {
    const cur = getStoredOrientation() ?? "horizontal";
    const next = (cur === "horizontal") ? "vertical" : "horizontal";
    setOrientation(next);
    renderAll();
  });

  // Variant layout mode toggle in settings menu
  const variantLayoutModeItem = getElementById("variantLayoutModeItem");
  
  if (variantLayoutModeItem) {
    variantLayoutModeItem.addEventListener("click", () => {
      const cur = getVariantLayoutMode();
      const next = (cur === "equidistant") ? "genomic" : "equidistant";
      setVariantLayoutMode(next);
      renderAll();
    });
  }

  // Load Reads button in settings menu
  const loadReadsItem = getElementById("loadReadsItem");
  const loadReadsLabel = getElementById("loadReadsLabel");
  
  if (loadReadsItem) {
    loadReadsItem.addEventListener("click", () => {
      if (readsLoading) return; // Already loading
      
      loadReadsLabel.textContent = "⏳";
      fetchReadsFromPython()
        .then(() => {
          loadReadsLabel.textContent = "✓";
          setTimeout(() => { loadReadsLabel.textContent = "▶"; }, 2000);
        })
        .catch((err) => {
          loadReadsLabel.textContent = "✗";
          console.error("Failed to load reads:", err);
          setTimeout(() => { loadReadsLabel.textContent = "▶"; }, 2000);
        });
    });
  }


  // Fullscreen mode setup
  const fullscreenItem = getElementById("fullscreenItem");
  const fullscreenLabel = getElementById("fullscreenLabel");
  
  // Resize callback for focus mode
  function triggerResize() {
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        if (webgpuCore && webgpuSupported) {
          try {
            webgpuCore.handleResize();
          } catch (error) {
            // WebGPU resize error
          }
        }
        renderAll();
      });
    });
  }

  // Focus mode implementation (inlined from focus_mode.js)
  function installFocusMode({ viewerEl, toggleEl, viewId, onEnter, onExit }) {
    if (!viewerEl || !toggleEl || !viewId) {
      return;
    }

    let isActive = false;
    let overlay = null;
    let modal = null;
    let topbar = null;
    let placeholder = null;
    let originalParent = null;
    let originalNextSibling = null;

    const overlayId = `genomeshader-overlay-${viewId}`;
    const modalId = `genomeshader-modal-${viewId}`;
    const topbarId = `genomeshader-topbar-${viewId}`;
    const placeholderId = `genomeshader-placeholder-${viewId}`;
    
    // Clean up any stale overlays from previous sessions on initialization
    const staleOverlay = document.getElementById(overlayId);
    if (staleOverlay) {
      console.log(`Cleaning up stale overlay: ${overlayId}`);
      staleOverlay.remove();
    }

    function createOverlay() {
      // Remove any existing overlay with this ID first
      const existingOverlay = document.getElementById(overlayId);
      if (existingOverlay) {
        existingOverlay.remove();
      }
      
      overlay = document.createElement('div');
      overlay.id = overlayId;
      overlay.style.cssText = `
        position: fixed;
        inset: 0;
        z-index: 2147483647;
        background: rgba(0, 0, 0, 0.75);
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
      `;

      modal = document.createElement('div');
      modal.id = modalId;
      modal.style.cssText = `
        position: absolute;
        inset: 24px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        background: var(--bg, #0b0d10);
        border-radius: 12px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        pointer-events: auto;
      `;

      topbar = document.createElement('div');
      topbar.id = topbarId;
      topbar.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px 16px;
        border-bottom: 1px solid var(--border, rgba(255,255,255,0.10));
        background: var(--panel, #11151b);
        flex-shrink: 0;
      `;

      const title = document.createElement('div');
      title.textContent = 'Genomeshader — Full screen';
      title.style.cssText = `
        font-size: 14px;
        font-weight: 600;
        color: var(--text, rgba(255,255,255,0.92));
      `;

      const closeBtn = document.createElement('button');
      closeBtn.textContent = '✕';
      closeBtn.setAttribute('aria-label', 'Close full screen');
      closeBtn.style.cssText = `
        width: 32px;
        height: 32px;
        border: 1px solid var(--border2, rgba(255,255,255,0.08));
        background: var(--panel2, rgba(255,255,255,0.03));
        color: var(--text, rgba(255,255,255,0.92));
        border-radius: 8px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        line-height: 1;
        transition: all 0.15s ease;
      `;
      closeBtn.addEventListener('mouseenter', () => {
        closeBtn.style.filter = 'brightness(1.1)';
      });
      closeBtn.addEventListener('mouseleave', () => {
        closeBtn.style.filter = '';
      });
      closeBtn.addEventListener('click', exit);

      topbar.appendChild(title);
      topbar.appendChild(closeBtn);

      const modalBody = document.createElement('div');
      modalBody.style.cssText = `
        flex: 1;
        overflow: hidden;
        position: relative;
        pointer-events: auto;
        touch-action: none;
      `;

      modal.appendChild(topbar);
      modal.appendChild(modalBody);
      overlay.appendChild(modal);

      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          exit();
        }
      });

      // Close menu when clicking on modal body in full-screen mode
      const handleModalBodyClick = (e) => {
        // Check if menu is open and click is outside menu and menu button
        const menuBtn = document.getElementById('menuBtn');
        const ctxMenu = document.getElementById('ctxMenu');
        if (ctxMenu && ctxMenu.classList.contains('open') &&
            !ctxMenu.contains(e.target) && 
            menuBtn && !menuBtn.contains(e.target)) {
          // Close the menu
          if (typeof closeMenu === 'function') {
            closeMenu();
          }
        }
      };
      modalBody.addEventListener('click', handleModalBodyClick, true);
      overlay._menuCloseHandler = handleModalBodyClick;
      overlay._modalBody = modalBody;

      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          // First check if menu is open, close it if so
          const ctxMenu = document.getElementById('ctxMenu');
          if (ctxMenu && ctxMenu.classList.contains('open') && typeof closeMenu === 'function') {
            closeMenu();
            e.preventDefault();
            e.stopPropagation();
            return;
          }
          // Otherwise exit full-screen mode
          if (isActive) {
            exit();
          }
        }
      };
      document.addEventListener('keydown', handleEscape);
      overlay._escapeHandler = handleEscape;

      return { overlay, modal, modalBody };
    }

    function enter() {
      if (isActive) return;

      const { overlay, modal, modalBody } = createOverlay();
      
      originalParent = viewerEl.parentNode;
      originalNextSibling = viewerEl.nextSibling;

      placeholder = document.createElement('div');
      placeholder.id = placeholderId;
      placeholder.style.cssText = `
        width: ${viewerEl.offsetWidth}px;
        height: ${viewerEl.offsetHeight}px;
        min-height: 600px;
      `;

      if (originalNextSibling) {
        originalParent.insertBefore(placeholder, originalNextSibling);
      } else {
        originalParent.appendChild(placeholder);
      }

      modalBody.appendChild(viewerEl);
      document.body.appendChild(overlay);

      const originalOverflow = document.body.style.overflow;
      document.body.style.overflow = 'hidden';
      overlay._originalOverflow = originalOverflow;

      isActive = true;
      updateToggleLabel();

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          // Rebind interactions after DOM move
          if (typeof interactionBinding !== 'undefined' && interactionBinding) {
            interactionBinding.destroy();
          }
          // Re-find main element within the moved viewer element
          const mainAfterMove = viewerEl.querySelector ? viewerEl.querySelector("#main") : byId(root, "main");
          if (mainAfterMove && typeof bindInteractions !== 'undefined') {
            // Use root to maintain scoping, but mainAfterMove is the actual element
            interactionBinding = bindInteractions(root, state, mainAfterMove);
          }
          if (onEnter) {
            onEnter();
          }
        });
      });
    }

    function exit() {
      if (!isActive) return;

      if (overlay && overlay._originalOverflow !== undefined) {
        document.body.style.overflow = overlay._originalOverflow;
      } else {
        document.body.style.overflow = '';
      }

      if (overlay && overlay._escapeHandler) {
        document.removeEventListener('keydown', overlay._escapeHandler);
      }

      // Remove menu close handler from modal body
      if (overlay && overlay._menuCloseHandler && overlay._modalBody) {
        overlay._modalBody.removeEventListener('click', overlay._menuCloseHandler, true);
      }

      if (placeholder && originalParent) {
        if (originalNextSibling) {
          originalParent.insertBefore(viewerEl, originalNextSibling);
        } else {
          originalParent.appendChild(viewerEl);
        }
        placeholder.remove();
        placeholder = null;
      }

      if (overlay) {
        overlay.remove();
        overlay = null;
        modal = null;
        topbar = null;
      }

      isActive = false;
      updateToggleLabel();

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          // Rebind interactions after DOM move
          if (typeof interactionBinding !== 'undefined' && interactionBinding) {
            interactionBinding.destroy();
          }
          // Re-find main element within the moved viewer element
          const mainAfterMove = viewerEl.querySelector ? viewerEl.querySelector("#main") : byId(root, "main");
          if (mainAfterMove && typeof bindInteractions !== 'undefined') {
            // Use root to maintain scoping, but mainAfterMove is the actual element
            interactionBinding = bindInteractions(root, state, mainAfterMove);
          }
          if (onExit) {
            onExit();
          }
        });
      });
    }

    function updateToggleLabel() {
      if (fullscreenLabel) {
        fullscreenLabel.textContent = isActive ? 'Exit full screen' : 'Enter full screen';
      }
    }

    toggleEl.addEventListener('click', (e) => {
      e.stopPropagation();
      if (isActive) {
        exit();
      } else {
        enter();
      }
    });

    updateToggleLabel();

    return {
      enter,
      exit,
      isActive: () => isActive
    };
  }

  // Initialize focus mode after app is ready
  // Declare interactionBinding early so it's accessible to overlay callbacks
  let interactionBinding = null;
  
  const viewId = window.GENOMESHADER_VIEW_ID || document.querySelector('[data-view-id]')?.dataset.viewId || 'default';
  let focusModeController = null;
  if (fullscreenItem && app) {
    focusModeController = installFocusMode({
      viewerEl: app,
      toggleEl: fullscreenItem,
      viewId: viewId,
      onEnter: triggerResize,
      onExit: triggerResize
    });

  }

  // Hotkeys for Settings menu items
  const handleSettingsHotkeys = (e) => {
    // Check if we're in an input field (to avoid interfering with typing)
    const isInputField = e.target.tagName === 'INPUT' || 
                        e.target.tagName === 'TEXTAREA' || 
                        e.target.isContentEditable;
    
    // Only process if not in input field and no modifier keys are pressed
    if (isInputField || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) {
      return;
    }

    const key = e.key.toLowerCase();
    
    // Theme toggle: 't'
    if (key === 't' && themeItem) {
      e.preventDefault();
      e.stopPropagation();
      const cur = document.documentElement.getAttribute("data-theme") || "auto";
      const next = cur === "dark" ? "light" : (cur === "light" ? "auto" : "dark");
      setTheme(next);
      renderAll();
      return;
    }

    // Orientation toggle: 'o'
    if (key === 'o' && orientationItem) {
      e.preventDefault();
      e.stopPropagation();
      const cur = getStoredOrientation() ?? "horizontal";
      const next = (cur === "horizontal") ? "vertical" : "horizontal";
      setOrientation(next);
      renderAll();
      return;
    }

    // Variant Layout toggle: 'v'
    if (key === 'v' && variantLayoutModeItem) {
      e.preventDefault();
      e.stopPropagation();
      const cur = getVariantLayoutMode();
      const next = (cur === "equidistant") ? "genomic" : "equidistant";
      setVariantLayoutMode(next);
      renderAll();
      return;
    }

    // Full screen toggle: 'f'
    if (key === 'f' && fullscreenItem && focusModeController && !focusModeController.isActive()) {
      e.preventDefault();
      e.stopPropagation();
      focusModeController.enter();
      return;
    }

    // Load Reads: 'r'
    if (key === 'r' && loadReadsItem && !readsLoading) {
      e.preventDefault();
      e.stopPropagation();
      loadReadsLabel.textContent = "⏳";
      fetchReadsFromPython()
        .then(() => {
          loadReadsLabel.textContent = "✓";
          setTimeout(() => { loadReadsLabel.textContent = "▶"; }, 2000);
        })
        .catch((err) => {
          loadReadsLabel.textContent = "✗";
          console.error("Failed to load reads:", err);
          setTimeout(() => { loadReadsLabel.textContent = "▶"; }, 2000);
        });
      return;
    }
  };

  // Add hotkey listener for all Settings menu items
  document.addEventListener('keydown', handleSettingsHotkeys, true);

  const mq = window.matchMedia?.("(prefers-color-scheme: light)");
  mq?.addEventListener?.("change", () => {
    if ((document.documentElement.getAttribute("data-theme") || "auto") === "auto") {
      updateThemeLabel();
      renderAll();
    }
  });

  // -----------------------------
  // ViewState
  // -----------------------------
  const state = {
    contig: "chr1",
    startBp: 100_000,
    endBp:   100_900,
    pxPerBp: 1,

    firstVariantIndex: 0,
    K: 8,
    hoveredVariantIndex: null, // index of hovered variant, or null
    expandedInsertions: new Set(), // Set of variant IDs that have expanded insertions
    hoveredRepeatTooltip: null, // { text, x, y } or null
    hoveredVariantLabelTooltip: null, // { text, x, y } or null
    locusVariantElements: new Map(), // Map of variant index -> { lineEl, circleEl } for Locus track

    // interaction
    dragging: false,
    lastX: 0,
    lastY: 0,

    // touch pinch
    pointers: new Map(),     // pointerId -> {x,y}
    pinchStartDist: null,
    pinchStartSpan: null,
    pinchAnchorBp: null,

    // track management
    tracks: [
      { id: "ideogram", label: "Chromosome", collapsed: false, height: 38, minHeight: 20 },
      { id: "genes", label: "Genes", collapsed: false, height: 50, minHeight: 30 },
      { id: "repeats", label: "RepeatMasker", collapsed: false, height: 50, minHeight: 30 },
      { id: "ruler", label: "Locus", collapsed: false, height: 68, minHeight: 40 },
      { id: "reference", label: "Reference", collapsed: false, height: 40, minHeight: 30 },
      { id: "flow", label: "Variants/Haplotypes", collapsed: false, height: 150, minHeight: 100 },
      { id: "reads", label: "Reads", collapsed: false, height: 220, minHeight: 50 }
    ],
    trackDragState: null,  // { trackId, startX, startY, offsetX, offsetY }
    trackResizeState: null, // { trackId, startX, startY, startHeight }
    
    // variant layout mode: "equidistant" or "genomic"
    variantLayoutMode: null, // will be initialized from localStorage
    
    // allele order for each variant: Map<variantId, string[]> where array is ['.', '(N bp) refAllele', '(N bp) altAllele1', ...]
    variantAlleleOrder: new Map(),
    
    // drag state for allele reordering
    alleleDragState: null, // { variantId, alleleIndex, label, startX, startY, offsetX, offsetY, dropIndex }
    
    // hovered allele node: { variantId, alleleIndex } or null
    hoveredAlleleNode: null,
    
    // pinned allele labels: Set of strings like "variantId:alleleIndex"
    pinnedAlleleLabels: new Set(),
    
    // pinned variant labels: Set of variant IDs (strings)
    pinnedVariantLabels: new Set(),
    
    // selected alleles for multi-select: Set of strings like "variantId:alleleIndex"
    selectedAlleles: new Set(),
    
    // sample selection state
    sampleSelection: {
      strategy: 'best_evidence',
      numSamples: 1,
      combineMode: 'AND', // 'AND' or 'OR'
      candidateSamples: [], // Will be populated when selection changes
      allSampleIds: [] // All available sample IDs (populated from data)
    },
    
    // Smart tracks state
    smartTracks: [], // Array of Smart track instances
    smartTrackRenderers: new Map(), // Map<trackId, { webgpuCore, instancedRenderer, canvas, webgpuCanvas, container }>
    
    // allele context menu state: { x, y, visible } or null
    alleleContextMenu: null
  };

  // Initialize variant layout mode
  const storedVariantMode = getStoredVariantLayoutMode();
  state.variantLayoutMode = storedVariantMode ?? "equidistant";
  // Initialize label after DOM is ready
  setTimeout(() => updateVariantLayoutModeLabel(), 0);

  // Chromosome lengths for bounds checking
  const chrLengths = {
    "chr1": 248_956_422,
    "chr2": 242_193_529,
    "chr3": 198_295_559,
    "chr4": 190_214_555,
    "chr5": 181_538_259,
    "chr6": 170_805_979,
    "chr7": 159_345_973,
    "chr8": 145_138_636,
    "chr9": 138_394_717,
    "chr10": 133_797_422,
    "chr11": 135_086_622,
    "chr12": 133_275_309,
    "chr13": 114_364_328,
    "chr14": 107_043_718,
    "chr15": 101_991_189,
    "chr16": 90_338_345,
    "chr17": 83_257_441,
    "chr18": 80_373_285,
    "chr19": 58_617_616,
    "chr20": 64_444_167,
    "chr21": 46_709_983,
    "chr22": 50_818_468,
    "chrX": 156_040_895,
    "chrY": 57_227_415
  };

  // Helper function to get chromosome length for current contig
  function getChromosomeLength() {
    return chrLengths[state.contig] || 248_956_422;
  }

  // Helper function to clamp startBp and endBp to chromosome boundaries
  function clampToChromosomeBounds() {
    const chrLength = getChromosomeLength();
    const span = state.endBp - state.startBp;
    
    // Clamp startBp to [0, chrLength - span]
    state.startBp = Math.max(0, Math.min(state.startBp, chrLength - span));
    
    // Ensure endBp doesn't exceed chromosome length
    state.endBp = Math.min(state.startBp + span, chrLength);
    
    // If span is larger than chromosome, center it
    if (span > chrLength) {
      state.startBp = 0;
      state.endBp = chrLength;
    }
  }

  // Function to update document title with current locus
  function updateDocumentTitle() {
    const startFormatted = Math.floor(state.startBp).toLocaleString();
    const endFormatted = Math.floor(state.endBp).toLocaleString();
    document.title = `Genomeshader (${state.contig}:${startFormatted}-${endFormatted})`;
  }

  // Initialize state from GENOMESHADER_CONFIG if available
  let dataBounds = null;
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.region) {
    const region = window.GENOMESHADER_CONFIG.region;
    // Parse region string format: "chr1:100000-200000"
    const match = region.match(/^([^:]+):(\d+)-(\d+)$/);
    if (match) {
      state.contig = match[1];
      state.startBp = parseInt(match[2], 10);
      state.endBp = parseInt(match[3], 10);
    }
    
    // Store data bounds if available (where actual read data exists)
    if (window.GENOMESHADER_CONFIG.data_bounds) {
      dataBounds = {
        start: window.GENOMESHADER_CONFIG.data_bounds.start,
        end: window.GENOMESHADER_CONFIG.data_bounds.end
      };
    }
    
    // Update document title with initial locus
    updateDocumentTitle();
  }

  const main = byId(root, "main");
  const tracksSvg = byId(root, "tracksSvg");
  const flow = byId(root, "flow");
  const reads = byId(root, "reads");
  const flowCanvas = byId(root, "flowCanvas");
  const readsCanvas = byId(root, "readsCanvas");
  const flowOverlay = byId(root, "flowOverlay");
  const readsOverlay = byId(root, "readsOverlay");
  const hud = byId(root, "hud");
  const tooltip = byId(root, "tooltip");
  const tracksWebGPU = byId(root, "tracksWebGPU");
  const flowWebGPU = byId(root, "flowWebGPU");
  const readsWebGPU = byId(root, "readsWebGPU");

  // Initialize WebGPU infrastructure
  let webgpuCore = null;
  let instancedRenderer = null;
  let flowWebGPUCore = null;
  let flowInstancedRenderer = null;
  let flowRibbonRenderer = null;
  let readsWebGPUCore = null;
  let readsInstancedRenderer = null;
  let webgpuSupported = false;
  let repeatHitTestData = []; // For tooltip hit testing
  
  // Cache for ribbon transition data (keyed by variant pair IDs)
  // This avoids recalculating transitions on every pan/zoom
  const ribbonTransitionCache = new Map();
  const MAX_CACHE_SIZE = 1000; // Limit cache size to prevent unbounded growth
  let cachedVisibleVariantIds = null; // Track which variants were used for cache
  let cachedViewportRange = null; // Track the viewport range used for cache (with padding)
  
  // Expanded variant window with padding to reduce cache invalidation during pan/zoom
  // Returns variants within viewport + padding (e.g., 30% on each side)
  function expandedVariantWindow(paddingFraction = 0.3) {
    const span = state.endBp - state.startBp;
    const padding = span * paddingFraction;
    const expandedStart = Math.max(0, state.startBp - padding);
    const expandedEnd = state.endBp + padding;
    return variants.filter(v => v.pos >= expandedStart && v.pos <= expandedEnd);
  }

  async function initWebGPU() {
    if (!navigator.gpu) {
      console.warn("WebGPU not supported, falling back to SVG rendering");
      if (tracksWebGPU) tracksWebGPU.style.display = 'none';
      return false;
    }

    // Wait for canvas to have dimensions
    if (!tracksWebGPU) {
      return false;
    }
    
    const checkDimensions = () => {
      const rect = tracksWebGPU.getBoundingClientRect();
      return rect.width > 0 && rect.height > 0;
    };
    
    // Wait up to 2 seconds for dimensions
    for (let i = 0; i < 40; i++) {
      if (checkDimensions()) {
        break;
      }
      await new Promise(resolve => setTimeout(resolve, 50));
    }
    
    if (!checkDimensions()) {
      if (tracksWebGPU) tracksWebGPU.style.display = 'none';
      return false;
    }

    try {
      webgpuCore = new WebGPUCore();
      await webgpuCore.init(tracksWebGPU);
      instancedRenderer = new InstancedRenderer(webgpuCore);

      // Flow WebGPU (separate canvas)
      if (flowWebGPU) {
        flowWebGPUCore = new WebGPUCore();
        await flowWebGPUCore.init(flowWebGPU);
        flowInstancedRenderer = new InstancedRenderer(flowWebGPUCore);
        flowRibbonRenderer = new BezierRibbonRenderer(flowWebGPUCore, { segments: 44 });
      }

      // Reads WebGPU (separate canvas)
      if (readsWebGPU) {
        readsWebGPUCore = new WebGPUCore();
        await readsWebGPUCore.init(readsWebGPU);
        readsInstancedRenderer = new InstancedRenderer(readsWebGPUCore);
      }

      webgpuSupported = true;
      return true;
    } catch (error) {
      console.warn("Failed to initialize WebGPU:", error);
      if (tracksWebGPU) tracksWebGPU.style.display = 'none';
      return false;
    }
  }

  // Initialize WebGPU after a short delay to ensure DOM is ready
  setTimeout(() => {
    initWebGPU().catch(err => {
      console.error("WebGPU initialization error:", err);
    });
  }, 100);

  // Initialize orientation state after DOM elements are available
  updateOrientationState();

  function rectW(el) { 
    if (!el) return 0;
    const w = el.getBoundingClientRect().width;
    return isNaN(w) || w <= 0 ? 0 : w;
  }
  function rectH(el) { 
    if (!el) return 0;
    const h = el.getBoundingClientRect().height;
    return isNaN(h) || h <= 0 ? 0 : h;
  }

  function tracksWidthPx() { 
    if (!tracksSvg) return 0;
    const w = tracksSvg.getBoundingClientRect().width;
    return isNaN(w) || w <= 0 ? 0 : w;
  }
  function flowWidthPx()   { return rectW(flow); }
  function flowHeightPx()  { return rectH(flow); }
  function readsWidthPx()  { return rectW(reads); }
  function readsHeightPx() { return rectH(reads); }

  function cssVar(name) {
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  }

  function updateDerived() {
    const span = state.endBp - state.startBp;
    if (span <= 0 || isNaN(span)) {
      // Invalid span, keep previous pxPerBp or use default
      if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
        state.pxPerBp = 1;
      }
      return;
    }
    if (isVerticalMode()) {
      const h = tracksHeightPx();
      if (h > 0 && !isNaN(h)) {
        state.pxPerBp = h / span;
      } else if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
        state.pxPerBp = 1;
      }
    } else {
      const w = tracksWidthPx();
      if (w > 0 && !isNaN(w)) {
        state.pxPerBp = w / span;
      } else if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
        state.pxPerBp = 1;
      }
    }
    // Final guard
    if (isNaN(state.pxPerBp) || state.pxPerBp <= 0) {
      state.pxPerBp = 1;
    }
  }

  // Calculate total insertion gap width for expanded insertions (in pixels)
  // Uses precomputed insertionGapPx from backend if available for performance
  function getTotalInsertionGapWidth() {
    let totalGap = 0;
    for (const variant of variants) {
      if (state.expandedInsertions.has(variant.id) && isInsertion(variant)) {
        // Use precomputed gap width if available (performance optimization)
        if (variant.hasOwnProperty('insertionGapPx')) {
          totalGap += variant.insertionGapPx;
        } else {
          // Fallback to computation for backward compatibility
          const maxInsertLen = getMaxInsertionLength(variant);
          totalGap += maxInsertLen * 8;
        }
      }
    }
    return totalGap;
  }
  
  // IMPORTANT: canonical genome-x mapping for the right pane (tracks/canvases)
  // Accounts for expanded insertion gaps
  function xGenomeCanonical(bp, W) {
    // Guard against invalid inputs
    if (!W || W <= 0 || isNaN(W) || isNaN(bp)) {
      return 16; // Return leftPad as safe default
    }
    const leftPad = 16, rightPad = 16;
    const innerW = Math.max(0, W - leftPad - rightPad);
    if (innerW <= 0) {
      return leftPad;
    }
    const span = state.endBp - state.startBp;
    if (span <= 0 || isNaN(span)) {
      return leftPad;
    }
    // Guard against invalid pxPerBp
    if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
      return leftPad;
    }
    const totalGapPx = getTotalInsertionGapWidth();
    const totalGapBp = totalGapPx / state.pxPerBp;
    if (isNaN(totalGapBp)) {
      return leftPad;
    }
    const effectiveSpan = span + totalGapBp;
    if (effectiveSpan <= 0 || isNaN(effectiveSpan)) {
      return leftPad;
    }
    
    // Calculate x position, accounting for insertion gaps before this position
    // Uses optimized binary search lookup if available for O(log n) performance
    const accumulatedGapPx = getAccumulatedGapPx(bp, state.expandedInsertions);
    
    const bpOffset = bp - state.startBp;
    const accumulatedGapBp = accumulatedGapPx / state.pxPerBp;
    if (isNaN(accumulatedGapBp) || isNaN(bpOffset)) {
      return leftPad;
    }
    const normalizedPos = (bpOffset + accumulatedGapBp) / effectiveSpan;
    if (isNaN(normalizedPos)) {
      return leftPad;
    }
    
    const result = leftPad + normalizedPos * innerW;
    return isNaN(result) ? leftPad : Math.max(leftPad, Math.min(leftPad + innerW, result));
  }
  
  function xGenome(bp) {
    return xGenomeCanonical(bp, tracksWidthPx());
  }
  
  function bpFromXGenome(xPx, W) {
    const leftPad = 16, rightPad = 16;
    const innerW = W - leftPad - rightPad;
    const span = state.endBp - state.startBp;
    const totalGapPx = getTotalInsertionGapWidth();
    const totalGapBp = totalGapPx / state.pxPerBp;
    const effectiveSpan = span + totalGapBp;
    const t = (xPx - leftPad) / innerW;
    
    // Reverse calculation accounting for gaps - iterative refinement
    // Uses optimized binary search lookup for O(log n) performance per iteration
    let bpEstimate = state.startBp + t * effectiveSpan;
    for (let iter = 0; iter < 5; iter++) {
      const accumulatedGapPx = getAccumulatedGapPx(bpEstimate, state.expandedInsertions);
      const accumulatedGapBp = accumulatedGapPx / state.pxPerBp;
      bpEstimate = state.startBp + (t * effectiveSpan) - accumulatedGapBp;
    }
    
    return bpEstimate;
  }

  // Vertical mode coordinate mapping (genomic axis vertical: bottom=start, top=end)
  function yGenomeCanonical(bp, H) {
    // Guard against invalid inputs
    if (!H || H <= 0 || isNaN(H) || isNaN(bp)) {
      return 16; // Return topPad as safe default
    }
    const topPad = 16, bottomPad = 16;
    const innerH = Math.max(0, H - topPad - bottomPad);
    if (innerH <= 0) {
      return topPad;
    }
    const span = state.endBp - state.startBp;
    if (span <= 0 || isNaN(span)) {
      return topPad;
    }
    // Guard against invalid pxPerBp
    if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
      return topPad;
    }
    const totalGapPx = getTotalInsertionGapWidth();
    const totalGapBp = totalGapPx / state.pxPerBp;
    if (isNaN(totalGapBp)) {
      return topPad;
    }
    const effectiveSpan = span + totalGapBp;
    if (effectiveSpan <= 0 || isNaN(effectiveSpan)) {
      return topPad;
    }
    
    // Calculate y position, accounting for insertion gaps before this position
    // Uses optimized binary search lookup if available for O(log n) performance
    const accumulatedGapPx = getAccumulatedGapPx(bp, state.expandedInsertions);
    
    const bpOffset = bp - state.startBp;
    const accumulatedGapBp = accumulatedGapPx / state.pxPerBp;
    if (isNaN(accumulatedGapBp) || isNaN(bpOffset)) {
      return topPad;
    }
    const normalizedPos = (bpOffset + accumulatedGapBp) / effectiveSpan;
    if (isNaN(normalizedPos)) {
      return topPad;
    }
    
    // Invert: bottom (H - bottomPad) = start, top (topPad) = end
    const result = H - bottomPad - normalizedPos * innerH;
    return isNaN(result) ? topPad : Math.max(topPad, Math.min(H - bottomPad, result));
  }
  
  function yGenome(bp) {
    return yGenomeCanonical(bp, tracksHeightPx());
  }
  
  function tracksHeightPx() {
    if (!tracksSvg) return 0;
    const h = tracksSvg.getBoundingClientRect().height;
    return isNaN(h) || h <= 0 ? 0 : h;
  }
  
  function bpFromYGenome(yPx, H) {
    const topPad = 16, bottomPad = 16;
    const innerH = H - topPad - bottomPad;
    const span = state.endBp - state.startBp;
    const totalGapPx = getTotalInsertionGapWidth();
    const totalGapBp = totalGapPx / state.pxPerBp;
    const effectiveSpan = span + totalGapBp;
    
    // Invert: yPx is from top, but we want position from bottom
    const normalizedPos = (H - bottomPad - yPx) / innerH;
    const t = Math.max(0, Math.min(1, normalizedPos));
    
    // Reverse calculation accounting for gaps - iterative refinement
    // Uses optimized binary search lookup for O(log n) performance per iteration
    let bpEstimate = state.startBp + t * effectiveSpan;
    for (let iter = 0; iter < 5; iter++) {
      const accumulatedGapPx = getAccumulatedGapPx(bpEstimate, state.expandedInsertions);
      const accumulatedGapBp = accumulatedGapPx / state.pxPerBp;
      bpEstimate = state.startBp + (t * effectiveSpan) - accumulatedGapBp;
    }
    
    return bpEstimate;
  }

  function xColumn(i, totalColumns) {
    const W = flowWidthPx();
    if (!W || W <= 0 || isNaN(W) || isNaN(i)) {
      return 60;
    }
    const margin = 60;
    const innerW = Math.max(10, W - 2*margin);
    const numCols = totalColumns !== undefined ? totalColumns : state.K;
    if (numCols <= 1) return margin;
    const result = margin + (i / (numCols - 1)) * innerW;
    return isNaN(result) ? margin : result;
  }
  function yColumn(i, totalColumns) {
    const H = flowHeightPx();
    if (!H || H <= 0 || isNaN(H) || isNaN(i)) {
      return 60;
    }
    const margin = 60;
    const innerH = Math.max(10, H - 2*margin);
    const numCols = totalColumns !== undefined ? totalColumns : state.K;
    if (numCols <= 1) return margin;
    // Invert: index 0 (earliest variant) should be at bottom (higher Y), 
    // last index (latest variant) should be at top (lower Y)
    const result = margin + innerH - (i / (numCols - 1)) * innerH;
    return isNaN(result) ? margin : result;
  }

  // -----------------------------
  // Variant data: load from config or use demo data
  // -----------------------------
  let variants = [];
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.variants_data) {
    const data = window.GENOMESHADER_CONFIG.variants_data;
    // Data should already be an array of variant objects
    if (Array.isArray(data) && data.length > 0) {
      variants = data;
      console.log(`Loaded ${variants.length} variants from config`);
    } else {
      console.warn("Variants data is not in expected array format or is empty:", data);
      // Fall back to empty array or demo data
      variants = [];
    }
  } else {
    // Fall back to demo data if no config provided
    console.log("No variants_data found in GENOMESHADER_CONFIG, using demo data");
    variants = [
      { id: "v1", pos: 100_120, alleles: ["ref","a1"], refAllele: "A", altAlleles: ["A" + "ATCGATCGATCGATCGATCGATCGATCGAT"] }, // insertion example (30 bp inserted: ATCGATCGATCGATCGATCGATCGATCGAT)
      { id: "v2", pos: 100_240, alleles: ["ref","a1"] },
      { id: "v3", pos: 100_410, alleles: ["ref","a1","a2"] },
      { id: "v4", pos: 100_610, alleles: ["ref","a1"] },
      { id: "v5", pos: 100_720, alleles: ["ref","a1"] },
      { id: "v6", pos: 100_780, alleles: ["ref","a1"] },
      { id: "v7", pos: 100_860, alleles: ["ref","a1"] },
      { id: "v8", pos: 100_895, alleles: ["ref","a1"] },
      { id: "v9", pos: 100_930, alleles: ["ref","a1"] },
    ];
  }
  
  // Helper to check if variant is an insertion
  // Uses precomputed value from backend if available, otherwise computes it
  function isInsertion(variant) {
    // Use precomputed value if available (performance optimization)
    if (variant.hasOwnProperty('isInsertion')) {
      return variant.isInsertion === true;
    }
    // Fallback to computation for backward compatibility
    if (!variant.refAllele || !variant.altAlleles) return false;
    const refLen = variant.refAllele.length;
    return variant.altAlleles.some(alt => alt.length > refLen);
  }
  
  // Get the longest insertion allele length for a variant
  // Uses precomputed value from backend if available, otherwise computes it
  function getMaxInsertionLength(variant) {
    // Use precomputed value if available (performance optimization)
    if (variant.hasOwnProperty('maxInsertionLength')) {
      return variant.maxInsertionLength || 0;
    }
    // Fallback to computation for backward compatibility
    if (!variant.refAllele || !variant.altAlleles) return 0;
    const refLen = variant.refAllele.length;
    return Math.max(...variant.altAlleles.map(alt => Math.max(0, alt.length - refLen)));
  }

  // Precomputed sorted list of insertion variants for efficient coordinate transformations
  // Loaded from config if available
  let insertionVariantsLookup = [];
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.insertion_variants_lookup) {
    insertionVariantsLookup = window.GENOMESHADER_CONFIG.insertion_variants_lookup;
    console.log(`Loaded ${insertionVariantsLookup.length} insertion variants for coordinate transformation lookup`);
  }

  // Optimized function to get accumulated gap pixels up to a position
  // Uses binary search on precomputed sorted list for O(log n) performance
  // Filters by expanded insertions at runtime (since that's dynamic state)
  function getAccumulatedGapPx(bp, expandedInsertions) {
    if (!insertionVariantsLookup || insertionVariantsLookup.length === 0) {
      // Fallback to linear search if lookup table not available
      let accumulatedGapPx = 0;
      for (const variant of variants) {
        if (variant.pos < bp && expandedInsertions.has(variant.id) && isInsertion(variant)) {
          if (variant.hasOwnProperty('insertionGapPx')) {
            accumulatedGapPx += variant.insertionGapPx;
          } else {
            const maxInsertLen = getMaxInsertionLength(variant);
            accumulatedGapPx += maxInsertLen * 8;
          }
        }
      }
      return accumulatedGapPx;
    }

    // Binary search to find all insertion variants before position bp
    let left = 0;
    let right = insertionVariantsLookup.length - 1;
    let lastIndex = -1;
    
    // Find the rightmost insertion variant with pos < bp
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (insertionVariantsLookup[mid].pos < bp) {
        lastIndex = mid;
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    // Sum gaps for all variants up to lastIndex that are expanded
    let accumulatedGapPx = 0;
    for (let i = 0; i <= lastIndex; i++) {
      const lookupVariant = insertionVariantsLookup[i];
      if (expandedInsertions.has(lookupVariant.id)) {
        accumulatedGapPx += lookupVariant.insertionGapPx;
      }
    }
    
    return accumulatedGapPx;
  }

  // Genes: load from config or use empty array as fallback
  // Note: transcripts_data now contains gene models (exon union) instead of individual transcripts
  let transcripts = [];
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.transcripts_data) {
    const data = window.GENOMESHADER_CONFIG.transcripts_data;
    // Data should already be an array of gene model objects
    if (Array.isArray(data)) {
      transcripts = data;
      console.log(`Loaded ${transcripts.length} gene models for genes track`);
    } else {
      console.warn("Gene models data is not in expected array format:", data);
    }
  } else {
    console.warn("No transcripts_data found in GENOMESHADER_CONFIG:", window.GENOMESHADER_CONFIG);
  }

  // RepeatMasker: load from config or use empty array as fallback
  let repeats = [];
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.repeats_data) {
    const data = window.GENOMESHADER_CONFIG.repeats_data;
    // Data should already be an array of repeat objects with start, end, cls
    if (Array.isArray(data)) {
      repeats = data;
      console.log(`Loaded ${repeats.length} repeats for RepeatMasker track`);
    } else {
      console.warn("Repeats data is not in expected array format:", data);
    }
  } else {
    console.warn("No repeats_data found in GENOMESHADER_CONFIG:", window.GENOMESHADER_CONFIG);
  }

  // Reference sequence: load from config or use empty string as fallback
  let referenceSequence = "";
  if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.reference_data) {
    const data = window.GENOMESHADER_CONFIG.reference_data;
    // Data should be a string containing the DNA sequence
    if (typeof data === 'string') {
      referenceSequence = data;
      console.log(`Loaded reference sequence of length ${referenceSequence.length} bases`);
    } else {
      console.warn("Reference data is not in expected string format:", data);
    }
  } else {
    console.warn("No reference_data found in GENOMESHADER_CONFIG:", window.GENOMESHADER_CONFIG);
  }

  // -----------------------------
  // SVG helpers
  // -----------------------------
  const SVGNS = "http://www.w3.org/2000/svg";
  function clearSvg(svg) { while (svg.firstChild) svg.removeChild(svg.firstChild); }
  function el(tag, attrs = {}, text = null) {
    const n = document.createElementNS(SVGNS, tag);
    for (const [k,v] of Object.entries(attrs)) {
      // Skip null/undefined values
      if (v == null) {
        continue;
      }
      
      let value = v;
      
      // Check if value is already NaN (number or string "NaN")
      if (typeof value === 'number' && isNaN(value)) {
        console.warn(`Genomeshader: NaN value for ${k} in <${tag}>, using 0`);
        value = 0;
      } else if (typeof value === 'string' && (value === 'NaN' || value.toLowerCase() === 'nan')) {
        console.warn(`Genomeshader: "NaN" string for ${k} in <${tag}>, using 0`);
        value = 0;
      } else {
        // Validate numeric attributes that must be non-negative
        if (['width', 'height', 'r', 'rx', 'ry'].includes(k)) {
          // Handle both number and string inputs
          let numVal;
          if (typeof value === 'number') {
            numVal = value;
          } else {
            numVal = parseFloat(value);
          }
          
          // Check for NaN first
          if (isNaN(numVal)) {
            console.warn(`Genomeshader: Invalid ${k} value ${v} (NaN) for <${tag}>, using 0`);
            value = 0;
          } 
          // Check for negative values - SVG doesn't allow negative width/height
          else if (numVal < 0) {
            console.warn(`Genomeshader: Invalid ${k} value ${v} (negative) for <${tag}>, using 0`);
            value = 0;
          } 
          // Use the parsed/validated number
          else {
            value = numVal;
          }
        }
        // Validate position attributes that must be valid numbers (can be negative for positioning)
        else if (['x', 'y', 'x1', 'x2', 'y1', 'y2', 'cx', 'cy'].includes(k)) {
          const numVal = parseFloat(value);
          if (isNaN(numVal)) {
            console.warn(`Genomeshader: Invalid ${k} value ${v} (NaN) for <${tag}>, using 0`);
            value = 0;
          } else {
            value = numVal; // Use parsed number (can be negative for positioning)
          }
        }
        // For any other numeric-looking attribute, validate it's not NaN
        else if (typeof value === 'number' && isNaN(value)) {
          console.warn(`Genomeshader: NaN value for ${k} in <${tag}>, using 0`);
          value = 0;
        }
      }
      
      n.setAttribute(k, String(value));
    }
    if (text !== null) n.textContent = text;
    return n;
  }

  // -----------------------------
  // "Nice" tick selection for ruler
  // -----------------------------
  function trimZeros(s) {
    return s.replace(/\.0+$/, "").replace(/(\.\d*[1-9])0+$/, "$1");
  }
  function formatBp(bp, spanBp = null) {
    // Determine precision based on span if provided
    let kbPrecision = 1;
    
    if (spanBp !== null) {
      if (spanBp < 100) {
        // Very zoomed in - show full base pair position with commas
        return `${Math.round(bp).toLocaleString()} bp`;
      } else if (spanBp < 1_000) {
        // Zoomed in - show more decimal places for kb
        kbPrecision = 2;
      } else if (spanBp < 10_000) {
        // Moderately zoomed - show 2 decimal places
        kbPrecision = 2;
      } else {
        // Normal zoom - show 1 decimal place
        kbPrecision = 1;
      }
    }
    
    if (bp >= 1_000_000) return `${trimZeros((bp / 1_000_000).toFixed(2))} Mb`;
    if (bp >= 1_000)     return `${trimZeros((bp / 1_000).toFixed(kbPrecision))} kb`;
    return `${bp} bp`;
  }
  function chooseNiceTickBp(spanBp, desiredTicks) {
    const target = spanBp / desiredTicks;
    const pow = Math.pow(10, Math.floor(Math.log10(target)));
    const candidates = [1,2,5,10].map(m => m*pow);
    let best = candidates[0], bestDiff = Infinity;
    for (const c of candidates) {
      const diff = Math.abs((spanBp / c) - desiredTicks);
      if (diff < bestDiff) { bestDiff = diff; best = c; }
    }
    return best;
  }

  // -----------------------------
  // Track layout calculation
  // -----------------------------
  function getTrackLayout() {
    const layout = [];
    const headerH = 24;
    const padding = 8;
    const isVertical = isVerticalMode();

    if (isVertical) {
      // Vertical mode: tracks side-by-side (left/width based)
      let currentX = 0;
      const mainHeight = rectH(main);
      // Ensure mainHeight is valid
      const safeMainHeight = (isNaN(mainHeight) || mainHeight <= 0) ? 0 : mainHeight;
      
      for (const track of state.tracks) {
        const effectiveWidth = track.collapsed ? headerH : (headerH + (track.height || 0));
        const safeContentLeft = currentX + headerH;
        const safeContentWidth = track.collapsed ? 0 : (track.height || 0);
        
        // Validate all values are numbers
        if (isNaN(currentX) || isNaN(effectiveWidth) || isNaN(safeContentLeft) || isNaN(safeContentWidth)) {
          console.warn('Genomeshader: Invalid layout values in vertical mode', { currentX, effectiveWidth, safeContentLeft, safeContentWidth, track: track.id });
          continue;
        }
        
        layout.push({
          track,
          left: currentX,
          width: effectiveWidth,
          contentLeft: safeContentLeft,
          contentWidth: safeContentWidth,
          // Also include top/height for compatibility
          top: 0,
          height: safeMainHeight,
          contentTop: 0,
          contentHeight: safeMainHeight
        });
        currentX += effectiveWidth; // no gap between tracks
      }
    } else {
      // Horizontal mode: tracks stacked vertically (top/height based)
      let currentY = 0;
      const mainWidth = rectW(main);
      // Ensure mainWidth is valid
      const safeMainWidth = (isNaN(mainWidth) || mainWidth <= 0) ? 0 : mainWidth;
      
      for (const track of state.tracks) {
        const effectiveHeight = track.collapsed ? headerH : (headerH + (track.height || 0));
        const safeContentTop = currentY + headerH;
        const safeContentHeight = track.collapsed ? 0 : (track.height || 0);
        
        // Validate all values are numbers
        if (isNaN(currentY) || isNaN(effectiveHeight) || isNaN(safeContentTop) || isNaN(safeContentHeight)) {
          console.warn('Genomeshader: Invalid layout values in horizontal mode', { currentY, effectiveHeight, safeContentTop, safeContentHeight, track: track.id });
          continue;
        }
        
        layout.push({
          track,
          top: currentY,
          height: effectiveHeight,
          contentTop: safeContentTop,
          contentHeight: safeContentHeight,
          // Also include left/width for compatibility
          left: 0,
          width: safeMainWidth,
          contentLeft: 0,
          contentWidth: safeMainWidth
        });
        currentY += effectiveHeight; // no gap between tracks
      }
    }

    return layout;
  }

  function updateTracksHeight() {
    const layout = getTrackLayout();
    const isVertical = isVerticalMode();
    // Exclude flow and reads from tracks height/width since they're positioned separately
    const tracksLayout = layout.filter(l => l.track.id !== "flow" && l.track.id !== "reads");
    if (isVertical) {
      const totalW = tracksLayout.length > 0 
        ? tracksLayout[tracksLayout.length - 1].left + tracksLayout[tracksLayout.length - 1].width
        : 0;
      // In vertical mode, tracks are side-by-side, so we don't need to set --tracks-h
      // But we might want to set a width variable if needed
    } else {
      const totalH = tracksLayout.length > 0 
        ? tracksLayout[tracksLayout.length - 1].top + tracksLayout[tracksLayout.length - 1].height
        : 0;
      // Use default height if calculation fails or returns 0
      const finalHeight = totalH > 0 ? totalH : 280; // Default to 280px if calculation fails
      document.documentElement.style.setProperty('--tracks-h', `${finalHeight}px`);
    }
  }

  // -----------------------------
  // Tracks rendering (ideogram + genes + repeats + ruler)
  // -----------------------------
  // Track retry attempts to avoid infinite loops
  let renderTracksRetryCount = 0;
  const MAX_RETRY_ATTEMPTS = 10;
  
  function renderTracks() {
    clearSvg(tracksSvg);
    // Clear variant element references
    state.locusVariantElements.clear();
    // Clear WebGPU renderer instances
    if (instancedRenderer) {
      instancedRenderer.clear();
    }
    repeatHitTestData = [];
    
    const isVertical = isVerticalMode();
    const W = isVertical ? tracksHeightPx() : tracksWidthPx();
    const H = isVertical ? tracksWidthPx() : tracksHeightPx();
    
    // Guard against invalid dimensions - retry if dimensions are not ready
    if (!W || W <= 0 || isNaN(W) || !H || H <= 0 || isNaN(H)) {
      if (renderTracksRetryCount < MAX_RETRY_ATTEMPTS) {
        renderTracksRetryCount++;
        // Try to update tracks height before retrying (might fix the dimension issue)
        updateTracksHeight();
        // Schedule a retry after a short delay to allow layout to settle
        setTimeout(() => {
          renderTracks();
        }, 50);
        return;
      } else {
        renderTracksRetryCount = 0; // Reset counter
        return;
      }
    }
    
    // Reset retry counter on successful render
    renderTracksRetryCount = 0;
    
    // Ensure pxPerBp is valid before rendering
    if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
      // Try to update derived values
      updateDerived();
      // Check again
      if (!state.pxPerBp || state.pxPerBp <= 0 || isNaN(state.pxPerBp)) {
        return;
      }
    }
    
    const layout = getTrackLayout();
    
    // Coordinate mapping functions based on orientation
    const genomePos = isVertical ? yGenome.bind(null) : xGenome.bind(null);
    // In vertical mode, use tracksHeightPx() for Y coordinate (genomic axis is vertical)
    // In horizontal mode, use W (tracksWidthPx()) for X coordinate (genomic axis is horizontal)
    const genomePosCanonical = isVertical 
      ? (bp) => yGenomeCanonical(bp, tracksHeightPx())
      : (bp) => xGenomeCanonical(bp, W);
    
    // Find track positions (needed to exclude ideogram from shading)
    const ideogramLayout = layout.find(l => l.track.id === "ideogram");
    const genesLayout = layout.find(l => l.track.id === "genes");
    const repeatsLayout = layout.find(l => l.track.id === "repeats");
    const rulerLayout = layout.find(l => l.track.id === "ruler");
    const referenceLayout = layout.find(l => l.track.id === "reference");
    const flowLayout = layout.find(l => l.track.id === "flow");
    const readsLayout = layout.find(l => l.track.id === "reads");
    
    // Calculate ideogram track bounds to exclude from shading (including track controls header)
    let ideogramTrackStart = 0;
    let ideogramTrackEnd = 0;
    if (ideogramLayout && !ideogramLayout.track.collapsed) {
      if (isVertical) {
        // In vertical mode, ideogram is on the left side (x-axis)
        // Use left/width to include the track controls header area
        ideogramTrackStart = ideogramLayout.left;
        ideogramTrackEnd = ideogramLayout.left + ideogramLayout.width;
      } else {
        // In horizontal mode, ideogram is at the top (y-axis)
        // Use top/height to include the track controls header area
        ideogramTrackStart = ideogramLayout.top;
        ideogramTrackEnd = ideogramLayout.top + ideogramLayout.height;
      }
    }
    
    // Draw data bounds overlays across all tracks except ideogram (if data bounds exist and differ from view)
    if (dataBounds && (dataBounds.start > state.startBp || dataBounds.end < state.endBp)) {
      const dataStartPos = genomePos(dataBounds.start);
      const dataEndPos = genomePos(dataBounds.end);
      
      // Find the tracks container bounds
      const tracksContainer = document.getElementById("tracksContainer");
      if (tracksContainer) {
        const containerRect = tracksContainer.getBoundingClientRect();
        const svgRect = tracksSvg.getBoundingClientRect();
        
        // Helper function to draw out-of-bounds shading (darker)
        const drawOutOfBoundsRect = (x, y, width, height) => {
          tracksSvg.appendChild(el("rect", {
            x: x,
            y: y,
            width: width,
            height: height,
            fill: "rgba(127,127,127,0.15)", // Darker for out-of-bounds
            "pointer-events": "none",
            "class": "data-bounds-overlay"
          }));
        };
        
        if (isVertical) {
          // In vertical mode, Y axis is inverted: bottom (higher Y) = smaller bp, top (lower Y) = larger bp
          // dataStartPos = Y position of dataBounds.start (smaller bp → higher Y, near bottom)
          // dataEndPos = Y position of dataBounds.end (larger bp → lower Y, near top)
          
          // Out-of-bounds region below data (smaller bp than dataBounds.start)
          // dataBounds.start > state.startBp means view extends to show bp < dataBounds.start
          // In vertical mode: smaller bp → higher Y → bottom of screen
          // So out-of-bounds is from dataStartPos to H (bottom)
          if (dataBounds.start > state.startBp) {
            const overlayY1 = Math.max(dataStartPos, 0);
            const overlayY2 = H;
            if (overlayY2 > overlayY1) {
              if (ideogramTrackEnd > 0) {
                // Left side of ideogram track
                if (ideogramTrackStart > 0) {
                  drawOutOfBoundsRect(0, overlayY1, ideogramTrackStart, overlayY2 - overlayY1);
                }
                // Right side of ideogram track
                if (ideogramTrackEnd < W) {
                  drawOutOfBoundsRect(ideogramTrackEnd, overlayY1, W - ideogramTrackEnd, overlayY2 - overlayY1);
                }
              } else {
                // No ideogram track, draw full width
                drawOutOfBoundsRect(0, overlayY1, W, overlayY2 - overlayY1);
              }
            }
          }
          
          // Out-of-bounds region above data (larger bp than dataBounds.end)
          // dataBounds.end < state.endBp means view extends to show bp > dataBounds.end
          // In vertical mode: larger bp → lower Y → top of screen
          // So out-of-bounds is from 0 to dataEndPos (top)
          if (dataBounds.end < state.endBp) {
            const overlayY1 = 0;
            const overlayY2 = Math.min(dataEndPos, H);
            if (overlayY2 > overlayY1) {
              if (ideogramTrackEnd > 0) {
                // Left side of ideogram track
                if (ideogramTrackStart > 0) {
                  drawOutOfBoundsRect(0, overlayY1, ideogramTrackStart, overlayY2 - overlayY1);
                }
                // Right side of ideogram track
                if (ideogramTrackEnd < W) {
                  drawOutOfBoundsRect(ideogramTrackEnd, overlayY1, W - ideogramTrackEnd, overlayY2 - overlayY1);
                }
              } else {
                // No ideogram track, draw full width
                drawOutOfBoundsRect(0, overlayY1, W, overlayY2 - overlayY1);
              }
            }
          }
        } else {
          // Horizontal mode - exclude ideogram track area
          // Region before data start (out-of-bounds, darker)
          if (dataBounds.start > state.startBp) {
            const overlayX1 = 0;
            const overlayX2 = dataStartPos;
            if (ideogramTrackEnd > 0) {
              // Top side of ideogram track
              if (ideogramTrackStart > 0) {
                drawOutOfBoundsRect(overlayX1, 0, overlayX2 - overlayX1, ideogramTrackStart);
              }
              // Bottom side of ideogram track
              if (ideogramTrackEnd < H) {
                drawOutOfBoundsRect(overlayX1, ideogramTrackEnd, overlayX2 - overlayX1, H - ideogramTrackEnd);
              }
            } else {
              // No ideogram track, draw full height
              drawOutOfBoundsRect(overlayX1, 0, overlayX2 - overlayX1, H);
            }
          }
          
          // Region after data end (out-of-bounds, darker)
          if (dataBounds.end < state.endBp) {
            const overlayX1 = dataEndPos;
            const overlayX2 = W;
            if (ideogramTrackEnd > 0) {
              // Top side of ideogram track
              if (ideogramTrackStart > 0) {
                drawOutOfBoundsRect(overlayX1, 0, overlayX2 - overlayX1, ideogramTrackStart);
              }
              // Bottom side of ideogram track
              if (ideogramTrackEnd < H) {
                drawOutOfBoundsRect(overlayX1, ideogramTrackEnd, overlayX2 - overlayX1, H - ideogramTrackEnd);
              }
            } else {
              // No ideogram track, draw full height
              drawOutOfBoundsRect(overlayX1, 0, overlayX2 - overlayX1, H);
            }
          }
        }
      }
    }

    if (!ideogramLayout || !genesLayout || !repeatsLayout || !rulerLayout || !referenceLayout || !flowLayout || !readsLayout) return;

    // Ideogram layout
    if (!ideogramLayout.track.collapsed) {
      // Validate layout properties before using them
      const contentLeft = ideogramLayout.contentLeft;
      const contentTop = ideogramLayout.contentTop;
      if (isNaN(contentLeft) || isNaN(contentTop)) {
        console.warn('Genomeshader: Invalid ideogram layout values', { contentLeft, contentTop });
        return;
      }
      
      let ideogramX, ideogramY, ideogramW, ideogramH;
      if (isVertical) {
        ideogramX = (isNaN(contentLeft) ? 0 : contentLeft) + 12;
        ideogramW = 16;
        // Leave space at bottom for chromosome label, start ideogram higher
        ideogramY = 16;
        // In vertical mode, ideogram spans the genomic axis (W dimension, which is SVG height)
        // Leave space at bottom (about 40px) for the chromosome label
        ideogramH = Math.max(0, W - 32 - 40);
      } else {
        ideogramY = (isNaN(contentTop) ? 0 : contentTop) + 12;
        ideogramH = 16;
        ideogramX = 16;
        ideogramW = Math.max(0, W - 32);
      }
      
      // Final validation of calculated values
      if (isNaN(ideogramX) || isNaN(ideogramY) || isNaN(ideogramW) || isNaN(ideogramH) || 
          ideogramW <= 0 || ideogramH <= 0) {
        console.warn('Genomeshader: Invalid ideogram dimensions', { ideogramX, ideogramY, ideogramW, ideogramH });
        return;
      }

      // --- Chromosome label
      if (isVertical) {
        // Position chromosome label at the bottom
        const labelY = W - 16;
        tracksSvg.appendChild(el("text", {
          x: ideogramX + ideogramW/2 + 1,
          y: labelY,
          class: "svg-chr",
          "text-anchor": "middle",
          "dominant-baseline": "middle",
          transform: "rotate(-90 " + (ideogramX + ideogramW/2) + " " + labelY + ")"
        }, state.contig));
      } else {
        tracksSvg.appendChild(el("text", {
          x: 16,
          y: ideogramY + ideogramH/2 + 1,
          class: "svg-chr",
          "dominant-baseline": "middle"
        }, state.contig));
      }

      // --- Ideogram (p/q arm rounded rects + cytobands clipped inside)
      const bandX = isVertical ? ideogramX : 70;
      const bandY = isVertical ? ideogramY : ideogramY;
      const bandW = isVertical ? ideogramW : Math.max(0, W - bandX - 16);
      // In vertical mode, bandH should use the full available height
      const bandH = isVertical ? ideogramH : ideogramH;
      
      // Validate band dimensions before using them
      if (isNaN(bandX) || isNaN(bandY) || isNaN(bandW) || isNaN(bandH) || 
          bandW <= 0 || bandH <= 0) {
        console.warn('Genomeshader: Invalid band dimensions', { bandX, bandY, bandW, bandH, ideogramX, ideogramY, ideogramW, ideogramH, W, H });
        return;
      }

      // Use global chromosome lengths for mapping cytoband positions
      const chrLength = getChromosomeLength();
      
      // Get ideogram data from config (already parsed from JSON in Python)
      let ideogramData = [];
      if (window.GENOMESHADER_CONFIG && window.GENOMESHADER_CONFIG.ideogram_data) {
        const data = window.GENOMESHADER_CONFIG.ideogram_data;
        // Data should already be an array, but ensure it is
        if (Array.isArray(data)) {
          ideogramData = data;
        } else {
          console.warn("Ideogram data is not in expected array format:", data);
        }
      }
      
      // Find centromere position to determine p/q arm split
      let centromereStart = null;
      let centromereEnd = null;
      for (const band of ideogramData) {
        if (band.gieStain === "acen") {
          if (centromereStart === null) {
            centromereStart = band.chromStart;
          }
          centromereEnd = band.chromEnd;
        }
      }
      
      // Calculate actual p/q arm proportions based on centromere position
      // If no centromere found, use approximate position (p-arm is typically ~48% of chromosome)
      const defaultPFrac = 0.48;
      const centromerePos = centromereStart !== null ? centromereStart : Math.floor(chrLength * defaultPFrac);
      const pFrac = centromerePos / chrLength;
      const qFrac = 1 - pFrac;

      let pX, pY, pW, pH, qX, qY, qW, qH;
      if (isVertical) {
        // In vertical mode, arms are vertical (p-arm bottom, q-arm top)
        pH = Math.max(10, Math.floor(bandH * pFrac));
        qH = Math.max(10, Math.floor(bandH * qFrac));
        pW = qW = bandW;
        pX = qX = bandX;
        pY = bandY + bandH - pH; // p-arm at bottom
        qY = bandY; // q-arm at top
      } else {
        // Horizontal mode: arms are horizontal
        pW = Math.max(10, Math.floor(bandW * pFrac));
        qW = Math.max(10, Math.floor(bandW * qFrac));
        pH = qH = bandH;
        pX = bandX;
        qX = bandX + pW;
        pY = qY = bandY;
      }
      
      // Validate all calculated arm positions and dimensions
      if (isNaN(pX) || isNaN(pY) || isNaN(pW) || isNaN(pH) ||
          isNaN(qX) || isNaN(qY) || isNaN(qW) || isNaN(qH) ||
          pW <= 0 || pH <= 0 || qW <= 0 || qH <= 0) {
        console.warn('Genomeshader: Invalid arm dimensions', { pX, pY, pW, pH, qX, qY, qW, qH });
        return;
      }

      // defs + clipPath that matches both arms
      const defs = el("defs");
      const clipId = "chrClip";
      const clip = el("clipPath", { id: clipId });

      const armStroke = "rgba(127,127,127,0.22)";
      const armFill = "rgba(127,127,127,0.12)";

      const pArm = el("rect", { x: pX, y: pY, width: pW, height: pH, rx: 9, fill: armFill, stroke: armStroke });
      const qArm = el("rect", { x: qX, y: qY, width: qW, height: qH, rx: 9, fill: armFill, stroke: armStroke });

      clip.appendChild(el("rect", { x: pX, y: pY, width: pW, height: pH, rx: 9 }));
      clip.appendChild(el("rect", { x: qX, y: qY, width: qW, height: qH, rx: 9 }));

      defs.appendChild(clip);
      tracksSvg.appendChild(defs);

      tracksSvg.appendChild(pArm);
      tracksSvg.appendChild(qArm);
      
      // Calculate p-arm and q-arm lengths in base pairs
      const pArmLength = centromerePos;
      const qArmLength = chrLength - centromerePos;
      
      const bandInnerX = isVertical ? bandX - 2 : bandX;
      const bandInnerY = isVertical ? bandY : bandY - 2;
      const bandInnerW = isVertical ? bandW + 4 : bandW;
      const bandInnerH = isVertical ? bandH : bandH + 4;
      
      // Render each cytoband
      for (const band of ideogramData) {
        const bandStart = band.chromStart;
        const bandEnd = band.chromEnd;
        const isCentromere = band.gieStain === "acen";
        const isPArm = bandEnd <= centromerePos;
        
        // Determine which arm and calculate position
        let bandPos, bandSize;
        if (isPArm) {
          // p-arm: map from 0 to pArmLength onto p-arm dimensions
          const pFracStart = bandStart / pArmLength;
          const pFracEnd = bandEnd / pArmLength;
          const pFracSize = (bandEnd - bandStart) / pArmLength;
          
          if (isVertical) {
            // p-arm is at bottom, so we go from bottom up
            bandPos = pY + pH - (pFracEnd * pH);
            bandSize = pFracSize * pH;
          } else {
            // p-arm is on left
            bandPos = pX + (pFracStart * pW);
            bandSize = pFracSize * pW;
          }
        } else {
          // q-arm: map from centromerePos to chrLength onto q-arm dimensions
          const qFracStart = (bandStart - centromerePos) / qArmLength;
          const qFracEnd = (bandEnd - centromerePos) / qArmLength;
          const qFracSize = (bandEnd - bandStart) / qArmLength;
          
          if (isVertical) {
            // q-arm is at top
            bandPos = qY + (qFracStart * qH);
            bandSize = qFracSize * qH;
          } else {
            // q-arm is on right
            bandPos = qX + (qFracStart * qW);
            bandSize = qFracSize * qW;
          }
        }
        
        // Convert color from hex to rgba for better visibility
        const color = band.color || "#808080";
        let fillColor, strokeColor, strokeWidth;
        if (isCentromere) {
          fillColor = "rgba(255,77,77,0.35)";
          strokeColor = "none";
          strokeWidth = 0;
        } else {
          // Convert hex to rgba with opacity
          const r = parseInt(color.slice(1, 3), 16);
          const g = parseInt(color.slice(3, 5), 16);
          const b = parseInt(color.slice(5, 7), 16);
          // Adjust opacity based on color intensity (darker = more opaque)
          const intensity = (r + g + b) / 3;
          const opacity = 0.1 + (1 - intensity / 255) * 0.3;
          fillColor = `rgba(${r},${g},${b},${opacity})`;
          strokeColor = "none";
          strokeWidth = 0;
        }
        
        if (isVertical) {
          tracksSvg.appendChild(el("rect", {
            x: bandInnerX,
            y: bandPos,
            width: bandInnerW,
            height: Math.max(1, bandSize),
            fill: fillColor,
            stroke: strokeColor,
            "stroke-width": strokeWidth,
            "clip-path": `url(#${clipId})`
          }));
        } else {
          tracksSvg.appendChild(el("rect", {
            x: bandPos,
            y: bandInnerY,
            width: Math.max(1, bandSize),
            height: bandInnerH,
            fill: fillColor,
            stroke: strokeColor,
            "stroke-width": strokeWidth,
            "clip-path": `url(#${clipId})`
          }));
        }
      }

      // Locus highlight - small red rectangle showing current view position
      const locusCenter = (state.startBp + state.endBp) / 2;
      const locusFrac = locusCenter / chrLength;
      
      // Determine if locus is on p-arm or q-arm
      const isLocusPArm = locusCenter <= centromerePos;
      
      if (isVertical) {
        let locusY, locusHighlightHeight = 12;
        if (isLocusPArm) {
          // p-arm is at bottom
          const pFrac = locusCenter / pArmLength;
          locusY = pY + pH - (pFrac * pH);
        } else {
          // q-arm is at top
          const qFrac = (locusCenter - centromerePos) / qArmLength;
          locusY = qY + (qFrac * qH);
        }
        const locusHighlightY = Math.max(
          isLocusPArm ? pY : qY,
          Math.min(
            (isLocusPArm ? pY + pH : qY + qH) - locusHighlightHeight,
            locusY - locusHighlightHeight / 2
          )
        );
        
        tracksSvg.appendChild(el("rect", {
          x: (isLocusPArm ? pX : qX) - 1,
          y: locusHighlightY,
          width: (isLocusPArm ? pW : qW) + 2,
          height: locusHighlightHeight,
          fill: "rgba(255,77,77,0.25)",
          stroke: "rgba(255,77,77,0.95)",
          "stroke-width": 1
        }));
      } else {
        let locusX, locusHighlightWidth = 12;
        if (isLocusPArm) {
          // p-arm is on left
          const pFrac = locusCenter / pArmLength;
          locusX = pX + (pFrac * pW);
        } else {
          // q-arm is on right
          const qFrac = (locusCenter - centromerePos) / qArmLength;
          locusX = qX + (qFrac * qW);
        }
        const locusHighlightX = Math.max(
          isLocusPArm ? pX : qX,
          Math.min(
            (isLocusPArm ? pX + pW : qX + qW) - locusHighlightWidth,
            locusX - locusHighlightWidth / 2
          )
        );
        
        tracksSvg.appendChild(el("rect", {
          x: locusHighlightX,
          y: (isLocusPArm ? pY : qY) - 1,
          width: locusHighlightWidth,
          height: (isLocusPArm ? pH : qH) + 2,
          fill: "rgba(255,77,77,0.25)",
          stroke: "rgba(255,77,77,0.95)",
          "stroke-width": 1
        }));
      }
    }

    // --- Genes track (exons/introns/strand)
    if (!genesLayout.track.collapsed) {
      let geneStartX, geneStartY, laneDim, lanes, genesDim;
      if (isVertical) {
        geneStartX = genesLayout.contentLeft + 8;
        laneDim = 30;
        lanes = 3;
        genesDim = lanes * laneDim;
        geneStartY = 16;
      } else {
        geneStartY = genesLayout.contentTop + 8;
        laneDim = 30;
        lanes = 3;
        genesDim = lanes * laneDim;
        geneStartX = 16;
      }

      // Use WebGPU for lane separator lines if available
      const devicePixelRatio = window.devicePixelRatio || 1;
      const useWebGPU = webgpuSupported && instancedRenderer;
      
      for (let lane=0; lane<lanes; lane++) {
        if (isVertical) {
          const x = geneStartX + lane*laneDim + laneDim/2;
          if (useWebGPU) {
            instancedRenderer.addLine(
              x * devicePixelRatio, 16 * devicePixelRatio,
              x * devicePixelRatio, (H-16) * devicePixelRatio,
              0x7F7F7F, 0.14
            );
          } else {
            tracksSvg.appendChild(el("line", {
              x1: x, x2: x, y1: 16, y2: H-16,
              stroke: "rgba(127,127,127,0.14)"
            }));
          }
        } else {
          const y = geneStartY + lane*laneDim + laneDim/2;
          if (useWebGPU) {
            instancedRenderer.addLine(
              16 * devicePixelRatio, y * devicePixelRatio,
              (W-16) * devicePixelRatio, y * devicePixelRatio,
              0x7F7F7F, 0.14
            );
          } else {
            tracksSvg.appendChild(el("line", {
              x1: 16, x2: W-16, y1: y, y2: y,
              stroke: "rgba(127,127,127,0.14)"
            }));
          }
        }
      }

      function drawStrandArrows(pos1, pos2, perpPos, strand, isVert) {
        const dir = strand === "-" ? -1 : 1;
        const step = 24;
        const start = Math.min(pos1, pos2), end = Math.max(pos1, pos2);
        const devicePixelRatio = window.devicePixelRatio || 1;
        const useWebGPU = webgpuSupported && instancedRenderer;
        
        for (let p = start + 10; p < end - 10; p += step) {
          const size = 5;
          if (isVert) {
            const cy = p;
            if (useWebGPU) {
              // Triangle: tip at (perpPos, cy), base at (perpPos ± size*0.8, cy + dir*size)
              instancedRenderer.addTriangle(
                perpPos * devicePixelRatio, cy * devicePixelRatio,
                (perpPos - dir*size*0.8) * devicePixelRatio, (cy + dir*size) * devicePixelRatio,
                (perpPos + dir*size*0.8) * devicePixelRatio, (cy + dir*size) * devicePixelRatio,
                0x78B4FF, 0.50
              );
            } else {
              const p1 = `${perpPos},${cy}`;
              const p2 = `${perpPos - dir*size*0.8},${cy + dir*size}`;
              const p3 = `${perpPos + dir*size*0.8},${cy + dir*size}`;
              tracksSvg.appendChild(el("polygon", {
                points: `${p1} ${p2} ${p3}`,
                fill: "rgba(120,180,255,0.50)"
              }));
            }
          } else {
            const cx = p;
            if (useWebGPU) {
              // Triangle: tip at (cx, perpPos), base at (cx - dir*size, perpPos ± size*0.8)
              instancedRenderer.addTriangle(
                cx * devicePixelRatio, perpPos * devicePixelRatio,
                (cx - dir*size) * devicePixelRatio, (perpPos - size*0.8) * devicePixelRatio,
                (cx - dir*size) * devicePixelRatio, (perpPos + size*0.8) * devicePixelRatio,
                0x78B4FF, 0.50
              );
            } else {
              const p1 = `${cx},${perpPos}`;
              const p2 = `${cx - dir*size},${perpPos - size*0.8}`;
              const p3 = `${cx - dir*size},${perpPos + size*0.8}`;
              tracksSvg.appendChild(el("polygon", {
                points: `${p1} ${p2} ${p3}`,
                fill: "rgba(120,180,255,0.50)"
              }));
            }
          }
        }
      }

    // Iterate over gene models (transcripts variable now contains gene models)
    for (const gene of transcripts) {
      const s = Math.max(gene.start, state.startBp);
      const e = Math.min(gene.end,   state.endBp);
      if (e <= state.startBp || s >= state.endBp) continue;

      let perpPos;
      if (isVertical) {
        perpPos = geneStartX + gene.lane*laneDim + laneDim/2;
      } else {
        perpPos = geneStartY + gene.lane*laneDim + laneDim/2;
      }

      // intron baseline (full gene span)
      const pos1 = genomePos(s);
      const pos2 = genomePos(e);
      
      const devicePixelRatio = window.devicePixelRatio || 1;
      const useWebGPU = webgpuSupported && instancedRenderer;
      
      if (isVertical) {
        if (useWebGPU) {
          instancedRenderer.addLine(
            perpPos * devicePixelRatio, pos1 * devicePixelRatio,
            perpPos * devicePixelRatio, pos2 * devicePixelRatio,
            0x78B4FF, 0.45
          );
        } else {
          tracksSvg.appendChild(el("line", {
            x1: perpPos, x2: perpPos, y1: pos1, y2: pos2,
            stroke: "rgba(120,180,255,0.45)",
            "stroke-width": 1
          }));
        }
        drawStrandArrows(pos1, pos2, perpPos, gene.strand, true);
      } else {
        if (useWebGPU) {
          instancedRenderer.addLine(
            pos1 * devicePixelRatio, perpPos * devicePixelRatio,
            pos2 * devicePixelRatio, perpPos * devicePixelRatio,
            0x78B4FF, 0.45
          );
        } else {
          tracksSvg.appendChild(el("line", {
            x1: pos1, x2: pos2, y1: perpPos, y2: perpPos,
            stroke: "rgba(120,180,255,0.45)",
            "stroke-width": 1
          }));
        }
        drawStrandArrows(pos1, pos2, perpPos, gene.strand, false);
      }

      // exons - now with union model and universal/partial distinction
      let firstExonY = null; // Track bottom-most exon Y position for gene name alignment in vertical mode
      let firstExonX = null; // Track first exon X position for gene name alignment in horizontal mode
      for (const exon of gene.exons) {
        // Exon format: [start, end, is_universal]
        const es0 = exon[0];
        const ee0 = exon[1];
        const isUniversal = exon[2] === true || exon[2] === undefined; // Default to universal if not specified
        
        const es = Math.max(es0, state.startBp);
        const ee = Math.min(ee0, state.endBp);
        if (ee <= state.startBp || es >= state.endBp) continue;
        const exPos1 = genomePos(es);
        const exPos2 = genomePos(ee);

        const devicePixelRatio = window.devicePixelRatio || 1;
        const useWebGPU = webgpuSupported && instancedRenderer;
        
        // Determine colors based on universal vs partial
        // Universal: solid fill + full opacity stroke
        // Partial: very light fill + reduced opacity stroke
        const fillColor = isUniversal 
          ? [120/255, 180/255, 255/255, 0.18]  // Full opacity fill for universal
          : [120/255, 180/255, 255/255, 0.05]; // Very light fill for partial
        const strokeColor = isUniversal
          ? [120/255, 180/255, 255/255, 0.9]   // Full opacity stroke for universal
          : [120/255, 180/255, 255/255, 0.4]; // Reduced opacity stroke for partial
        
        if (isVertical) {
          // In vertical mode, exons are horizontal bars
          // exPos1 and exPos2 are Y coordinates, need to ensure correct ordering
          const yMin = Math.min(exPos1, exPos2);
          const yMax = Math.max(exPos1, exPos2);
          // Track the bottom-most exon's bottom Y position for gene name alignment
          // (yMax is the bottom of the exon in vertical mode where higher Y = bottom)
          // We want the highest Y value (bottom-most exon)
          if (firstExonY === null || yMax > firstExonY) {
            firstExonY = yMax;
          }
          
          const exonX = perpPos - 6;
          const exonY = yMin;
          const exonW = 12;
          const exonH = Math.max(2, yMax - yMin);
          
          if (useWebGPU) {
            // Draw fill (only if universal or very light for partial)
            if (isUniversal || fillColor[3] > 0) {
              instancedRenderer.addRect(
                exonX * devicePixelRatio,
                exonY * devicePixelRatio,
                exonW * devicePixelRatio,
                exonH * devicePixelRatio,
                fillColor
              );
            }
            // Draw stroke on top
            instancedRenderer.addRect(
              exonX * devicePixelRatio,
              exonY * devicePixelRatio,
              exonW * devicePixelRatio,
              exonH * devicePixelRatio,
              strokeColor
            );
          } else {
            // SVG fallback
            const rectAttrs = {
              x: exonX, y: exonY,
              width: exonW, height: exonH,
              rx: 4,
              stroke: isUniversal ? "var(--blue)" : "rgba(120,180,255,0.4)",
              "stroke-width": 1
            };
            // Only add fill for universal exons
            if (isUniversal) {
              rectAttrs.fill = "var(--blueFill)";
            } else {
              rectAttrs.fill = "rgba(120,180,255,0.05)";
            }
            tracksSvg.appendChild(el("rect", rectAttrs));
          }
        } else {
          // Track the first exon's X position for gene name alignment
          if (firstExonX === null) {
            firstExonX = exPos1;
          }
          
          const exonX = exPos1;
          const exonY = perpPos - 6;
          const exonW = Math.max(2, exPos2 - exPos1);
          const exonH = 12;
          
          if (useWebGPU) {
            // Draw fill (only if universal or very light for partial)
            if (isUniversal || fillColor[3] > 0) {
              instancedRenderer.addRect(
                exonX * devicePixelRatio,
                exonY * devicePixelRatio,
                exonW * devicePixelRatio,
                exonH * devicePixelRatio,
                fillColor
              );
            }
            // Draw stroke on top
            instancedRenderer.addRect(
              exonX * devicePixelRatio,
              exonY * devicePixelRatio,
              exonW * devicePixelRatio,
              exonH * devicePixelRatio,
              strokeColor
            );
          } else {
            // SVG fallback
            const rectAttrs = {
              x: exonX, y: exonY,
              width: exonW, height: exonH,
              rx: 4,
              stroke: isUniversal ? "var(--blue)" : "rgba(120,180,255,0.4)",
              "stroke-width": 1
            };
            // Only add fill for universal exons
            if (isUniversal) {
              rectAttrs.fill = "var(--blueFill)";
            } else {
              rectAttrs.fill = "rgba(120,180,255,0.05)";
            }
            tracksSvg.appendChild(el("rect", rectAttrs));
          }
        }
      }

      // gene label near gene start
      if (isVertical) {
        // Gene name to the left of the gene track
        // Y position should match the bottom of the bottom-most exon
        const geneNameY = firstExonY !== null ? firstExonY : pos1;
        tracksSvg.appendChild(el("text", {
          x: perpPos - 8,
          y: geneNameY,
          class:"svg-geneName",
          "text-anchor": "start",
          "dominant-baseline": "text-after-edge",
          transform: "rotate(-90 " + (perpPos - 8) + " " + geneNameY + ")"
        }, `${gene.name}`));
        // Strand indicator to the right of the gene track (just a bit to the right)
        tracksSvg.appendChild(el("text", {
          x: perpPos + 8,
          y: pos1,
          class:"svg-small",
          "text-anchor": "start",
          "dominant-baseline": "middle"
        }, gene.strand === "+" ? "↑" : "↓"));
      } else {
        // In horizontal mode, X position should match the first exon's X position
        const geneNameX = firstExonX !== null ? firstExonX : pos1;
        tracksSvg.appendChild(el("text", {
          x: geneNameX,
          y: perpPos - 12,
          class:"svg-geneName"
        }, `${gene.name}`));
        tracksSvg.appendChild(el("text", {
          x: pos1 + 2,
          y: perpPos + 16,
          class:"svg-small"
        }, gene.strand === "+" ? "→" : "←"));
      }
    }
    }

    // --- RepeatMasker track
    if (!repeatsLayout.track.collapsed) {
      let repeatsX, repeatsY, repeatsW, repeatsH;
      if (isVertical) {
        repeatsX = repeatsLayout.contentLeft + 8;
        repeatsW = 22;
        repeatsY = 16;
        // In vertical mode, repeatsH should use W (genomic axis dimension), not H
        repeatsH = W - 32;
      } else {
        repeatsY = repeatsLayout.contentTop + 8;
        repeatsH = 22;
        repeatsX = 16;
        repeatsW = W - 32;
      }

      // background guide line
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: repeatsX + repeatsW/2, x2: repeatsX + repeatsW/2, y1: 16, y2: W-16,
          stroke: "rgba(127,127,127,0.16)"
        }));
      } else {
        tracksSvg.appendChild(el("line", {
          x1: 16, x2: W-16, y1: repeatsY + repeatsH/2, y2: repeatsY + repeatsH/2,
          stroke: "rgba(127,127,127,0.16)"
        }));
      }

    function repeatColor(cls) {
      // simple palette-ish mapping; kept subtle
      switch (cls) {
        case "SINE": return "rgba(255, 206, 86, 0.35)";
        case "LINE": return "rgba(75, 192, 192, 0.28)";
        case "LTR":  return "rgba(153, 102, 255, 0.28)";
        case "DNA":  return "rgba(255, 99, 132, 0.22)";
        default:     return "rgba(201, 203, 207, 0.22)";
      }
    }

    function repeatColorToRgba(cls) {
      const rgbaStr = repeatColor(cls);
      // Parse "rgba(255, 206, 86, 0.35)" to [r, g, b, a] normalized
      const match = rgbaStr.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
      if (match) {
        return [
          parseInt(match[1]) / 255,
          parseInt(match[2]) / 255,
          parseInt(match[3]) / 255,
          parseFloat(match[4])
        ];
      }
      return [0.5, 0.5, 0.5, 0.5]; // fallback
    }

    // Optimize repeat rendering: filter, cluster, and batch DOM operations
    // Calculate minimum pixel width (don't render repeats smaller than 1 pixel)
    const minPixelWidth = 1;
    const clusterThreshold = 5; // Cluster repeats within 5bp of each other
    const maxRepeatsToRender = 5000; // Safety limit to prevent crashes

    // Filter and prepare visible repeats
    const visibleRepeats = [];
    for (const r of repeats) {
      if (r.end <= state.startBp || r.start >= state.endBp) continue;
      const rs = Math.max(r.start, state.startBp);
      const re = Math.min(r.end, state.endBp);
      
      const pos1 = genomePos(rs);
      const pos2 = genomePos(re);
      const width = Math.abs(pos2 - pos1);
      
      // Skip repeats that are too small to render
      if (width < minPixelWidth) continue;
      
      visibleRepeats.push({
        start: rs,  // Clamped start for rendering
        end: re,   // Clamped end for rendering
        originalStart: r.start,  // Original RepeatMasker start coordinate
        originalEnd: r.end,     // Original RepeatMasker end coordinate
        cls: r.cls,
        pos1: pos1,
        pos2: pos2,
        width: width
      });
    }

    // Sort by position for clustering
    visibleRepeats.sort((a, b) => a.start - b.start);

    // Cluster nearby repeats of the same class to reduce DOM elements
    const clusteredRepeats = [];
    let currentCluster = null;
    
    for (const r of visibleRepeats) {
      if (currentCluster && 
          r.cls === currentCluster.cls &&
          r.start - currentCluster.end <= clusterThreshold) {
        // Merge into current cluster
        currentCluster.end = Math.max(currentCluster.end, r.end);
        currentCluster.originalEnd = Math.max(currentCluster.originalEnd, r.originalEnd);
        currentCluster.pos2 = genomePos(currentCluster.end);
        currentCluster.width = Math.abs(currentCluster.pos2 - currentCluster.pos1);
      } else {
        // Start new cluster
        if (currentCluster) {
          clusteredRepeats.push(currentCluster);
        }
        currentCluster = {
          start: r.start,
          end: r.end,
          originalStart: r.originalStart,
          originalEnd: r.originalEnd,
          cls: r.cls,
          pos1: r.pos1,
          pos2: r.pos2,
          width: r.width
        };
      }
    }
    if (currentCluster) {
      clusteredRepeats.push(currentCluster);
    }

    // Limit the number of elements to render (take first N if too many)
    const repeatsToRender = clusteredRepeats.slice(0, maxRepeatsToRender);
    
    if (clusteredRepeats.length > maxRepeatsToRender) {
      console.warn(`Too many repeats (${clusteredRepeats.length}), rendering only first ${maxRepeatsToRender}`);
    }

    // Store repeat data for hit testing
    repeatHitTestData = [];
    
    // Use WebGPU if available, otherwise fall back to SVG
    if (webgpuSupported && instancedRenderer) {
      // Add rectangles to WebGPU renderer
      // Scale by devicePixelRatio since WebGPU canvas uses physical pixels
      const dpr = window.devicePixelRatio || 1;
      
      for (const r of repeatsToRender) {
        const pos1 = r.pos1;
        const pos2 = r.pos2;
        const width = Math.max(1, pos2 - pos1);
        const height = repeatsH - 8;
        
        let x, y, w, h;
        if (isVertical) {
          const yMin = Math.min(pos1, pos2);
          const yMax = Math.max(pos1, pos2);
          x = repeatsX + 4;
          y = yMin;
          w = repeatsW - 8;
          h = Math.max(1, yMax - yMin);
        } else {
          x = pos1;
          y = repeatsY + 4;
          w = width;
          h = height;
        }
        
        const rgba = repeatColorToRgba(r.cls);
        // Scale coordinates by DPR to match physical pixel canvas
        instancedRenderer.addRect(x * dpr, y * dpr, w * dpr, h * dpr, rgba);
        
        // Store for hit testing (use original RepeatMasker coordinates, not clamped/clustered)
        repeatHitTestData.push({
          start: r.originalStart,
          end: r.originalEnd,
          cls: r.cls
        });
      }
    } else {
      // Fallback to SVG rendering
      const fragment = document.createDocumentFragment();
      
      for (const r of repeatsToRender) {
        const pos1 = r.pos1;
        const pos2 = r.pos2;
        const isSmall = r.width < 3; // Don't add stroke for very small elements
        
        // Format tooltip text with repeat class and original coordinates
        const tooltipText = `${r.cls} repeat\n${Math.floor(r.originalStart).toLocaleString()} - ${Math.floor(r.originalEnd).toLocaleString()}`;
        
        // Create rect element
        let rect;
        if (isVertical) {
          const yMin = Math.min(pos1, pos2);
          const yMax = Math.max(pos1, pos2);
          rect = el("rect", {
            x: repeatsX + 4,
            y: yMin,
            width: repeatsW - 8,
            height: Math.max(1, yMax - yMin),
            rx: isSmall ? 0 : 6,
            fill: repeatColor(r.cls),
            style: "cursor: pointer;"
          });
          if (!isSmall) {
            rect.setAttribute("stroke", "rgba(127,127,127,0.20)");
          }
        } else {
          rect = el("rect", {
            x: pos1,
            y: repeatsY + 4,
            width: Math.max(1, pos2 - pos1),
            height: repeatsH - 8,
            rx: isSmall ? 0 : 6,
            fill: repeatColor(r.cls),
            style: "cursor: pointer;"
          });
          if (!isSmall) {
            rect.setAttribute("stroke", "rgba(127,127,127,0.20)");
          }
        }
        
        // Add mouse event handlers for tooltip
        rect.addEventListener("mousemove", (e) => {
          state.hoveredRepeatTooltip = {
            text: tooltipText,
            x: e.clientX + 10,
            y: e.clientY + 10
          };
          updateTooltip();
        });
        
        rect.addEventListener("mouseleave", () => {
          state.hoveredRepeatTooltip = null;
          updateTooltip();
        });
        
        fragment.appendChild(rect);
      }
      
      // Append all elements at once (single DOM operation)
      tracksSvg.appendChild(fragment);
    }
    }

    // --- Locus ruler
    if (!rulerLayout.track.collapsed) {
      let rulerX, rulerY, rulerW, rulerH, baseX, baseY;
      if (isVertical) {
        rulerX = rulerLayout.contentLeft + 8;
        rulerW = 56;
        rulerY = 16;
        rulerH = H - 32;
        baseX = rulerX + 14;
      } else {
        rulerY = rulerLayout.contentTop + 8;
        rulerH = 56;
        rulerX = 16;
        rulerW = W - 32;
        baseY = rulerY + 14;
      }

      // Base line
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: baseX, x2: baseX, y1: 16, y2: H-16,
          stroke: "rgba(127,127,127,0.70)",
          "stroke-width": 1.2
        }));
      } else {
        tracksSvg.appendChild(el("line", {
          x1: 16, x2: W-16, y1: baseY, y2: baseY,
          stroke: "rgba(127,127,127,0.70)",
          "stroke-width": 1.2
        }));
      }

      const span = state.endBp - state.startBp;
      const dim = isVertical ? H : W;
      const desiredMajorTicks = Math.max(5, Math.min(10, Math.floor((dim - 32) / 140)));
      const majorBp = chooseNiceTickBp(span, desiredMajorTicks);
      const minorBp = majorBp / 5;

      const pxPerMajor = (dim - 32) / (span / majorBp);
      const showLabels = pxPerMajor >= 80;

    const firstMinor = Math.ceil(state.startBp / minorBp) * minorBp;

    // Track major tick label positions to avoid overlap with edge labels
    const majorTickLabelPositions = [];

    for (let bp = firstMinor; bp <= state.endBp; bp += minorBp) {
      const pos = genomePos(bp);
      const isMajor = (Math.round(bp / minorBp) % 5) === 0;

      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: baseX - (isMajor ? 9 : 5), x2: baseX + (isMajor ? 9 : 5),
          y1: pos, y2: pos,
          stroke: isMajor ? "rgba(127,127,127,0.55)" : "rgba(127,127,127,0.30)",
          "stroke-width": isMajor ? 1.1 : 1
        }));

        if (isMajor && showLabels) {
          const textEl = el("text", {
            x: baseX + 26,
            y: pos,
            class: "svg-small",
            "text-anchor": "start",
            "dominant-baseline": "middle",
            transform: "rotate(-90 " + (baseX + 26) + " " + pos + ")"
          }, formatBp(Math.round(bp), span));
          tracksSvg.appendChild(textEl);
          majorTickLabelPositions.push(pos);
        }
      } else {
        tracksSvg.appendChild(el("line", {
          x1: pos, x2: pos,
          y1: baseY - (isMajor ? 9 : 5), y2: baseY + (isMajor ? 9 : 5),
          stroke: isMajor ? "rgba(127,127,127,0.55)" : "rgba(127,127,127,0.30)",
          "stroke-width": isMajor ? 1.1 : 1
        }));

        if (isMajor && showLabels) {
          tracksSvg.appendChild(el("text", {
            x: pos,
            y: baseY + 26,
            class: "svg-small",
            "text-anchor": "middle"
          }, formatBp(Math.round(bp), span)));
          majorTickLabelPositions.push(pos);
        }
      }
    }

    // Only show edge labels if no tick label is too close
    const edgeThreshold = 100; // pixels
    if (isVertical) {
      const bottomEdgeY = H - 16;
      const topEdgeY = 16;
      const hasNearbyBottomTick = majorTickLabelPositions.some(tickY => Math.abs(tickY - bottomEdgeY) < edgeThreshold);
      const hasNearbyTopTick = majorTickLabelPositions.some(tickY => Math.abs(tickY - topEdgeY) < edgeThreshold);

      if (!hasNearbyBottomTick) {
        const textEl = el("text", {
          x: baseX + 26, y: bottomEdgeY, class:"svg-small", "text-anchor":"start", "dominant-baseline":"middle",
          transform: "rotate(-90 " + (baseX + 26) + " " + bottomEdgeY + ")"
        }, formatBp(Math.round(state.startBp), span));
        tracksSvg.appendChild(textEl);
      }
      if (!hasNearbyTopTick) {
        const textEl = el("text", {
          x: baseX + 26, y: topEdgeY, class:"svg-small", "text-anchor":"start", "dominant-baseline":"middle",
          transform: "rotate(-90 " + (baseX + 26) + " " + topEdgeY + ")"
        }, formatBp(Math.round(state.endBp), span));
        tracksSvg.appendChild(textEl);
      }
    } else {
      const leftEdgeX = 16;
      const rightEdgeX = W - 16;
      const hasNearbyLeftTick = majorTickLabelPositions.some(tickX => Math.abs(tickX - leftEdgeX) < edgeThreshold);
      const hasNearbyRightTick = majorTickLabelPositions.some(tickX => Math.abs(tickX - rightEdgeX) < edgeThreshold);

      if (!hasNearbyLeftTick) {
        tracksSvg.appendChild(el("text", { x: 16, y: baseY + 26, class:"svg-small" },
          formatBp(Math.round(state.startBp), span)
        ));
      }
      if (!hasNearbyRightTick) {
        tracksSvg.appendChild(el("text", {
          x: W - 16, y: baseY + 26, class:"svg-small", "text-anchor":"end"
        }, formatBp(Math.round(state.endBp), span)));
      }
    }

    // Variant marks
    for (let idx = 0; idx < variants.length; idx++) {
      const v = variants[idx];
      if (v.pos < state.startBp || v.pos > state.endBp) continue;
      const pos = genomePos(v.pos);
      const isHovered = state.hoveredVariantIndex === idx;
      const strokeWidth = isHovered ? 2.5 : 1.2;
      const circleStrokeWidth = isHovered ? 2.2 : 1.4;
      const isIns = isInsertion(v);

      let lineEl;
      const strokeColor = isHovered ? "var(--blue)" : "rgba(127,127,127,0.5)";
      if (isVertical) {
        lineEl = el("line", {
          x1: baseX - 18, x2: baseX + 18,
          y1: pos, y2: pos,
          stroke: strokeColor,
          "stroke-width": strokeWidth,
          style: "cursor: pointer;",
          "data-variant-id": v.id
        });
      } else {
        lineEl = el("line", {
          x1: pos, x2: pos,
          y1: baseY - 18, y2: baseY + 18,
          stroke: strokeColor,
          "stroke-width": strokeWidth,
          style: "cursor: pointer;",
          "data-variant-id": v.id
        });
      }
      lineEl.addEventListener("mouseenter", () => {
        state.hoveredVariantIndex = idx;
        renderHoverOnly();
      });
      lineEl.addEventListener("mouseleave", () => {
        state.hoveredVariantIndex = null;
        renderHoverOnly();
      });
      
      // For insertions, add pointerdown handler to the line itself
      if (isInsertion(v)) {
        lineEl.style.pointerEvents = "auto";
        lineEl.addEventListener("pointerdown", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (state.expandedInsertions.has(v.id)) {
            state.expandedInsertions.delete(v.id);
          } else {
            state.expandedInsertions.add(v.id);
          }
          renderAll();
        });
      }
      tracksSvg.appendChild(lineEl);
      
      // Store reference to variant elements for hover updates
      if (!state.locusVariantElements.has(idx)) {
        state.locusVariantElements.set(idx, { lineEl: null, circleEl: null });
      }
      state.locusVariantElements.get(idx).lineEl = lineEl;
      
      // For insertions, add a larger invisible clickable area AFTER the line (so it's on top)
      if (isInsertion(v)) {
        // Add an invisible wider rectangle for easier clicking
        let clickArea;
        if (isVertical) {
          clickArea = el("rect", {
            x: baseX - 20,
            y: pos - 5,
            width: 40,
            height: 10,
            fill: "transparent",
            style: "cursor: pointer; pointer-events: auto;"
          });
        } else {
          clickArea = el("rect", {
            x: pos - 5,
            y: baseY - 20,
            width: 10,
            height: 40,
            fill: "transparent",
            style: "cursor: pointer; pointer-events: auto;"
          });
        }
        clickArea.addEventListener("pointerdown", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (state.expandedInsertions.has(v.id)) {
            state.expandedInsertions.delete(v.id);
          } else {
            state.expandedInsertions.add(v.id);
          }
          renderAll();
        });
        tracksSvg.appendChild(clickArea);
      }

      let circleEl;
      const circleStrokeColor = isHovered ? "var(--blue)" : "rgba(127,127,127,0.5)";
      if (isVertical) {
        circleEl = el("circle", {
          cx: baseX - 18, cy: pos, r: 3.4,
          fill: "none",
          stroke: circleStrokeColor,
          "stroke-width": circleStrokeWidth,
          style: "cursor: pointer;",
          "data-variant-id": v.id
        });
      } else {
        circleEl = el("circle", {
          cx: pos, cy: baseY - 18, r: 3.4,
          fill: "none",
          stroke: circleStrokeColor,
          "stroke-width": circleStrokeWidth,
          style: "cursor: pointer;",
          "data-variant-id": v.id
        });
      }
      circleEl.addEventListener("mouseenter", () => {
        state.hoveredVariantIndex = idx;
        renderHoverOnly();
      });
      circleEl.addEventListener("mouseleave", () => {
        state.hoveredVariantIndex = null;
        renderHoverOnly();
      });
      // Pointerdown handler to toggle insertion expansion
      if (isInsertion(v)) {
        circleEl.style.pointerEvents = "auto";
        circleEl.addEventListener("pointerdown", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (state.expandedInsertions.has(v.id)) {
            state.expandedInsertions.delete(v.id);
          } else {
            state.expandedInsertions.add(v.id);
          }
          renderAll();
        });
      }
      tracksSvg.appendChild(circleEl);
      
      // Store reference to circle element for hover updates
      if (!state.locusVariantElements.has(idx)) {
        state.locusVariantElements.set(idx, { lineEl: null, circleEl: null });
      }
      state.locusVariantElements.get(idx).circleEl = circleEl;
      
      // Draw expanded insertion sequence if expanded
      if (state.expandedInsertions.has(v.id) && isInsertion(v)) {
        // Use precomputed gap width if available (performance optimization)
        let gapSize;
        if (v.hasOwnProperty('insertionGapPx')) {
          gapSize = v.insertionGapPx;
        } else {
          // Fallback to computation for backward compatibility
          const maxInsertLen = getMaxInsertionLength(v);
          gapSize = maxInsertLen * 8;
        }
        
        // Draw inserted sequence (use longest alt allele)
        const longestAlt = v.altAlleles.reduce((a, b) => a.length > b.length ? a : b);
        const insertedSeq = longestAlt.substring(v.refAllele.length);
        const baseSize = gapSize / insertedSeq.length;
        
        const nucleotideColors = {
          'A': 'rgba(0, 200, 0, 0.8)',      // green
          'C': 'rgba(0, 0, 255, 0.8)',      // blue
          'G': 'rgba(255, 165, 0, 0.8)',    // orange
          'T': 'rgba(255, 0, 0, 0.8)'       // red
        };
        
        if (isVertical) {
          const gapStartY = pos;
          const gapEndY = gapStartY - gapSize; // going up (toward start)
          
          // Draw gap background
          tracksSvg.appendChild(el("rect", {
            x: baseX - 18,
            y: gapEndY,
            width: 36,
            height: gapSize,
            fill: "rgba(255,255,255,0.1)",
            stroke: "rgba(127,127,127,0.3)",
            "stroke-width": 1,
            "stroke-dasharray": "2,2"
          }));
          
          for (let i = 0; i < insertedSeq.length; i++) {
            const base = insertedSeq[i].toUpperCase();
            const baseY = gapStartY - (i + 1) * baseSize;
            const color = nucleotideColors[base] || 'rgba(127,127,127,0.8)';
            
            tracksSvg.appendChild(el("rect", {
              x: baseX - 16,
              y: baseY,
              width: 32,
              height: baseSize - 1,
              fill: color
            }));
            
            // Draw base letter if space allows
            if (baseSize >= 8) {
              const textEl = el("text", {
                x: baseX,
                y: baseY + baseSize / 2,
                class: "svg-small",
                "text-anchor": "middle",
                fill: "white",
                "font-weight": "bold",
                "dominant-baseline": "middle",
                transform: "rotate(-90 " + baseX + " " + (baseY + baseSize / 2) + ")"
              }, base);
              tracksSvg.appendChild(textEl);
            }
          }
        } else {
          const gapStartX = pos;
          const gapEndX = gapStartX + gapSize;
          
          // Draw gap background
          tracksSvg.appendChild(el("rect", {
            x: gapStartX,
            y: baseY - 18,
            width: gapSize,
            height: 36,
            fill: "rgba(255,255,255,0.1)",
            stroke: "rgba(127,127,127,0.3)",
            "stroke-width": 1,
            "stroke-dasharray": "2,2"
          }));
          
          for (let i = 0; i < insertedSeq.length; i++) {
            const base = insertedSeq[i].toUpperCase();
            const baseX = gapStartX + i * baseSize;
            const color = nucleotideColors[base] || 'rgba(127,127,127,0.8)';
            
            tracksSvg.appendChild(el("rect", {
              x: baseX,
              y: baseY - 16,
              width: baseSize - 1,
              height: 32,
              fill: color
            }));
            
            // Draw base letter if space allows
            if (baseSize >= 8) {
              tracksSvg.appendChild(el("text", {
                x: baseX + baseSize / 2,
                y: baseY,
                class: "svg-small",
                "text-anchor": "middle",
                fill: "white",
                "font-weight": "bold",
                "dominant-baseline": "middle"
              }, base));
            }
          }
        }
      }
    }

      // separator
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: rulerX + rulerW, x2: rulerX + rulerW, y1: 0, y2: H,
          stroke: "rgba(127,127,127,0.12)"
        }));
      } else {
        tracksSvg.appendChild(el("line", {
          x1: 0, x2: W, y1: rulerY + rulerH, y2: rulerY + rulerH,
          stroke: "rgba(127,127,127,0.12)"
        }));
      }
    }

    // --- Reference track
    if (!referenceLayout.track.collapsed) {
      let referenceX, referenceY, referenceW, referenceH;
      if (isVertical) {
        referenceX = referenceLayout.contentLeft + 8;
        referenceW = 24;
        referenceY = 16;
        referenceH = H - 32;
      } else {
        referenceY = referenceLayout.contentTop + 8;
        referenceH = 24;
        referenceX = 16;
        referenceW = W - 32;
      }

      // Helper function to get reference sequence for a region
      // Returns { sequence: array, startBp: number } where startBp is the genomic position of sequence[0]
      function getReferenceSequence(startBp, endBp) {
        // Use the real reference sequence from config if available
        if (referenceSequence && referenceSequence.length > 0) {
          // Calculate the offset into the sequence
          // The reference sequence starts at data_bounds.start (0-based)
          // UCSC returns sequence for [start, end), so sequence[i] corresponds to genomic position (dataStart + i)
          const dataStart = window.GENOMESHADER_CONFIG?.data_bounds?.start || 0;
          const viewStart = Math.floor(startBp);
          const viewEnd = Math.floor(endBp);
          
          // Calculate sequence indices (0-based relative to sequence start)
          // seqStart: index in sequence string for viewStart genomic position
          // seqEnd: index in sequence string for (viewEnd + 1) genomic position (exclusive end)
          const seqStart = Math.max(0, viewStart - dataStart);
          const seqEnd = Math.min(referenceSequence.length, viewEnd - dataStart + 1);
          
          // Only return sequence if we have valid indices within bounds
          if (seqStart >= 0 && seqEnd > seqStart && seqStart < referenceSequence.length) {
            const sequence = referenceSequence.slice(seqStart, seqEnd).split('');
            // The actual genomic start position of the returned sequence
            const actualStartBp = dataStart + seqStart;
            return { sequence: sequence, startBp: actualStartBp };
          }
        }
        // Fallback: return empty array if no sequence data
        return { sequence: [], startBp: startBp };
      }

      const span = state.endBp - state.startBp;
      const startBpInt = Math.floor(state.startBp);
      const endBpInt = Math.floor(state.endBp);
      const refSeqData = getReferenceSequence(startBpInt, endBpInt);
      const refSeq = refSeqData.sequence;
      const refSeqStartBp = refSeqData.startBp;

      const nucleotideColors = {
        'A': 'rgba(0, 200, 0, 0.8)',      // green
        'C': 'rgba(0, 0, 255, 0.8)',      // blue
        'G': 'rgba(255, 165, 0, 0.8)',    // orange
        'T': 'rgba(255, 0, 0, 0.8)'       // red
      };

      // Helper function to convert nucleotide color to RGBA array for WebGPU
      function nucleotideColorToRgba(base) {
        const rgbaStr = nucleotideColors[base] || 'rgba(127,127,127,0.8)';
        const match = rgbaStr.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
        if (match) {
          return [
            parseInt(match[1]) / 255,
            parseInt(match[2]) / 255,
            parseInt(match[3]) / 255,
            parseFloat(match[4])
          ];
        }
        return [0.5, 0.5, 0.5, 0.8]; // fallback
      }

      // Calculate base size based on zoom level
      const minBaseSize = 2; // Minimum size per base in pixels
      const baseSize = Math.max(minBaseSize, state.pxPerBp);

      // Only show individual bases if zoomed in enough (at least 2 actual pixels per base)
      const showIndividualBases = state.pxPerBp >= 2;

      // Performance limit: maximum number of bases to render
      const maxBasesToRender = 10000;

      if (showIndividualBases && refSeq.length > 0) {
        // Filter and prepare visible bases
        const visibleBases = [];
        for (let i = 0; i < refSeq.length; i++) {
          // Calculate the actual genomic position for this base
          // UCSC uses 0-based coordinates, but genomic positions are 1-based
          // refSeq[i] corresponds to genomic position refSeqStartBp + i + 1 (1-based)
          const bp = refSeqStartBp + i + 1;
          
          // Only render bases that are within the visible view
          if (bp < state.startBp || bp > state.endBp) continue;
          
          // Use genomePosCanonical to account for insertion gaps
          const pos = genomePosCanonical(bp);
          const nextBp = bp + 1;
          const nextPos = nextBp <= state.endBp ? genomePosCanonical(nextBp) : genomePosCanonical(state.endBp);
          const actualSize = Math.max(minBaseSize, Math.abs(nextPos - pos));
          
          // Skip bases that are too small to render
          if (actualSize < minBaseSize) continue;
          
          const base = refSeq[i].toUpperCase();
          visibleBases.push({
            bp: bp,
            base: base,
            pos: pos,
            nextPos: nextPos,
            actualSize: actualSize
          });
        }

        // Limit the number of bases to render
        const basesToRender = visibleBases.slice(0, maxBasesToRender);
        
        if (visibleBases.length > maxBasesToRender) {
          console.warn(`Too many bases (${visibleBases.length}), rendering only first ${maxBasesToRender}`);
        }

        // Use WebGPU if available, otherwise fall back to SVG
        if (webgpuSupported && instancedRenderer) {
          // Add rectangles to WebGPU renderer
          // Scale by devicePixelRatio since WebGPU canvas uses physical pixels
          const dpr = window.devicePixelRatio || 1;
          
          for (const b of basesToRender) {
            const pos = b.pos;
            const actualSize = b.actualSize;
            const base = b.base;
            const rgba = nucleotideColorToRgba(base);
            
            let x, y, w, h;
            if (isVertical) {
              x = referenceX;
              y = pos;
              w = referenceW;
              h = actualSize - 0.5;
            } else {
              x = pos;
              y = referenceY;
              w = actualSize - 0.5;
              h = referenceH;
            }
            
            // Scale coordinates by DPR to match physical pixel canvas
            instancedRenderer.addRect(x * dpr, y * dpr, w * dpr, h * dpr, rgba);
          }
          
          // Draw base letters using SVG (text rendering can stay SVG-based)
          // Use solid colors for text (more vibrant than the semi-transparent rect colors)
          const nucleotideTextColors = {
            'A': '#00a000',  // green
            'C': '#0000cc',  // blue
            'G': '#cc8400',  // orange
            'T': '#cc0000'   // red
          };
          const fragment = document.createDocumentFragment();
          for (const b of basesToRender) {
            if (b.actualSize >= 8) {
              const base = b.base;
              const pos = b.pos;
              const actualSize = b.actualSize;
              const textColor = nucleotideTextColors[base] || '#666';
              
              if (isVertical) {
                const textEl = el("text", {
                  x: referenceX + referenceW / 2,
                  y: pos + actualSize / 2,
                  "text-anchor": "middle",
                  "dominant-baseline": "middle",
                  style: `fill: ${textColor}; font-size: 10px; font-weight: bold;`,
                  transform: "rotate(-90 " + (referenceX + referenceW / 2) + " " + (pos + actualSize / 2) + ")"
                }, base);
                fragment.appendChild(textEl);
              } else {
                const textEl = el("text", {
                  x: pos + actualSize / 2,
                  y: referenceY + referenceH / 2,
                  "text-anchor": "middle",
                  "dominant-baseline": "middle",
                  style: `fill: ${textColor}; font-size: 10px; font-weight: bold;`
                }, base);
                fragment.appendChild(textEl);
              }
            }
          }
          tracksSvg.appendChild(fragment);
        } else {
          // Fallback to SVG rendering
          // Use solid colors for text (more vibrant than the semi-transparent rect colors)
          const svgTextColors = {
            'A': '#00a000',  // green
            'C': '#0000cc',  // blue
            'G': '#cc8400',  // orange
            'T': '#cc0000'   // red
          };
          const fragment = document.createDocumentFragment();
          
          for (const b of basesToRender) {
            const pos = b.pos;
            const actualSize = b.actualSize;
            const base = b.base;
            const rectColor = nucleotideColors[base] || 'rgba(127,127,127,0.8)';
            const textColor = svgTextColors[base] || '#666';
            
            if (isVertical) {
              fragment.appendChild(el("rect", {
                x: referenceX,
                y: pos,
                width: referenceW,
                height: actualSize - 0.5,
                fill: rectColor
              }));

              // Draw base letter if space allows
              if (actualSize >= 8) {
                const textEl = el("text", {
                  x: referenceX + referenceW / 2,
                  y: pos + actualSize / 2,
                  "text-anchor": "middle",
                  "dominant-baseline": "middle",
                  style: `fill: ${textColor}; font-size: 10px; font-weight: bold;`,
                  transform: "rotate(-90 " + (referenceX + referenceW / 2) + " " + (pos + actualSize / 2) + ")"
                }, base);
                fragment.appendChild(textEl);
              }
            } else {
              fragment.appendChild(el("rect", {
                x: pos,
                y: referenceY,
                width: actualSize - 0.5,
                height: referenceH,
                fill: rectColor
              }));

              // Draw base letter if space allows
              if (actualSize >= 8) {
                const textEl = el("text", {
                  x: pos + actualSize / 2,
                  y: referenceY + referenceH / 2,
                  "text-anchor": "middle",
                  "dominant-baseline": "middle",
                  style: `fill: ${textColor}; font-size: 10px; font-weight: bold;`
                }, base);
                fragment.appendChild(textEl);
              }
            }
          }
          
          // Append all elements at once (single DOM operation)
          tracksSvg.appendChild(fragment);
        }
      } else {
        // Zoomed out: show a continuous reference line with subtle pattern
        if (isVertical) {
          const topPad = 16, bottomPad = 16;
          const innerH = H - topPad - bottomPad;
          const totalGapPx = getTotalInsertionGapWidth();
          const totalGapBp = totalGapPx / state.pxPerBp;
          const effectiveSpan = span + totalGapBp;

          // Draw background
          tracksSvg.appendChild(el("rect", {
            x: referenceX,
            y: topPad,
            width: referenceW,
            height: innerH,
            fill: "rgba(127,127,127,0.08)",
            rx: 4
          }));

          // Draw a subtle pattern indicating reference sequence
          const patternHeight = 20;
          for (let y = topPad; y < topPad + innerH; y += patternHeight * 2) {
            tracksSvg.appendChild(el("rect", {
              x: referenceX,
              y: y,
              width: referenceW,
              height: Math.min(patternHeight, topPad + innerH - y),
              fill: "rgba(127,127,127,0.12)"
            }));
          }
        } else {
          const leftPad = 16, rightPad = 16;
          const innerW = W - leftPad - rightPad;
          const totalGapPx = getTotalInsertionGapWidth();
          const totalGapBp = totalGapPx / state.pxPerBp;
          const effectiveSpan = span + totalGapBp;

          // Draw background
          tracksSvg.appendChild(el("rect", {
            x: leftPad,
            y: referenceY,
            width: innerW,
            height: referenceH,
            fill: "rgba(127,127,127,0.08)",
            rx: 4
          }));

          // Draw a subtle pattern indicating reference sequence
          const patternWidth = 20;
          for (let x = leftPad; x < leftPad + innerW; x += patternWidth * 2) {
            tracksSvg.appendChild(el("rect", {
              x: x,
              y: referenceY,
              width: Math.min(patternWidth, leftPad + innerW - x),
              height: referenceH,
              fill: "rgba(127,127,127,0.12)"
            }));
          }
        }
      }

      // Separator
      if (isVertical) {
        tracksSvg.appendChild(el("line", {
          x1: referenceX + referenceW, x2: referenceX + referenceW, y1: 0, y2: H,
          stroke: "rgba(127,127,127,0.12)"
        }));
      } else {
        tracksSvg.appendChild(el("line", {
          x1: 0, x2: W, y1: referenceY - 4, y2: referenceY - 4,
          stroke: "rgba(127,127,127,0.12)"
        }));
      }
    }

    // Execute WebGPU render pass for tracks canvas (genes and repeats)
    const hasTracksInstances = instancedRenderer && 
        (instancedRenderer.rectInstances.length > 0 || 
         instancedRenderer.triangleInstances.length > 0 || 
         instancedRenderer.lineInstances.length > 0);
    if (webgpuSupported && instancedRenderer && hasTracksInstances) {
      try {
        // Update projection matrix for current canvas size
        const dpr = window.devicePixelRatio || 1;
        const width = tracksWebGPU.clientWidth * dpr;
        const height = tracksWebGPU.clientHeight * dpr;
        
        // Resize canvas if needed
        if (tracksWebGPU.width !== width || tracksWebGPU.height !== height) {
          tracksWebGPU.width = width;
          tracksWebGPU.height = height;
          webgpuCore.handleResize();
        }
        
        const encoder = webgpuCore.createCommandEncoder();
        const texture = webgpuCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear',
            storeOp: 'store',
          }],
        });
        
        instancedRenderer.render(encoder, renderPass);
        renderPass.end();
        webgpuCore.submit([encoder.finish()]);
      } catch (error) {
        console.error("Tracks WebGPU render error:", error);
        // Fallback: clear instances and continue with SVG only
        instancedRenderer.clear();
      }
    } else if (webgpuSupported && instancedRenderer) {
      // Clear WebGPU canvas if no instances to render
      try {
        const dpr = window.devicePixelRatio || 1;
        const width = tracksWebGPU.clientWidth * dpr;
        const height = tracksWebGPU.clientHeight * dpr;
        
        if (tracksWebGPU.width !== width || tracksWebGPU.height !== height) {
          tracksWebGPU.width = width;
          tracksWebGPU.height = height;
          webgpuCore.handleResize();
        }
        
        const encoder = webgpuCore.createCommandEncoder();
        const texture = webgpuCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear',
            storeOp: 'store',
          }],
        });
        renderPass.end();
        webgpuCore.submit([encoder.finish()]);
      } catch (error) {
        // Ignore errors when clearing
      }
    }
  }

  // -----------------------------
  // Canvas helpers
  // -----------------------------
  function resizeCanvasTo(el, canvas) {
    const dpr = window.devicePixelRatio || 1;
    const w = Math.floor(rectW(el) * dpr);
    const h = Math.floor(rectH(el) * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
    return dpr;
  }

  function visibleVariantWindow() {
    // Return all variants in the visible genomic range, not limited by state.K
    // state.K is just used for initial window sizing
    const visibleVariants = variants.filter(v => v.pos >= state.startBp && v.pos <= state.endBp);
    return visibleVariants;
  }

  function roundRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y,   x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x,   y+h, rr);
    ctx.arcTo(x,   y+h, x,   y,   rr);
    ctx.arcTo(x,   y,   x+w, y,   rr);
    ctx.closePath();
  }

  // -----------------------------
  // Sankey placeholder (Canvas2D)
  // -----------------------------
  function renderFlowCanvas() {
    const layout = getTrackLayout();
    const flowLayout = layout.find(l => l.track.id === "flow");
    if (!flowLayout || flowLayout.track.collapsed) {
      // Clear canvas if collapsed
      const ctx = flowCanvas.getContext("2d");
      ctx.clearRect(0, 0, flowCanvas.width, flowCanvas.height);
      // Clear WebGPU renderer instances
      if (flowInstancedRenderer) {
        flowInstancedRenderer.clear();
      }
      return;
    }

    const dpr = resizeCanvasTo(flow, flowCanvas);
    const ctx = flowCanvas.getContext("2d");
    
    // Clear and set up canvas
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,flowCanvas.width,flowCanvas.height);
    ctx.scale(dpr, dpr);
    
    // Clear WebGPU renderer instances
    if (flowInstancedRenderer) {
      flowInstancedRenderer.clear();
    }
    if (flowRibbonRenderer) {
      flowRibbonRenderer.clear();
    }

    const isVertical = isVerticalMode();
    const variantMode = getVariantLayoutMode();
    const junctionY = 40;
    const junctionX = 40;

    const W = flowWidthPx(), H = flowHeightPx();

    const colLines = cssVar("--grid");
    const colGrid  = cssVar("--grid2");
    const colText  = cssVar("--muted");
    const colBlue  = cssVar("--blue");
    const colGray  = "rgba(127,127,127,0.5)"; // Gray for non-hovered lines

    // drawRibbon: WebGPU Bezier ribbon renderer (replaces Canvas2D tessellation)
    // Note: srcInfo/dstInfo coordinates are in Canvas2D logical pixels (scaled by dpr)
    // WebGPU uses physical pixels, so we need to scale by devicePixelRatio
    const drawRibbon = (srcInfo, dstInfo, srcY0, srcY1, dstY0, dstY1, color) => {
      if (!srcInfo || !dstInfo) return;

      // Scale coordinates from logical pixels (Canvas2D) to physical pixels (WebGPU)
      const devicePixelRatio = window.devicePixelRatio || 1;

      // Clamp to node bounds so ribbons meet nodes flush
      const srcY0C = Math.max(srcInfo.top, Math.min(srcY0, srcInfo.bottom));
      const srcY1C = Math.max(srcInfo.top, Math.min(srcY1, srcInfo.bottom));
      const dstY0C = Math.max(dstInfo.top, Math.min(dstY0, dstInfo.bottom));
      const dstY1C = Math.max(dstInfo.top, Math.min(dstY1, dstInfo.bottom));

      // Ensure consistent top/bottom ordering (prevents "candy-wrapper twist")
      let sTop = Math.min(srcY0C, srcY1C);
      let sBot = Math.max(srcY0C, srcY1C);
      let dTop = Math.min(dstY0C, dstY1C);
      let dBot = Math.max(dstY0C, dstY1C);

      // Apply slight endpoint taper (classic alluvial aesthetic)
      // Shrink endpoints toward midpoint by ~6% for intentional joins
      const taperFrac = 0.06;
      const sMid = (sTop + sBot) / 2;
      const sHalfH = (sBot - sTop) / 2;
      sTop = sMid - sHalfH * (1 - taperFrac);
      sBot = sMid + sHalfH * (1 - taperFrac);
      
      const dMid = (dTop + dBot) / 2;
      const dHalfH = (dBot - dTop) / 2;
      dTop = dMid - dHalfH * (1 - taperFrac);
      dBot = dMid + dHalfH * (1 - taperFrac);

      const srcX = srcInfo.right;
      const dstX = dstInfo.left;
      const dx = dstX - srcX;
      if (!(dx > 1.0)) return;

      // Handle length: no fixed 10px minimum; clamp by dx to avoid loops when zoomed out
      const base = dx * 0.40;
      const handle = Math.max(1.0, Math.min(base, dx * 0.45));

      // Scale all coordinates to physical pixels for WebGPU
      const topP0 = [srcX * devicePixelRatio, sTop * devicePixelRatio];
      const topP3 = [dstX * devicePixelRatio, dTop * devicePixelRatio];
      const botP0 = [srcX * devicePixelRatio, sBot * devicePixelRatio];
      const botP3 = [dstX * devicePixelRatio, dBot * devicePixelRatio];

      // Horizontal tangents at endpoints (classic Sankey look)
      const topP1 = [(srcX + handle) * devicePixelRatio, sTop * devicePixelRatio];
      const topP2 = [(dstX - handle) * devicePixelRatio, dTop * devicePixelRatio];
      const botP1 = [(srcX + handle) * devicePixelRatio, sBot * devicePixelRatio];
      const botP2 = [(dstX - handle) * devicePixelRatio, dBot * devicePixelRatio];

      // Parse color string to RGBA floats (expects "rgba(r,g,b,a)" or similar)
      const m = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      let rgba = [0.47, 0.71, 1.0, 0.20];
      if (m) {
        rgba = [parseInt(m[1])/255, parseInt(m[2])/255, parseInt(m[3])/255, m[4] !== undefined ? parseFloat(m[4]) : 1.0];
      }

      if (webgpuSupported && flowRibbonRenderer) {
        flowRibbonRenderer.addRibbon(topP0, topP1, topP2, topP3, botP0, botP1, botP2, botP3, rgba);
        return;
      }

      // Fallback (optional): if you want, keep your old Canvas2D path here.
    };

    // drawRibbonVertical: WebGPU Bezier ribbon renderer for vertical mode
    // In vertical mode with inverted Y axis (bottom=start, top=end):
    // - Source (earlier variant) is at BOTTOM (higher Y)
    // - Destination (later variant) is at TOP (lower Y)
    // - Ribbons flow UPWARD from srcInfo.top to dstInfo.bottom
    const drawRibbonVertical = (srcInfo, dstInfo, srcX0, srcX1, dstX0, dstX1, color) => {
      if (!srcInfo || !dstInfo) return;

      // Scale coordinates from logical pixels (Canvas2D) to physical pixels (WebGPU)
      const devicePixelRatio = window.devicePixelRatio || 1;

      // Clamp to node bounds so ribbons meet nodes flush (using left/right for horizontal extent)
      const srcX0C = Math.max(srcInfo.left, Math.min(srcX0, srcInfo.right));
      const srcX1C = Math.max(srcInfo.left, Math.min(srcX1, srcInfo.right));
      const dstX0C = Math.max(dstInfo.left, Math.min(dstX0, dstInfo.right));
      const dstX1C = Math.max(dstInfo.left, Math.min(dstX1, dstInfo.right));

      // Ensure consistent left/right ordering (prevents "candy-wrapper twist")
      let sLeft = Math.min(srcX0C, srcX1C);
      let sRight = Math.max(srcX0C, srcX1C);
      let dLeft = Math.min(dstX0C, dstX1C);
      let dRight = Math.max(dstX0C, dstX1C);

      // Apply slight endpoint taper (classic alluvial aesthetic)
      // Shrink endpoints toward midpoint by ~6% for intentional joins
      const taperFrac = 0.06;
      const sMid = (sLeft + sRight) / 2;
      const sHalfW = (sRight - sLeft) / 2;
      sLeft = sMid - sHalfW * (1 - taperFrac);
      sRight = sMid + sHalfW * (1 - taperFrac);
      
      const dMid = (dLeft + dRight) / 2;
      const dHalfW = (dRight - dLeft) / 2;
      dLeft = dMid - dHalfW * (1 - taperFrac);
      dRight = dMid + dHalfW * (1 - taperFrac);

      // With inverted Y axis: source is at bottom (higher Y), dest is at top (lower Y)
      // Ribbons flow UPWARD: from srcInfo.top (top edge of source node) to dstInfo.bottom (bottom edge of dest node)
      const srcY = srcInfo.top;      // Top edge of source node (which is at bottom of screen)
      const dstY = dstInfo.bottom;   // Bottom edge of dest node (which is at top of screen)
      const dy = srcY - dstY;        // srcY > dstY, so this is positive
      if (!(dy > 1.0)) return;

      // Handle length: no fixed 10px minimum; clamp by dy to avoid loops when zoomed out
      const base = dy * 0.40;
      const handle = Math.max(1.0, Math.min(base, dy * 0.45));

      // Scale all coordinates to physical pixels for WebGPU
      // Ribbon flows from bottom (srcY, larger) to top (dstY, smaller)
      const leftP0 = [sLeft * devicePixelRatio, srcY * devicePixelRatio];
      const leftP3 = [dLeft * devicePixelRatio, dstY * devicePixelRatio];
      const rightP0 = [sRight * devicePixelRatio, srcY * devicePixelRatio];
      const rightP3 = [dRight * devicePixelRatio, dstY * devicePixelRatio];

      // Vertical tangents at endpoints (flowing upward: srcY decreases toward dstY)
      const leftP1 = [sLeft * devicePixelRatio, (srcY - handle) * devicePixelRatio];
      const leftP2 = [dLeft * devicePixelRatio, (dstY + handle) * devicePixelRatio];
      const rightP1 = [sRight * devicePixelRatio, (srcY - handle) * devicePixelRatio];
      const rightP2 = [dRight * devicePixelRatio, (dstY + handle) * devicePixelRatio];

      // Parse color string to RGBA floats (expects "rgba(r,g,b,a)" or similar)
      const m = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      let rgba = [0.47, 0.71, 1.0, 0.20];
      if (m) {
        rgba = [parseInt(m[1])/255, parseInt(m[2])/255, parseInt(m[3])/255, m[4] !== undefined ? parseFloat(m[4]) : 1.0];
      }

      if (webgpuSupported && flowRibbonRenderer) {
        // For vertical ribbons, we pass left/right edges as top/bottom edges to the renderer
        flowRibbonRenderer.addRibbon(leftP0, leftP1, leftP2, leftP3, rightP0, rightP1, rightP2, rightP3, rgba);
        return;
      }

      // Fallback (optional): if you want, keep your old Canvas2D path here.
    };

    // Helper function to parse rgba string and convert to hex for WebGPU
    function rgbaToHex(rgbaStr) {
      const match = rgbaStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
      if (match) {
        const r = parseInt(match[1]);
        const g = parseInt(match[2]);
        const b = parseInt(match[3]);
        return (r << 16) | (g << 8) | b;
      }
      // Fallback to blue if parsing fails
      return 0x78B4FF;
    }

    // background
    ctx.fillStyle = "rgba(127,127,127,0.035)";
    ctx.fillRect(0,0,W,H);

    // connectors (diagonal lines - make them meet the ruler variant position precisely)
    const win = visibleVariantWindow();
    
    // Use WebGPU for variant columns if available, otherwise fall back to Canvas 2D
    // Use flowWebGPU instead of tracksWebGPU for variant columns
    const useWebGPU = webgpuSupported && flowInstancedRenderer;
    const devicePixelRatio = window.devicePixelRatio || 1;
    const blueHex = rgbaToHex(colBlue);
    const grayHex = rgbaToHex(colGray);
    
    if (isVertical) {
      // In vertical mode, sort variants by position for consistent ordering
      const sortedWin = [...win].sort((a, b) => a.pos - b.pos);
      
      // columns (horizontal lines in vertical mode) - shortened to end near where allele nodes start
      // Calculate where allele nodes start (left + margin + horizontal offset)
      const left = 70;
      const marginPercent = 0.1;
      const minMargin = 10;
      const flowLayoutForStems = layout.find(l => l.track.id === "flow");
      const trackWidth = flowLayoutForStems ? flowLayoutForStems.contentWidth : 300;
      const margin = Math.max(minMargin, trackWidth * marginPercent);
      // Estimate where nodes start - use a reasonable default if we can't calculate exactly
      const nodeStartX = left + margin + 20; // Add some buffer for centering offset
      const stemEndXFull = Math.min(nodeStartX + 30, W - 18); // End stem 30px after nodes start, but don't go past right edge
      // Reduce stem length by half
      const stemEndX = junctionX + (stemEndXFull - junctionX) / 2;
      
      if (useWebGPU) {
        for (let i=0;i<sortedWin.length;i++) {
          const v = sortedWin[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          const color = isHovered ? blueHex : grayHex;
          const alpha = isHovered ? 0.7 : 0.5;
          // Position column based on mode
          const y = variantMode === "genomic" 
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          const yScaled = y * devicePixelRatio;
          flowInstancedRenderer.addLine(
            junctionX * devicePixelRatio, yScaled,
            stemEndX * devicePixelRatio, yScaled,
            color, alpha
          );
        }
      } else {
        for (let i=0;i<sortedWin.length;i++) {
          const v = sortedWin[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          ctx.strokeStyle = isHovered ? colBlue : colGray;
          ctx.globalAlpha = isHovered ? 0.7 : 0.5;
          ctx.lineWidth = isHovered ? 2.5 : 1;
          // Position column based on mode
          const y = variantMode === "genomic" 
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          ctx.beginPath();
          ctx.moveTo(junctionX, y);
          ctx.lineTo(stemEndX, y);
          ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
      }

      // Text labels (still use Canvas 2D for text)
      // Group variants by position to handle multiple variants at same position
      const variantsByPos = new Map();
      for (const v of sortedWin) {
        const pos = v.pos;
        if (!variantsByPos.has(pos)) {
          variantsByPos.set(pos, []);
        }
        variantsByPos.get(pos).push(v);
      }
      
      // Helper function to draw multi-line text (for variants at same position)
      const drawMultiLineText = (text, x, y, lineHeight = 12) => {
        const lines = text.split('\n');
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], x, y + i * lineHeight);
        }
      };
      
      // Calculate if we have enough space to show all labels
      // In vertical mode, labels are rotated 90 degrees, so text width becomes vertical height
      ctx.font = "12px ui-sans-serif, system-ui";
      const uniquePositions = Array.from(variantsByPos.keys()).sort((a, b) => a - b);
      const maxLabelWidth = Math.max(...uniquePositions.map(pos => {
        const idsAtPos = variantsByPos.get(pos).map(v => v.id).join('\n');
        return ctx.measureText(idsAtPos).width;
      }), 30);
      // When rotated, the label takes up maxLabelWidth pixels vertically
      // We need spacing between labels, so add some padding
      const minSpacing = maxLabelWidth + 10; // minimum pixels between label centers
      
      // Check spacing between consecutive variant positions
      // For genomic mode, check actual Y positions; for equidistant, use calculated spacing
      let hasEnoughSpace = uniquePositions.length === 0;
      if (uniquePositions.length > 0) {
        if (variantMode === "genomic") {
          // In genomic mode, check minimum spacing between actual positions
          const positions = uniquePositions.map(pos => yGenomeCanonical(pos, H)).sort((a, b) => a - b);
          let minActualSpacing = Infinity;
          for (let i = 1; i < positions.length; i++) {
            const spacing = positions[i] - positions[i - 1];
            if (spacing < minActualSpacing) {
              minActualSpacing = spacing;
            }
          }
          hasEnoughSpace = minActualSpacing >= minSpacing;
        } else {
          // In equidistant mode, calculate spacing
          const avgSpacing = H / uniquePositions.length;
          hasEnoughSpace = avgSpacing >= minSpacing;
        }
      }
      
      // Store variant label positions for hit testing
      const variantLabelPositions = [];
      
      ctx.fillStyle = colText;
      // Iterate over unique positions
      for (let posIdx = 0; posIdx < uniquePositions.length; posIdx++) {
        const pos = uniquePositions[posIdx];
        const variantsAtPos = variantsByPos.get(pos);
        const firstVariant = variantsAtPos[0];
        const variantIdx = variants.findIndex(v2 => v2.id === firstVariant.id);
        
        // Calculate Y position for this position
        // For equidistant mode, use the position index (not variant index) so variants at same position overlap
        let y;
        if (variantMode === "genomic") {
          y = yGenomeCanonical(pos, H);
        } else {
          // Use position index so all variants at same position get same Y coordinate
          y = yColumn(posIdx, uniquePositions.length);
        }
        
        // Determine if we should show this label
        const isHovered = variantsAtPos.some(v => state.hoveredVariantIndex === variants.findIndex(v2 => v2.id === v.id));
        const isPinned = variantsAtPos.some(v => state.pinnedVariantLabels.has(v.id));
        const shouldShow = isHovered || isPinned || hasEnoughSpace;
        
        if (shouldShow) {
          // Show first ID (or count if multiple)
          const displayText = variantsAtPos.length > 1 
            ? `${variantsAtPos[0].id} (+${variantsAtPos.length - 1})`
            : variantsAtPos[0].id;
          
          ctx.save();
          ctx.translate(14, y + 6);
          ctx.rotate(-Math.PI/2);
          ctx.fillText(displayText, 0, 0);
          ctx.restore();
        }
        
        // Store position for hit testing (for click-to-pin and tooltip) - one entry per position
        const firstVariantIdx = variants.findIndex(v2 => v2.id === firstVariant.id);
        const displayText = variantsAtPos.length > 1 
          ? `${variantsAtPos[0].id} (+${variantsAtPos.length - 1})`
          : variantsAtPos[0].id;
        const labelWidth = ctx.measureText(displayText).width;
        const labelIds = (firstVariant.displayIds && firstVariant.displayIds.length > 0)
          ? firstVariant.displayIds
          : [firstVariant.id];
        variantLabelPositions.push({
          variantId: firstVariant.id, // Use first variant ID for compatibility
          variantIdx: firstVariantIdx,
          x: 14,
          y: y,
          width: labelWidth, // When rotated, this is the vertical extent
          height: labelWidth, // Same as width when rotated
          allIds: labelIds, // Store all IDs for tooltip
          position: pos
        });
      }
      
      // Store positions globally for click detection
      window._variantLabelPositions = variantLabelPositions;

      // Connector lines from ruler to columns
      const x0 = 6;
      if (useWebGPU) {
        for (let i=0; i<sortedWin.length; i++) {
          const v = sortedWin[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          const color = isHovered ? blueHex : grayHex;
          const alpha = isHovered ? 0.7 : 0.5;
          const vy = yGenomeCanonical(v.pos, H); // always use genomic position for ruler connection
          const cy = variantMode === "genomic"
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          flowInstancedRenderer.addLine(
            x0 * devicePixelRatio, vy * devicePixelRatio,
            junctionX * devicePixelRatio, cy * devicePixelRatio,
            color, alpha
          );
        }
      } else {
        for (let i=0; i<sortedWin.length; i++) {
          const v = sortedWin[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          ctx.strokeStyle = isHovered ? colBlue : colGray;
          ctx.globalAlpha = isHovered ? 0.7 : 0.5;
          ctx.lineWidth = isHovered ? 2.5 : 1;
          const vy = yGenomeCanonical(v.pos, H);
          const cy = variantMode === "genomic"
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          ctx.beginPath();
          ctx.moveTo(x0, vy);
          ctx.lineTo(junctionX, cy);
          ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
      }
    } else {
      // columns (vertical lines) - shortened to end near where allele nodes start
      // Calculate where allele nodes start (top + margin + vertical offset)
      const top = 0;
      const marginPercent = 0.1;
      const minMargin = 10;
      const flowLayoutForStems = layout.find(l => l.track.id === "flow");
      const trackHeight = flowLayoutForStems ? flowLayoutForStems.contentHeight : 300;
      const margin = Math.max(minMargin, trackHeight * marginPercent);
      // Estimate where nodes start - use a reasonable default if we can't calculate exactly
      const nodeStartY = top + margin + 20; // Add some buffer for centering offset
      const stemEndYFull = Math.min(nodeStartY + 30, H - 18); // End stem 30px after nodes start, but don't go past bottom
      // Reduce stem length by half
      const stemEndY = junctionY + (stemEndYFull - junctionY) / 2;
      
      if (useWebGPU) {
        for (let i=0;i<win.length;i++) {
          const v = win[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          const color = isHovered ? blueHex : grayHex;
          const alpha = isHovered ? 0.7 : 0.5;
          // Position column based on mode
          const x = variantMode === "genomic"
            ? xGenomeCanonical(v.pos, W)
            : xColumn(i, win.length);
          const xScaled = x * devicePixelRatio;
          flowInstancedRenderer.addLine(
            xScaled, junctionY * devicePixelRatio,
            xScaled, stemEndY * devicePixelRatio,
            color, alpha
          );
        }
      } else {
        for (let i=0;i<win.length;i++) {
          const v = win[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          ctx.strokeStyle = isHovered ? colBlue : colGray;
          ctx.globalAlpha = isHovered ? 0.7 : 0.5;
          ctx.lineWidth = isHovered ? 2.5 : 1;
          // Position column based on mode
          const x = variantMode === "genomic"
            ? xGenomeCanonical(v.pos, W)
            : xColumn(i, win.length);
          ctx.beginPath();
          ctx.moveTo(x, junctionY);
          ctx.lineTo(x, stemEndY);
          ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
      }

      // Text labels (still use Canvas 2D for text)
      // Group variants by position to handle multiple variants at same position
      const variantsByPos = new Map();
      for (const v of win) {
        const pos = v.pos;
        if (!variantsByPos.has(pos)) {
          variantsByPos.set(pos, []);
        }
        variantsByPos.get(pos).push(v);
      }
      
      // Helper function to draw multi-line text (for variants at same position)
      const drawMultiLineText = (text, x, y, lineHeight = 12) => {
        const lines = text.split('\n');
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], x, y + i * lineHeight);
        }
      };
      
      // Calculate if we have enough space to show all labels
      // Estimate label width (measure text to be more accurate)
      ctx.font = "12px ui-sans-serif, system-ui";
      const uniquePositions = Array.from(variantsByPos.keys()).sort((a, b) => a - b);
      const maxLabelWidth = Math.max(...uniquePositions.map(pos => {
        const idsAtPos = variantsByPos.get(pos).map(v => v.id).join('\n');
        return ctx.measureText(idsAtPos).width;
      }), 50);
      const minSpacing = maxLabelWidth + 20; // minimum pixels between labels
      const hasEnoughSpace = uniquePositions.length === 0 || (W / uniquePositions.length) >= minSpacing;
      
      // Store variant label positions for hit testing
      const variantLabelPositions = [];
      
      ctx.fillStyle = colText;
      // Iterate over unique positions
      for (let posIdx = 0; posIdx < uniquePositions.length; posIdx++) {
        const pos = uniquePositions[posIdx];
        const variantsAtPos = variantsByPos.get(pos);
        const firstVariant = variantsAtPos[0];
        const variantIdx = variants.findIndex(v2 => v2.id === firstVariant.id);
        
        // Calculate X position for this position
        // For equidistant mode, use the position index (not variant index) so variants at same position overlap
        let x;
        if (variantMode === "genomic") {
          x = xGenomeCanonical(pos, W);
        } else {
          // Use position index so all variants at same position get same X coordinate
          x = xColumn(posIdx, uniquePositions.length);
        }
        
        // Determine if we should show this label
        const isHovered = variantsAtPos.some(v => state.hoveredVariantIndex === variants.findIndex(v2 => v2.id === v.id));
        const isPinned = variantsAtPos.some(v => state.pinnedVariantLabels.has(v.id));
        const shouldShow = isHovered || isPinned || hasEnoughSpace;
        
        if (shouldShow) {
          // Show first ID (or count if multiple)
          const displayText = variantsAtPos.length > 1 
            ? `${variantsAtPos[0].id} (+${variantsAtPos.length - 1})`
            : variantsAtPos[0].id;
          ctx.fillText(displayText, x - 10, 14);
        }
        
        // Store position for hit testing (for click-to-pin and tooltip) - one entry per position
        const firstVariantIdx = variants.findIndex(v2 => v2.id === firstVariant.id);
        const displayText = variantsAtPos.length > 1 
          ? `${variantsAtPos[0].id} (+${variantsAtPos.length - 1})`
          : variantsAtPos[0].id;
        const labelWidth = ctx.measureText(displayText).width;
        const labelIds = (firstVariant.displayIds && firstVariant.displayIds.length > 0)
          ? firstVariant.displayIds
          : [firstVariant.id];
        variantLabelPositions.push({
          variantId: firstVariant.id, // Use first variant ID for compatibility
          variantIdx: firstVariantIdx,
          x: x - 10,
          y: 2, // Text baseline is at y=14, but text extends upward, so hit box starts at y=2
          width: labelWidth,
          height: 14, // Single line height
          allIds: labelIds, // Store all IDs for tooltip
          position: pos
        });
      }
      
      // Store positions globally for click detection
      window._variantLabelPositions = variantLabelPositions;

      // Connector lines from ruler to columns
      const y0 = 6;
      if (useWebGPU) {
        for (let i=0; i<win.length; i++) {
          const v = win[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          const color = isHovered ? blueHex : grayHex;
          const alpha = isHovered ? 0.7 : 0.5;
          const vx = xGenomeCanonical(v.pos, W);
          const cx = variantMode === "genomic"
            ? xGenomeCanonical(v.pos, W)
            : xColumn(i, win.length);
          flowInstancedRenderer.addLine(
            vx * devicePixelRatio, y0 * devicePixelRatio,
            cx * devicePixelRatio, junctionY * devicePixelRatio,
            color, alpha
          );
        }
      } else {
        for (let i=0; i<win.length; i++) {
          const v = win[i];
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          const isHovered = state.hoveredVariantIndex === variantIdx;
          ctx.strokeStyle = isHovered ? colBlue : colGray;
          ctx.globalAlpha = isHovered ? 0.7 : 0.5;
          ctx.lineWidth = isHovered ? 2.5 : 1;
          const vx = xGenomeCanonical(v.pos, W);
          const cx = variantMode === "genomic"
            ? xGenomeCanonical(v.pos, W)
            : xColumn(i, win.length);
          ctx.beginPath();
          ctx.moveTo(vx, y0);
          ctx.lineTo(cx, junctionY);
          ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
      }
    }

    // Helper function to format allele with length suffix
    // Make it globally accessible for drag handlers
    // Uses precomputed formatted labels from backend if available for performance
    window.formatAlleleLabel = function formatAlleleLabel(allele, variant) {
      // If variant is provided and has precomputed formatted labels, use them
      if (variant) {
        // Check for no-call
        if (!allele || allele === ".") {
          return ". (no-call)";
        }
        // Check for reference allele
        if (variant.hasOwnProperty('formattedRefAllele') && variant.refAllele === allele) {
          return variant.formattedRefAllele;
        }
        // Check for alt alleles
        if (variant.hasOwnProperty('formattedAltAlleles') && variant.altAlleles) {
          const altIndex = variant.altAlleles.indexOf(allele);
          if (altIndex >= 0 && altIndex < variant.formattedAltAlleles.length) {
            return variant.formattedAltAlleles[altIndex];
          }
        }
      }
      // Fallback to computation for backward compatibility or when variant not provided
      if (!allele || allele === ".") {
        return ". (no-call)";
      }
      const length = allele.length;
      const lengthLabel = length === 1 ? "1 bp" : `${length} bp`;
      // Truncate to 50 bp and add "..." if longer
      const displayAllele = length > 50 ? allele.substring(0, 50) + "..." : allele;
      return `${displayAllele} (${lengthLabel})`;
    };
    
    // Helper function to get all formatted labels for a variant
    // Uses precomputed formatted labels from backend if available for performance
    function getFormattedLabelsForVariant(variant) {
      const labels = [];
      const labelToAllele = new Map();
      
      // Use precomputed formatted labels if available
      if (variant.hasOwnProperty('formattedRefAllele') && variant.hasOwnProperty('formattedAltAlleles')) {
        // Add no-call label
        const noCallLabel = ". (no-call)";
        labels.push(noCallLabel);
        labelToAllele.set(noCallLabel, ".");
        
        // Add reference allele label
        if (variant.formattedRefAllele) {
          labels.push(variant.formattedRefAllele);
          labelToAllele.set(variant.formattedRefAllele, variant.refAllele || ".");
        }
        
        // Add alt allele labels
        if (variant.formattedAltAlleles && variant.altAlleles) {
          for (let i = 0; i < variant.formattedAltAlleles.length && i < variant.altAlleles.length; i++) {
            const label = variant.formattedAltAlleles[i];
            const allele = variant.altAlleles[i];
            labels.push(label);
            labelToAllele.set(label, allele);
          }
        }
      } else {
        // Fallback to computation for backward compatibility
        const noCallLabel = formatAlleleLabel(".");
        labels.push(noCallLabel);
        labelToAllele.set(noCallLabel, ".");
        
        if (variant.refAllele) {
          const refLabel = formatAlleleLabel(variant.refAllele);
          labels.push(refLabel);
          labelToAllele.set(refLabel, variant.refAllele);
        }
        
        if (variant.altAlleles && Array.isArray(variant.altAlleles)) {
          for (let k = 0; k < variant.altAlleles.length; k++) {
            const altLabel = formatAlleleLabel(variant.altAlleles[k]);
            labels.push(altLabel);
            labelToAllele.set(altLabel, variant.altAlleles[k]);
          }
        }
      }
      
      return { labels, labelToAllele };
    }
    
    // Helper function to extract allele string from formatted label
    function extractAlleleFromLabel(label) {
      // Label format is "ALLELE (X bp)" or ". (no-call)"
      if (label.startsWith(". (no-call)")) return ".";
      const match = label.match(/^(.+?)\s*\([^)]+\)$/);
      return match ? match[1] : label;
    }
    
    // Helper function to get node colors based on allele type
    function getAlleleNodeColors(label, variant, actualAllele, isDragging) {
      const noCallLabel = formatAlleleLabel(".");
      const opacity = 0.65; // Light translucency
      const opacityDragging = 0.85; // Slightly more opaque when dragging
      const currentOpacity = isDragging ? opacityDragging : opacity;
      
      let fillColor, strokeColor;
      
      if (label === noCallLabel) {
        // No-call allele: gray with translucency
        fillColor = `rgba(200,200,200,${currentOpacity})`;
        strokeColor = `rgba(200,200,200,${currentOpacity})`;
      } else {
        // Determine allele type based on variant context and length
        // Use actualAllele if provided (to avoid truncation issues), otherwise extract from label
        const allele = actualAllele || extractAlleleFromLabel(label);
        const refLen = variant.refAllele ? variant.refAllele.length : 0;
        const alleleLen = allele.length;
        
        // 1 bp alleles are always SNVs (blue), regardless of reference length
        if (alleleLen === 1) {
          fillColor = `rgba(100,150,255,${currentOpacity})`;
          strokeColor = `rgba(100,150,255,${currentOpacity})`;
        } else {
          // Determine variant type by comparing ref to alts
          // Use precomputed variantType if available (performance optimization)
          let isDeletion = false;
          let isInsertion = false;
          
          if (variant.hasOwnProperty('variantType')) {
            // Use precomputed variant type
            const variantType = variant.variantType;
            isDeletion = variantType === 'deletion' || variantType === 'complex';
            isInsertion = variantType === 'insertion' || variantType === 'complex';
          } else {
            // Fallback to computation for backward compatibility
            if (variant.altAlleles && Array.isArray(variant.altAlleles) && variant.altAlleles.length > 0) {
              // Check if any alt is shorter than ref (deletion) or longer than ref (insertion)
              const hasShorterAlt = variant.altAlleles.some(alt => alt.length < refLen);
              const hasLongerAlt = variant.altAlleles.some(alt => alt.length > refLen);
              
              if (hasShorterAlt && !hasLongerAlt) {
                isDeletion = true;
              } else if (hasLongerAlt && !hasShorterAlt) {
                isInsertion = true;
              }
            }
          }
          
          // Color based on variant type and allele length
          if (isDeletion) {
            // In deletion variants, longer alleles are deletions (yellow)
            // Shorter alleles (if > 1 bp) would also be deletions, but 1 bp is already handled above
            const maxDiff = 100;
            const normalizedDiff = Math.min((alleleLen - 1) / maxDiff, 1.0); // Compare to 1 bp minimum
            const lightness = 70 - (normalizedDiff * 40); // 70% to 30%
            fillColor = `hsla(60, 80%, ${lightness}%, ${currentOpacity})`;
            strokeColor = `hsla(60, 80%, ${lightness}%, ${currentOpacity})`;
          } else if (isInsertion) {
            // In insertion variants, longer alleles are insertions (purple)
            const lengthDiff = alleleLen - refLen;
            const maxDiff = 100;
            const normalizedDiff = Math.min(lengthDiff / maxDiff, 1.0);
            const lightness = 70 - (normalizedDiff * 40); // 70% to 30%
            fillColor = `hsla(280, 70%, ${lightness}%, ${currentOpacity})`;
            strokeColor = `hsla(280, 70%, ${lightness}%, ${currentOpacity})`;
          } else {
            // SNV or substitution (same length): blue
            fillColor = `rgba(100,150,255,${currentOpacity})`;
            strokeColor = `rgba(100,150,255,${currentOpacity})`;
          }
        }
      }
      
      return { fillColor, strokeColor };
    }
    
    // Helper function to calculate allele node sizes based on frequencies
    // Make it globally accessible for drag handlers
    window.calculateAlleleSizes = function calculateAlleleSizes(variant, totalSpace, minSize, gap, numAlleles) {
      const alleleFrequencies = variant.alleleFrequencies || {};
      
      // Add margins to make the display more comfortable
      // Use 10% margin on each side (20% total), with a minimum of 20 pixels total
      const marginPercent = 0.1;
      const minMargin = 10;
      const margin = Math.max(minMargin, totalSpace * marginPercent);
      const availableSpace = totalSpace - (2 * margin);
      
      // If no frequencies available, return equal sizes
      if (!alleleFrequencies || Object.keys(alleleFrequencies).length === 0) {
        const equalSize = Math.max(minSize, (availableSpace - (numAlleles - 1) * gap) / numAlleles);
        const sizes = {};
        
        // Use helper function to get formatted labels (uses precomputed values if available)
        const { labels, labelToAllele } = getFormattedLabelsForVariant(variant);
        
        // Get precomputed labels for key mapping
        const noCallLabel = ". (no-call)";
        const refLabel = variant.hasOwnProperty('formattedRefAllele') && variant.formattedRefAllele
          ? variant.formattedRefAllele
          : (variant.refAllele ? formatAlleleLabel(variant.refAllele) : null);
        
        for (const label of labels) {
          // Map label to allele key
          let key = ".";
          if (label === noCallLabel) {
            key = ".";
          } else if (label === refLabel) {
            key = "ref";
          } else {
            // Find which alt allele this is using labelToAllele map or fallback
            const actualAllele = labelToAllele.get(label);
            if (actualAllele && variant.altAlleles && Array.isArray(variant.altAlleles)) {
              const altIndex = variant.altAlleles.indexOf(actualAllele);
              if (altIndex >= 0) {
                key = `a${altIndex + 1}`;
              }
            } else if (variant.altAlleles && Array.isArray(variant.altAlleles)) {
              // Fallback: find by comparing formatted labels
              const altIndex = variant.altAlleles.findIndex(alt => formatAlleleLabel(alt) === label);
              if (altIndex >= 0) {
                key = `a${altIndex + 1}`;
              }
            }
          }
          sizes[key] = equalSize;
        }
        return sizes;
      }
      
      // Calculate total minimum size needed
      const totalMinSize = numAlleles * minSize;
      const totalGapSize = (numAlleles - 1) * gap;
      const remainingSpace = availableSpace - totalMinSize - totalGapSize;
      
      if (remainingSpace < 0) {
        // Edge case: minimum sizes exceed available space
        // Just use minimum sizes
        const sizes = {};
        for (const key of Object.keys(alleleFrequencies)) {
          sizes[key] = minSize;
        }
        return sizes;
      }
      
      // Redistribute remaining space proportionally
      const finalSizes = {};
      for (const [allele, freq] of Object.entries(alleleFrequencies)) {
        const proportional = freq * remainingSpace;
        finalSizes[allele] = minSize + proportional;
      }
      
      return finalSizes;
    }
    
    // Get track dimensions for sizing (reuse flowLayout from earlier in function)
    const flowLayoutForSizing = layout.find(l => l.track.id === "flow");
    const trackDimension = isVertical 
      ? (flowLayoutForSizing ? flowLayoutForSizing.contentWidth : 300)
      : (flowLayoutForSizing ? flowLayoutForSizing.contentHeight : 300);
    
    // Allele nodes with drag-and-drop support
    // Define constants at function scope so they're accessible in nested functions
    const baseNodeW = 4, baseNodeH = 14, gap = 8;
    const MIN_NODE_SIZE = 4;
    
    // Make constants available globally for drag handlers
    window._alleleNodeConstants = { baseNodeW, baseNodeH, gap, MIN_NODE_SIZE };
    const nodePositions = []; // Store positions for hit testing: [{ variantId, alleleIndex, x, y, w, h }]
    
    // Store node info for ribbon drawing: Map<variantIndex, Map<alleleLabel, {x, y, w, h, top, bottom, left, right}>>
    const nodeInfoByVariant = new Map();
    
    // Collect all labels to draw at the very end (after all nodes and indicators)
    const allLabelsToDraw = [];
    
    if (isVertical) {
      const sortedWin = [...win].sort((a, b) => a.pos - b.pos);
      const left = 70;
      
      // Calculate margin for allele nodes (same as in calculateAlleleSizes)
      const marginPercent = 0.1;
      const minMargin = 10;
      const margin = Math.max(minMargin, trackDimension * marginPercent);
      
      for (let i=0;i<sortedWin.length;i++){
        const v = sortedWin[i];
        const variantIdx = variants.findIndex(v2 => v2.id === v.id);
        
        // Get allele labels with actual alleles: ['.', refAllele, altAllele1, altAllele2, ...]
        // Use helper function to get formatted labels (uses precomputed values if available)
        const { labels, labelToAllele } = getFormattedLabelsForVariant(v);
        
        // Get order from state, or use default
        let order = state.variantAlleleOrder.get(v.id);
        if (!order || order.length !== labels.length) {
          order = [...labels];
          state.variantAlleleOrder.set(v.id, order);
        }
        
        // Calculate allele sizes based on frequencies
        const alleleSizes = calculateAlleleSizes(v, trackDimension, MIN_NODE_SIZE, gap, order.length);
        
        // Map labels to allele keys for size lookup
        // Use precomputed labels if available
        const noCallLabel = ". (no-call)";
        const refLabel = v.hasOwnProperty('formattedRefAllele') && v.formattedRefAllele
          ? v.formattedRefAllele
          : (v.refAllele ? formatAlleleLabel(v.refAllele) : null);
        function getAlleleKey(label) {
          if (label === noCallLabel) return ".";
          if (label === refLabel) return "ref";
          // Use labelToAllele map for efficient lookup
          const actualAllele = labelToAllele.get(label);
          if (actualAllele && v.altAlleles && Array.isArray(v.altAlleles)) {
            const altIndex = v.altAlleles.indexOf(actualAllele);
            if (altIndex >= 0) return `a${altIndex + 1}`;
          }
          // Fallback: find by comparing formatted labels
          if (v.altAlleles && Array.isArray(v.altAlleles)) {
            const altIndex = v.altAlleles.findIndex(alt => formatAlleleLabel(alt) === label);
            if (altIndex >= 0) return `a${altIndex + 1}`;
          }
          return "."; // fallback
        }
        
        // Position based on variant layout mode
        const cy = variantMode === "genomic"
          ? yGenomeCanonical(v.pos, H)
          : yColumn(i, sortedWin.length);
        
        // Calculate total width of all nodes plus gaps
        let totalNodesWidth = 0;
        for (let j = 0; j < order.length; j++) {
          const label = order[j];
          const alleleKey = getAlleleKey(label);
          const nodeW = alleleSizes[alleleKey] || baseNodeW;
          totalNodesWidth += nodeW;
          if (j < order.length - 1) {
            totalNodesWidth += gap;
          }
        }
        
        // Center the nodes horizontally within the actual available space
        // Account for left offset and right margin to ensure nodes don't extend beyond track boundaries
        const availableWidth = W - left - margin;
        const horizontalOffset = Math.max(0, (availableWidth - totalNodesWidth) / 2);
        
        // Calculate cumulative positions for variable-width nodes, starting with left + horizontal offset
        let currentX = left + horizontalOffset;
        
        // Check if this variant column is hovered
        const isVariantHovered = state.hoveredVariantIndex === variantIdx;
        
        // Draw nodes in current order
        for (let j=0;j<order.length;j++){
          const label = order[j];
          const alleleKey = getAlleleKey(label);
          let nodeW = alleleSizes[alleleKey] || baseNodeW;
          let nodeH = baseNodeW;
          
          // Increase width when variant is hovered (vertical mode = horizontal nodes)
          if (isVariantHovered) {
            nodeH += 2;
          }
          
          const x = currentX;
          
          // Check if this node is being dragged
          const isDragging = state.alleleDragState && 
            state.alleleDragState.variantId === v.id && 
            state.alleleDragState.alleleIndex === order.indexOf(label);
          const dragOffsetX = isDragging ? state.alleleDragState.offsetX : 0;
          const dragOffsetY = isDragging ? state.alleleDragState.offsetY : 0;
          
          const nodeX = x + dragOffsetX;
          const nodeY = cy - nodeH/2 + dragOffsetY;

          // Get colors based on allele type (use actual allele from map, not extracted from label)
          const actualAllele = labelToAllele.get(label) || extractAlleleFromLabel(label);
          const colors = getAlleleNodeColors(label, v, actualAllele, isDragging);
          
          // Use WebGPU for fill if available, otherwise fall back to Canvas2D
          const devicePixelRatio = window.devicePixelRatio || 1;
          const useWebGPU = webgpuSupported && flowInstancedRenderer;
          
          if (useWebGPU) {
            // Parse rgba color string to array for WebGPU
            const fillMatch = colors.fillColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (fillMatch) {
              const r = parseInt(fillMatch[1]) / 255;
              const g = parseInt(fillMatch[2]) / 255;
              const b = parseInt(fillMatch[3]) / 255;
              const a = fillMatch[4] !== undefined ? parseFloat(fillMatch[4]) : 1.0;
              // Scale coordinates to physical pixels for WebGPU
              flowInstancedRenderer.addRect(
                nodeX * devicePixelRatio,
                nodeY * devicePixelRatio,
                nodeW * devicePixelRatio,
                nodeH * devicePixelRatio,
                [r, g, b, a]
              );
            }
          } else {
            // Fallback to Canvas2D
            ctx.fillStyle = colors.fillColor;
            ctx.beginPath();
            roundRect(ctx, nodeX, nodeY, nodeW, nodeH, 5);
            ctx.fill();
          }
          
          // Check if this allele is selected
          const selectionKey = `${v.id}:${order.indexOf(label)}`;
          const isSelected = state.selectedAlleles.has(selectionKey);
          
          // Stroke always uses Canvas2D (minimal overhead for borders)
          // Use highlight color and thicker stroke for selected alleles
          if (isSelected) {
            ctx.strokeStyle = "rgba(255, 215, 0, 1)"; // Gold highlight for selected
            ctx.lineWidth = 3;
          } else {
            ctx.strokeStyle = colors.strokeColor;
            ctx.lineWidth = isDragging ? 2 : 1;
          }
          ctx.beginPath();
          roundRect(ctx, nodeX, nodeY, nodeW, nodeH, 5);
          ctx.stroke();

          // Store label info for drawing after all nodes
          const labelKey = `${v.id}:${order.indexOf(label)}`;
          const isHovered = state.hoveredAlleleNode && 
            state.hoveredAlleleNode.variantId === v.id && 
            state.hoveredAlleleNode.alleleIndex === order.indexOf(label);
          const isPinned = state.pinnedAlleleLabels.has(labelKey);
          
          if (isHovered || isPinned || isSelected) {
            allLabelsToDraw.push({
              label: label,
              nodeX: nodeX,
              nodeY: nodeY,
              nodeW: nodeW,
              nodeH: nodeH,
              isVertical: true
            });
          }
          
          // Store position for hit testing
          nodePositions.push({
            variantId: v.id,
            alleleIndex: order.indexOf(label),
            label: label,
            x: nodeX,
            y: nodeY,
            w: nodeW,
            h: nodeH,
            isSelected: isSelected
          });
          
          // Store node info for ribbon drawing
          if (!nodeInfoByVariant.has(i)) {
            nodeInfoByVariant.set(i, new Map());
          }
          nodeInfoByVariant.get(i).set(label, {
            x: nodeX,
            y: nodeY,
            w: nodeW,
            isSelected: isSelected,
            h: nodeH,
            top: nodeY,
            bottom: nodeY + nodeH,
            left: nodeX,
            right: nodeX + nodeW
          });
          
          // Update position for next node
          currentX += nodeW + gap;
        }
        
        // Draw drop indicator if dragging this variant
        if (state.alleleDragState && state.alleleDragState.variantId === v.id && 
            state.alleleDragState.dropIndex !== null && state.alleleDragState.dropIndex !== undefined) {
          const dropIdx = state.alleleDragState.dropIndex;
          const currentIdx = order.indexOf(state.alleleDragState.label);
          
          // Only show indicator if dropping at a different position
          if (dropIdx !== currentIdx) {
            // Calculate drop position accounting for variable node widths, margin, and centering
            // Recalculate total width and horizontal offset (same as above)
            let totalNodesWidth = 0;
            for (let k = 0; k < order.length; k++) {
              const label = order[k];
              const alleleKey = getAlleleKey(label);
              const nodeW = alleleSizes[alleleKey] || baseNodeW;
              totalNodesWidth += nodeW;
              if (k < order.length - 1) {
                totalNodesWidth += gap;
              }
            }
            const availableWidth = W - left - margin;
            const horizontalOffset = Math.max(0, (availableWidth - totalNodesWidth) / 2);
            
            let indicatorX = left + horizontalOffset;
            for (let k = 0; k < dropIdx; k++) {
              const label = order[k];
              const alleleKey = getAlleleKey(label);
              const nodeW = alleleSizes[alleleKey] || baseNodeW;
              indicatorX += nodeW + gap;
            }
            // For the last position, draw after the last node
            if (dropIdx === order.length - 1) {
              const label = order[dropIdx];
              const alleleKey = getAlleleKey(label);
              const nodeW = alleleSizes[alleleKey] || baseNodeW;
              indicatorX += nodeW;
            }
            ctx.strokeStyle = "rgba(120, 180, 255, 0.8)"; // Use accent blue color
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(indicatorX, cy - baseNodeH/2 - 4);
            ctx.lineTo(indicatorX, cy + baseNodeH/2 + 4);
            ctx.stroke();
          }
        }
      }
    } else {
      for (let i=0;i<win.length;i++){
        const v = win[i];
        const variantIdx = variants.findIndex(v2 => v2.id === v.id);
        
        // Get allele labels with actual alleles: ['.', refAllele, altAllele1, altAllele2, ...]
        // Use helper function to get formatted labels (uses precomputed values if available)
        const { labels, labelToAllele } = getFormattedLabelsForVariant(v);
        
        // Get order from state, or use default
        let order = state.variantAlleleOrder.get(v.id);
        if (!order || order.length !== labels.length) {
          order = [...labels];
          state.variantAlleleOrder.set(v.id, order);
        }
        
        // Calculate allele sizes based on frequencies
        const alleleSizes = calculateAlleleSizes(v, trackDimension, MIN_NODE_SIZE, gap, order.length);
        
        // Map labels to allele keys for size lookup
        // Use precomputed labels if available
        const noCallLabel = ". (no-call)";
        const refLabel = v.hasOwnProperty('formattedRefAllele') && v.formattedRefAllele
          ? v.formattedRefAllele
          : (v.refAllele ? formatAlleleLabel(v.refAllele) : null);
        function getAlleleKey(label) {
          if (label === noCallLabel) return ".";
          if (label === refLabel) return "ref";
          // Use labelToAllele map for efficient lookup
          const actualAllele = labelToAllele.get(label);
          if (actualAllele && v.altAlleles && Array.isArray(v.altAlleles)) {
            const altIndex = v.altAlleles.indexOf(actualAllele);
            if (altIndex >= 0) return `a${altIndex + 1}`;
          }
          // Fallback: find by comparing formatted labels
          if (v.altAlleles && Array.isArray(v.altAlleles)) {
            const altIndex = v.altAlleles.findIndex(alt => formatAlleleLabel(alt) === label);
            if (altIndex >= 0) return `a${altIndex + 1}`;
          }
          return "."; // fallback
        }
        
        // Position based on variant layout mode
        const cx = variantMode === "genomic"
          ? xGenomeCanonical(win[i].pos, W)
          : xColumn(i, win.length);
        const top = 20;

        // Calculate margin for allele nodes (same as in calculateAlleleSizes)
        const marginPercent = 0.1;
        const minMargin = 10;
        const margin = Math.max(minMargin, trackDimension * marginPercent);
        
        // Calculate total height of all nodes plus gaps
        let totalNodesHeight = 0;
        for (let j = 0; j < order.length; j++) {
          const label = order[j];
          const alleleKey = getAlleleKey(label);
          const nodeH = alleleSizes[alleleKey] || baseNodeH;
          totalNodesHeight += nodeH;
          if (j < order.length - 1) {
            totalNodesHeight += gap;
          }
        }
        
        // Center the nodes vertically within the actual available space
        // Account for top offset and bottom margin to ensure nodes don't extend beyond track boundaries
        const availableHeight = H - top - margin;
        const verticalOffset = Math.max(0, (availableHeight - totalNodesHeight) / 2);

        // Calculate cumulative positions for variable-height nodes, starting with top + vertical offset
        let currentY = top + verticalOffset;

        // Check if this variant column is hovered
        const isVariantHovered = state.hoveredVariantIndex === variantIdx;
        
        // Draw nodes in current order
        for (let j=0;j<order.length;j++){
          const label = order[j];
          const alleleKey = getAlleleKey(label);
          let nodeW = baseNodeW;
          let nodeH = alleleSizes[alleleKey] || baseNodeH;
          
          // Increase height when variant is hovered (horizontal mode = vertical nodes)
          if (isVariantHovered) {
            nodeW += 2;
          }
          
          const y = currentY;
          
          // Check if this node is being dragged
          const isDragging = state.alleleDragState && 
            state.alleleDragState.variantId === v.id && 
            state.alleleDragState.alleleIndex === order.indexOf(label);
          const dragOffsetX = isDragging ? state.alleleDragState.offsetX : 0;
          const dragOffsetY = isDragging ? state.alleleDragState.offsetY : 0;
          
          const nodeX = cx - nodeW/2 + dragOffsetX;
          const nodeY = y + dragOffsetY;

          // Get colors based on allele type (use actual allele from map, not extracted from label)
          const actualAllele = labelToAllele.get(label) || extractAlleleFromLabel(label);
          const colors = getAlleleNodeColors(label, v, actualAllele, isDragging);
          
          // Use WebGPU for fill if available, otherwise fall back to Canvas2D
          const devicePixelRatio = window.devicePixelRatio || 1;
          const useWebGPU = webgpuSupported && flowInstancedRenderer;
          
          if (useWebGPU) {
            // Parse rgba color string to array for WebGPU
            const fillMatch = colors.fillColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
            if (fillMatch) {
              const r = parseInt(fillMatch[1]) / 255;
              const g = parseInt(fillMatch[2]) / 255;
              const b = parseInt(fillMatch[3]) / 255;
              const a = fillMatch[4] !== undefined ? parseFloat(fillMatch[4]) : 1.0;
              // Scale coordinates to physical pixels for WebGPU
              flowInstancedRenderer.addRect(
                nodeX * devicePixelRatio,
                nodeY * devicePixelRatio,
                nodeW * devicePixelRatio,
                nodeH * devicePixelRatio,
                [r, g, b, a]
              );
            }
          } else {
            // Fallback to Canvas2D
            ctx.fillStyle = colors.fillColor;
            ctx.beginPath();
            roundRect(ctx, nodeX, nodeY, nodeW, nodeH, 5);
            ctx.fill();
          }
          
          // Check if this allele is selected
          const selectionKey = `${v.id}:${order.indexOf(label)}`;
          const isSelected = state.selectedAlleles.has(selectionKey);
          
          // Stroke always uses Canvas2D (minimal overhead for borders)
          // Use highlight color and thicker stroke for selected alleles
          if (isSelected) {
            ctx.strokeStyle = "rgba(255, 215, 0, 1)"; // Gold highlight for selected
            ctx.lineWidth = 3;
          } else {
            ctx.strokeStyle = colors.strokeColor;
            ctx.lineWidth = isDragging ? 2 : 1;
          }
          ctx.beginPath();
          roundRect(ctx, nodeX, nodeY, nodeW, nodeH, 5);
          ctx.stroke();

          // Store label info for drawing after all nodes
          const labelKey = `${v.id}:${order.indexOf(label)}`;
          const isHovered = state.hoveredAlleleNode && 
            state.hoveredAlleleNode.variantId === v.id && 
            state.hoveredAlleleNode.alleleIndex === order.indexOf(label);
          const isPinned = state.pinnedAlleleLabels.has(labelKey);
          
          if (isHovered || isPinned || isSelected) {
            allLabelsToDraw.push({
              label: label,
              nodeX: nodeX,
              nodeY: nodeY,
              nodeW: nodeW,
              nodeH: nodeH,
              isVertical: false
            });
          }
          
          // Store position for hit testing
          nodePositions.push({
            variantId: v.id,
            alleleIndex: order.indexOf(label),
            label: label,
            x: nodeX,
            y: nodeY,
            w: nodeW,
            h: nodeH,
            isSelected: isSelected
          });
          
          // Store node info for ribbon drawing
          if (!nodeInfoByVariant.has(i)) {
            nodeInfoByVariant.set(i, new Map());
          }
          nodeInfoByVariant.get(i).set(label, {
            x: nodeX,
            y: nodeY,
            w: nodeW,
            h: nodeH,
            top: nodeY,
            bottom: nodeY + nodeH,
            left: nodeX,
            right: nodeX + nodeW,
            isSelected: isSelected
          });
          
          // Update position for next node
          currentY += nodeH + gap;
        }
        
        // Draw drop indicator if dragging this variant
        if (state.alleleDragState && state.alleleDragState.variantId === v.id && 
            state.alleleDragState.dropIndex !== null && state.alleleDragState.dropIndex !== undefined) {
          const dropIdx = state.alleleDragState.dropIndex;
          const currentIdx = order.indexOf(state.alleleDragState.label);
          
          // Only show indicator if dropping at a different position
          if (dropIdx !== currentIdx) {
            // Calculate drop position accounting for variable node heights, margin, and centering
            // Recalculate total height and vertical offset (same as above)
            let totalNodesHeight = 0;
            for (let k = 0; k < order.length; k++) {
              const label = order[k];
              const alleleKey = getAlleleKey(label);
              const nodeH = alleleSizes[alleleKey] || baseNodeH;
              totalNodesHeight += nodeH;
              if (k < order.length - 1) {
                totalNodesHeight += gap;
              }
            }
            const availableHeight = H - top - margin;
            const verticalOffset = Math.max(0, (availableHeight - totalNodesHeight) / 2);
            
            let indicatorY = top + verticalOffset;
            for (let k = 0; k < dropIdx; k++) {
              const label = order[k];
              const alleleKey = getAlleleKey(label);
              const nodeH = alleleSizes[alleleKey] || baseNodeH;
              indicatorY += nodeH + gap;
            }
            // For the last position, draw after the last node
            if (dropIdx === order.length - 1) {
              const label = order[dropIdx];
              const alleleKey = getAlleleKey(label);
              const nodeH = alleleSizes[alleleKey] || baseNodeH;
              indicatorY += nodeH;
            }
            ctx.strokeStyle = "rgba(120, 180, 255, 0.8)"; // Use accent blue color
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx - baseNodeW/2 - 4, indicatorY);
            ctx.lineTo(cx + baseNodeW/2 + 4, indicatorY);
            ctx.stroke();
          }
        }
      }
    }
    
    // Draw ribbons between alleles based on haplotype transitions (not matching labels)
    // For each pair of adjacent variants, we compute which alleles each sample has at both variants
    // and draw ribbons proportional to the number of haplotypes making each transition
    if (nodeInfoByVariant.size > 1) {
      const sortedVariantIdxs = Array.from(nodeInfoByVariant.keys()).sort((a, b) => a - b);
      
      // Get the actual variant list (sorted for vertical mode, original order for horizontal)
      const variantList = isVertical ? [...win].sort((a, b) => a.pos - b.pos) : win;
      
      // Use expanded variant window for caching (includes padding to reduce cache invalidation)
      // This way, small pan movements don't invalidate the cache
      const expandedWin = expandedVariantWindow(0.3); // 30% padding on each side
      const expandedVariantList = isVertical ? [...expandedWin].sort((a, b) => a.pos - b.pos) : expandedWin;
      
      // Check if viewport has moved beyond cached range (cache invalidation)
      // Only invalidate if viewport has moved significantly (beyond padding zone)
      const currentViewportRange = { start: state.startBp, end: state.endBp };
      const span = currentViewportRange.end - currentViewportRange.start;
      const padding = span * 0.3; // Same as expandedVariantWindow padding
      
      const viewportMovedBeyondCache = cachedViewportRange && (
        currentViewportRange.start < cachedViewportRange.start - padding ||
        currentViewportRange.end > cachedViewportRange.end + padding
      );
      
      if (viewportMovedBeyondCache || cachedVisibleVariantIds === null) {
        // Clear cache when viewport moves significantly beyond cached range
        // This happens less frequently now because we cache an expanded set
        ribbonTransitionCache.clear();
        cachedVisibleVariantIds = expandedVariantList.map(v => v.id).join(',');
        cachedViewportRange = { 
          start: currentViewportRange.start - padding, 
          end: currentViewportRange.end + padding 
        };
      }
      
      // Helper to get allele label from genotype index for a variant
      function getAlleleLabelForIndex(variant, alleleIdx) {
        if (alleleIdx === null || alleleIdx === undefined || alleleIdx === "." || isNaN(alleleIdx)) {
          return formatAlleleLabel(".");
        }
        if (alleleIdx === 0) {
          // Reference allele
          return variant.refAllele ? formatAlleleLabel(variant.refAllele) : formatAlleleLabel(".");
        }
        // Alt allele (1-indexed in genotype, but 0-indexed in altAlleles array)
        if (variant.altAlleles && variant.altAlleles[alleleIdx - 1]) {
          return formatAlleleLabel(variant.altAlleles[alleleIdx - 1]);
        }
        return formatAlleleLabel(".");
      }
      
      // Helper to get actual allele string from label for a variant
      function getActualAlleleFromLabel(variant, label) {
        const noCallLabel = formatAlleleLabel(".");
        if (label === noCallLabel) return ".";
        if (variant.refAllele && label === formatAlleleLabel(variant.refAllele)) {
          return variant.refAllele;
        }
        if (variant.altAlleles && Array.isArray(variant.altAlleles)) {
          for (const alt of variant.altAlleles) {
            if (label === formatAlleleLabel(alt)) {
              return alt;
            }
          }
        }
        return ".";
      }
      
      // Helper function to compute transitions for a variant pair
      function computeTransitions(srcVariant, dstVariant) {
        const transitions = new Map();
        const srcGenotypes = srcVariant.sampleGenotypes || {};
        const dstGenotypes = dstVariant.sampleGenotypes || {};
        
        // Get all samples that have genotype data at both variants
        const allSamples = new Set([...Object.keys(srcGenotypes), ...Object.keys(dstGenotypes)]);
        
        for (const sample of allSamples) {
          const srcGt = srcGenotypes[sample] || "./.";
          const dstGt = dstGenotypes[sample] || "./.";
          
          // Parse genotypes to get allele indices
          const srcAlleles = srcGt.replace("|", "/").split("/").map(a => {
            const trimmed = a.trim();
            return trimmed === "." || trimmed === "" ? null : parseInt(trimmed, 10);
          });
          const dstAlleles = dstGt.replace("|", "/").split("/").map(a => {
            const trimmed = a.trim();
            return trimmed === "." || trimmed === "" ? null : parseInt(trimmed, 10);
          });
          
          // For each haplotype (assuming diploid = 2 haplotypes per sample)
          const numHaplotypes = Math.min(srcAlleles.length, dstAlleles.length);
          for (let h = 0; h < numHaplotypes; h++) {
            const srcAlleleIdx = srcAlleles[h];
            const dstAlleleIdx = dstAlleles[h];
            
            const srcLabel = getAlleleLabelForIndex(srcVariant, srcAlleleIdx);
            const dstLabel = getAlleleLabelForIndex(dstVariant, dstAlleleIdx);
            
            if (!transitions.has(srcLabel)) {
              transitions.set(srcLabel, new Map());
            }
            const srcTransitions = transitions.get(srcLabel);
            srcTransitions.set(dstLabel, (srcTransitions.get(dstLabel) || 0) + 1);
          }
        }
        
        return transitions;
      }
      
      for (let i = 0; i < sortedVariantIdxs.length - 1; i++) {
        const srcIdx = sortedVariantIdxs[i];
        const dstIdx = sortedVariantIdxs[i + 1];
        const srcNodes = nodeInfoByVariant.get(srcIdx);
        const dstNodes = nodeInfoByVariant.get(dstIdx);
        
        if (!srcNodes || !dstNodes) continue;
        
        // Get the variant objects from visible list (nodes only exist for visible variants)
        const srcVariant = variantList[srcIdx];
        const dstVariant = variantList[dstIdx];
        if (!srcVariant || !dstVariant) continue;
        
        // Cache key: variant pair IDs (variant objects are the same regardless of which list they come from)
        const cacheKey = `${srcVariant.id}-${dstVariant.id}`;
        
        // Get or compute transitions (cached to avoid recalculating on every pan/zoom)
        // The cache includes transitions for variants in the expanded window, so when variants
        // move slightly off-screen and back, we don't need to recalculate
        let transitions = ribbonTransitionCache.get(cacheKey);
        if (!transitions) {
          transitions = computeTransitions(srcVariant, dstVariant);
          // Store as serializable Map structure (convert nested Maps to objects for storage)
          const serialized = Array.from(transitions.entries()).map(([srcLabel, dstMap]) => [
            srcLabel,
            Array.from(dstMap.entries())
          ]);
          
          // Limit cache size: remove oldest entries if cache is too large
          if (ribbonTransitionCache.size >= MAX_CACHE_SIZE) {
            // Remove first (oldest) entry
            const firstKey = ribbonTransitionCache.keys().next().value;
            ribbonTransitionCache.delete(firstKey);
          }
          
          ribbonTransitionCache.set(cacheKey, serialized);
        } else {
          // Deserialize cached transitions back to Map structure
          transitions = new Map(transitions.map(([srcLabel, dstEntries]) => [
            srcLabel,
            new Map(dstEntries)
          ]));
        }
        
        // If no transition data (no samples), fall back to connecting all src nodes to all dst nodes
        if (transitions.size === 0) {
          for (const [srcLabel, srcNode] of srcNodes) {
            for (const [dstLabel, dstNode] of dstNodes) {
              const actualAllele = getActualAlleleFromLabel(srcVariant, srcLabel);
              const colors = getAlleleNodeColors(srcLabel, srcVariant, actualAllele, false);
              const colorMatch = colors.fillColor.match(/rgba?\([^)]+,\s*([\d.]+)\)/);
              const alpha = colorMatch ? parseFloat(colorMatch[1]) : 0.65;
              const ribbonColor = colors.fillColor.replace(/[\d.]+\)$/, `${alpha * 0.3})`);
              
              if (isVertical) {
                // Draw thin connecting ribbon (vertical flow)
                const srcW = srcNode.right - srcNode.left;
                const dstW = dstNode.right - dstNode.left;
                const midSrc = srcNode.left + srcW / 2;
                const midDst = dstNode.left + dstW / 2;
                const thinW = Math.min(2, srcW * 0.1, dstW * 0.1);
                
                drawRibbonVertical(
                  srcNode, dstNode,
                  midSrc - thinW/2, midSrc + thinW/2,
                  midDst - thinW/2, midDst + thinW/2,
                  ribbonColor
                );
              } else {
                // Draw thin connecting ribbon (horizontal flow)
                const srcH = srcNode.bottom - srcNode.top;
                const dstH = dstNode.bottom - dstNode.top;
                const midSrc = srcNode.top + srcH / 2;
                const midDst = dstNode.top + dstH / 2;
                const thinH = Math.min(2, srcH * 0.1, dstH * 0.1);
                
                drawRibbon(
                  srcNode, dstNode,
                  midSrc - thinH/2, midSrc + thinH/2,
                  midDst - thinH/2, midDst + thinH/2,
                  ribbonColor
                );
              }
            }
          }
          continue;
        }
        
        // Calculate total outgoing count per source label and total incoming per dest label
        const srcTotals = new Map(); // srcLabel -> total outgoing haplotypes
        const dstTotals = new Map(); // dstLabel -> total incoming haplotypes
        let totalHaplotypes = 0; // Total haplotypes across all transitions
        
        for (const [srcLabel, dstMap] of transitions) {
          let total = 0;
          for (const [dstLabel, count] of dstMap) {
            total += count;
            totalHaplotypes += count;
            dstTotals.set(dstLabel, (dstTotals.get(dstLabel) || 0) + count);
          }
          srcTotals.set(srcLabel, total);
        }
        
        // Track current offset within each node for stacking ribbons
        // In horizontal mode: Y offset from top; in vertical mode: X offset from left
        const srcOffsets = new Map();
        const dstOffsets = new Map();
        
        // Get reference allele labels to identify background persistence flows
        const srcRefLabel = srcVariant.refAllele ? formatAlleleLabel(srcVariant.refAllele) : null;
        const dstRefLabel = dstVariant.refAllele ? formatAlleleLabel(dstVariant.refAllele) : null;
        
        // Collect all ribbon data first, then sort so reference flows draw first (background)
        const ribbonData = [];
        
        for (const [srcLabel, dstMap] of transitions) {
          const srcNode = srcNodes.get(srcLabel);
          if (!srcNode) continue;
          
          const srcTotal = srcTotals.get(srcLabel) || 1;
          
          for (const [dstLabel, count] of dstMap) {
            const dstNode = dstNodes.get(dstLabel);
            if (!dstNode) continue;
            
            const dstTotal = dstTotals.get(dstLabel) || 1;
            
            // Get current offsets (for stacking)
            const srcOffset = srcOffsets.get(srcLabel) || 0;
            const dstOffset = dstOffsets.get(dstLabel) || 0;
            
            let src0, src1, dst0, dst1;
            
            if (isVertical) {
              // Vertical mode: ribbons flow downward, width is along X axis
              const srcNodeW = srcNode.right - srcNode.left;
              const dstNodeW = dstNode.right - dstNode.left;
              
              // Calculate ribbon slice widths proportional to transition count
              const srcSliceW = (count / srcTotal) * srcNodeW;
              const dstSliceW = (count / dstTotal) * dstNodeW;
              
              // Calculate X positions
              src0 = srcNode.left + srcOffset;
              src1 = src0 + srcSliceW;
              dst0 = dstNode.left + dstOffset;
              dst1 = dst0 + dstSliceW;
              
              // Update offsets for next ribbon
              srcOffsets.set(srcLabel, srcOffset + srcSliceW);
              dstOffsets.set(dstLabel, dstOffset + dstSliceW);
            } else {
              // Horizontal mode: ribbons flow rightward, height is along Y axis
              const srcNodeH = srcNode.bottom - srcNode.top;
              const dstNodeH = dstNode.bottom - dstNode.top;
              
              // Calculate ribbon slice heights proportional to transition count
              const srcSliceH = (count / srcTotal) * srcNodeH;
              const dstSliceH = (count / dstTotal) * dstNodeH;
              
              // Calculate Y positions
              src0 = srcNode.top + srcOffset;
              src1 = src0 + srcSliceH;
              dst0 = dstNode.top + dstOffset;
              dst1 = dst0 + dstSliceH;
              
              // Update offsets for next ribbon
              srcOffsets.set(srcLabel, srcOffset + srcSliceH);
              dstOffsets.set(dstLabel, dstOffset + dstSliceH);
            }
            
            // Check if this is a reference-to-reference flow (background persistence)
            const isRefFlow = srcLabel === srcRefLabel && dstLabel === dstRefLabel;
            
            ribbonData.push({
              srcNode, dstNode, src0, src1, dst0, dst1,
              srcLabel, count, isRefFlow
            });
          }
        }
        
        // Sort ribbons: reference flows first (drawn in background), then colored flows on top
        ribbonData.sort((a, b) => (b.isRefFlow ? 1 : 0) - (a.isRefFlow ? 1 : 0));
        
        // Draw all ribbons with sqrt-scaled opacity
        // Add viewport clipping: skip ribbons where both nodes are completely off-screen
        const viewportLeft = 0;
        const viewportRight = W;
        const viewportTop = 0;
        const viewportBottom = H;
        
        for (const ribbon of ribbonData) {
          const { srcNode, dstNode, src0, src1, dst0, dst1, srcLabel, count, isRefFlow } = ribbon;
          
          // Viewport clipping: skip if both nodes are completely off-screen
          // This avoids rendering ribbons that are outside the visible area
          if (isVertical) {
            // Vertical mode: check X coordinates (horizontal position)
            const srcRight = Math.max(srcNode.left, srcNode.right);
            const srcLeft = Math.min(srcNode.left, srcNode.right);
            const dstRight = Math.max(dstNode.left, dstNode.right);
            const dstLeft = Math.min(dstNode.left, dstNode.right);
            
            // Skip if both nodes are completely outside viewport
            if ((srcRight < viewportLeft && dstRight < viewportLeft) ||
                (srcLeft > viewportRight && dstLeft > viewportRight)) {
              continue;
            }
          } else {
            // Horizontal mode: check Y coordinates (vertical position)
            const srcBottom = Math.max(srcNode.top, srcNode.bottom);
            const srcTop = Math.min(srcNode.top, srcNode.bottom);
            const dstBottom = Math.max(dstNode.top, dstNode.bottom);
            const dstTop = Math.min(dstNode.top, dstNode.bottom);
            
            // Skip if both nodes are completely outside viewport
            if ((srcBottom < viewportTop && dstBottom < viewportTop) ||
                (srcTop > viewportBottom && dstTop > viewportBottom)) {
              continue;
            }
          }
          
          // Get color from source allele
          const actualAllele = getActualAlleleFromLabel(srcVariant, srcLabel);
          const colors = getAlleleNodeColors(srcLabel, srcVariant, actualAllele, false);
          
          // Check if source or destination node is selected
          const isEdgeSelected = srcNode.isSelected || dstNode.isSelected;
          
          // Sqrt-scaled opacity: prevents dominant flows from drowning minor ones
          const frac = count / Math.max(1, totalHaplotypes);
          let alpha = 0.05 + 0.25 * Math.sqrt(frac);
          
          // De-emphasize reference flows further (lower saturation via reduced alpha)
          if (isRefFlow) {
            alpha *= 0.6; // 40% reduction for background persistence flows
          }
          
          // Boost opacity for edges connected to selected alleles
          if (isEdgeSelected) {
            alpha = Math.min(1.0, alpha * 3.0); // Triple the opacity for selected edges
          }
          
          let ribbonColor;
          if (isEdgeSelected) {
            // Use gold highlight color for selected edges
            ribbonColor = `rgba(255, 215, 0, ${alpha.toFixed(3)})`;
          } else {
            ribbonColor = colors.fillColor.replace(/[\d.]+\)$/, `${alpha.toFixed(3)})`);
          }
          
          if (isVertical) {
            // Vertical mode: src0/src1/dst0/dst1 are X positions
            drawRibbonVertical(srcNode, dstNode, src0, src1, dst0, dst1, ribbonColor);
          } else {
            // Horizontal mode: src0/src1/dst0/dst1 are Y positions
            drawRibbon(srcNode, dstNode, src0, src1, dst0, dst1, ribbonColor);
          }
        }
      }
    }
    
    // Store node positions globally for hit testing
    window._alleleNodePositions = nodePositions;
    
    // Draw all labels at the very end with tooltip-style rounded rectangles (to bring them to foreground)
    ctx.font = "11px ui-monospace, 'SF Mono', Monaco, 'Consolas', 'Courier New', monospace";
    const labelPadding = 6;
    const labelBorderRadius = 4;
    const labelBgColor = "rgba(0, 0, 0, 0.85)";
    const labelBorderColor = "rgba(255, 255, 255, 0.2)";
    const labelTextColor = "rgba(255, 255, 255, 0.95)";
    
    for (const labelInfo of allLabelsToDraw) {
      const text = labelInfo.label;
      const textMetrics = ctx.measureText(text);
      const textWidth = textMetrics.width;
      const textHeight = 11; // font size
      
      if (labelInfo.isVertical) {
        // Vertical mode: rotated text
        const labelX = labelInfo.nodeX + labelInfo.nodeW/2 - gap - 5 + 12;
        const labelY = labelInfo.nodeY - 12;
        
        // Calculate dimensions for rotated tooltip
        const tooltipW = textHeight + labelPadding * 2;
        const tooltipH = textWidth + labelPadding * 2;
        const tooltipX = labelX - tooltipH / 2;
        const tooltipY = labelY - tooltipW / 2;
        
        ctx.save();
        ctx.translate(labelX, labelY);
        ctx.rotate(-Math.PI/2);
        
        // Draw tooltip background
        ctx.fillStyle = labelBgColor;
        ctx.strokeStyle = labelBorderColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        roundRect(ctx, -tooltipH/2, -tooltipW/2, tooltipH, tooltipW, labelBorderRadius);
        ctx.fill();
        ctx.stroke();
        
        // Draw text
        ctx.fillStyle = labelTextColor;
        ctx.fillText(text, -textWidth/2, textHeight/2 + 2);
        
        ctx.restore();
      } else {
        // Horizontal mode: normal text
        const labelX = labelInfo.nodeX + 12;
        const labelY = labelInfo.nodeY + 13;
        
        // Calculate dimensions for tooltip
        const tooltipW = textWidth + labelPadding * 2;
        const tooltipH = textHeight + labelPadding * 2;
        const tooltipX = labelX - labelPadding;
        const tooltipY = labelY - textHeight - labelPadding;
        
        // Draw tooltip background
        ctx.fillStyle = labelBgColor;
        ctx.strokeStyle = labelBorderColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        roundRect(ctx, tooltipX, tooltipY, tooltipW, tooltipH, labelBorderRadius);
        ctx.fill();
        ctx.stroke();
        
        // Draw text
        ctx.fillStyle = labelTextColor;
        ctx.fillText(text, labelX, labelY);
      }
    }

    // Execute WebGPU render pass after variant columns are added
    // Render to flowWebGPU canvas (separate from tracksWebGPU)
    const hasFlowInstances = flowInstancedRenderer && 
        (flowInstancedRenderer.rectInstances.length > 0 || flowInstancedRenderer.lineInstances.length > 0);
    const hasRibbonInstances = flowRibbonRenderer && flowRibbonRenderer.instances.length > 0;
    if (webgpuSupported && flowInstancedRenderer && (hasFlowInstances || hasRibbonInstances)) {
      try {
        // Update projection matrix for current canvas size
        const devicePixelRatio = window.devicePixelRatio || 1;
        const width = flowWebGPU.clientWidth * devicePixelRatio;
        const height = flowWebGPU.clientHeight * devicePixelRatio;
        
        if (flowWebGPU.width !== width || flowWebGPU.height !== height) {
          flowWebGPU.width = width;
          flowWebGPU.height = height;
          flowWebGPUCore.handleResize();
        }
        
        const encoder = flowWebGPUCore.createCommandEncoder();
        const texture = flowWebGPUCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear', // Clear canvas on each render
            storeOp: 'store',
          }],
        });
        
        if (flowRibbonRenderer) flowRibbonRenderer.render(encoder, renderPass);
        flowInstancedRenderer.render(encoder, renderPass);
        renderPass.end();
        flowWebGPUCore.submit([encoder.finish()]);
      } catch (error) {
        console.error("Flow WebGPU render error:", error);
        // Fallback: clear instances and continue with Canvas 2D only
        flowInstancedRenderer.clear();
      }
    } else if (webgpuSupported && flowInstancedRenderer) {
      // Clear WebGPU canvas if no instances to render
      try {
        const encoder = flowWebGPUCore.createCommandEncoder();
        const texture = flowWebGPUCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear',
            storeOp: 'store',
          }],
        });
        renderPass.end();
        flowWebGPUCore.submit([encoder.finish()]);
      } catch (error) {
        // Ignore errors when clearing
      }
    }
  }

  // -----------------------------
  // Reads placeholder (IGV-style area)
  // -----------------------------
  function renderReadsCanvas() {
    const layout = getTrackLayout();
    const readsLayout = layout.find(l => l.track.id === "reads");
    if (!readsLayout || readsLayout.track.collapsed) {
      // Clear WebGPU renderer instances if collapsed
      if (readsInstancedRenderer) {
        readsInstancedRenderer.clear();
      }
      return; // Don't render if collapsed
    }

    // Ensure readsCanvas exists
    if (!readsCanvas || !reads) {
      return;
    }

    // Get device pixel ratio first (before any other operations)
    const dpr = window.devicePixelRatio || 1;
    
    const isVertical = isVerticalMode();
    const W = readsWidthPx();
    let H = readsHeightPx(); // Visible height
    
    // Calculate total content height if reads are loaded
    let totalContentHeight = H;
    if (!isVertical && loadedReadsLayout && loadedReadsLayout.reads && loadedReadsLayout.reads.length > 0) {
      // Only set up scrolling canvas in inline (horizontal) mode
      const top = 8;
      const rowH = 18;
      const totalRows = loadedReadsLayout.rowCount || Math.max(...loadedReadsLayout.reads.map(r => r.row)) + 1;
      totalContentHeight = top + totalRows * rowH + 12;
      
      // Use CSS grid on the container to stack canvases while keeping them in document flow
      // This allows overflow scrolling to work (absolutely positioned elements don't contribute to scroll overflow)
      reads.style.display = 'grid';
      reads.style.gridTemplateRows = '1fr';
      reads.style.gridTemplateColumns = '1fr';
      reads.style.height = readsLayout.track.collapsed ? "0px" : `${readsLayout.contentHeight}px`;
      reads.style.overflowY = 'auto';
      reads.style.overflowX = 'hidden';
      
      // Set canvas to fill grid cell and use explicit height for scrolling
      readsCanvas.height = totalContentHeight * dpr;
      readsCanvas.style.height = totalContentHeight + 'px';
      readsCanvas.style.width = W + 'px';
      readsCanvas.style.gridRow = '1';
      readsCanvas.style.gridColumn = '1';
      readsCanvas.style.position = 'static';
      readsCanvas.style.inset = 'auto';
      readsCanvas.width = W * dpr;
      
      // Also update WebGPU canvas to use grid stacking
      if (readsWebGPU) {
        readsWebGPU.style.height = totalContentHeight + 'px';
        readsWebGPU.style.width = W + 'px';
        readsWebGPU.style.gridRow = '1';
        readsWebGPU.style.gridColumn = '1';
        readsWebGPU.style.position = 'static';
        readsWebGPU.style.inset = 'auto';
      }
    } else {
      // For vertical mode or when no reads are loaded, use resizeCanvasTo
      // Reset grid styles if they were set
      reads.style.display = '';
      reads.style.gridTemplateRows = '';
      reads.style.gridTemplateColumns = '';
      readsCanvas.style.gridRow = '';
      readsCanvas.style.gridColumn = '';
      readsCanvas.style.position = '';
      readsCanvas.style.inset = '';
      if (readsWebGPU) {
        readsWebGPU.style.gridRow = '';
        readsWebGPU.style.gridColumn = '';
        readsWebGPU.style.position = '';
        readsWebGPU.style.inset = '';
      }
      resizeCanvasTo(reads, readsCanvas);
    }

    const ctx = readsCanvas.getContext("2d");
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,readsCanvas.width,readsCanvas.height);
    ctx.scale(dpr, dpr);
    
    // Clear WebGPU renderer instances
    if (readsInstancedRenderer) {
      readsInstancedRenderer.clear();
    }
    const colText = cssVar("--muted");
    const grid = cssVar("--grid2");

    // soft background - use totalContentHeight for inline mode when reads are loaded
    const bgHeight = (!isVertical && loadedReadsLayout && loadedReadsLayout.reads && loadedReadsLayout.reads.length > 0) ? totalContentHeight : H;
    ctx.fillStyle = "rgba(127,127,127,0.02)";
    ctx.fillRect(0,0,W,bgHeight);

    if (isVertical) {
      // In vertical mode, the genomic axis runs vertically
      // Use the reads container height (H) for coordinate mapping to match the canvas we're drawing in
      // Both tracks and reads containers now have the same height (mainHeight) and start at top: 0
      const coordHeight = H;
      
      // a few columns to suggest lanes (vertical mode)
      ctx.strokeStyle = grid;
      ctx.lineWidth = 1;
      const left = 8;
      const colW = 18;
      const cols = Math.floor((W - left - 12) / colW);
      for (let i=0; i<cols; i++) {
        const x = left + i*colW + colW/2;
        ctx.beginPath();
        ctx.moveTo(x, 16);
        ctx.lineTo(x, H-16);
        ctx.stroke();
      }

      // placeholder "reads" as rounded rects aligned in genome space
      function drawRead(bpStart, bpEnd, col, alpha=0.20) {
        const y1 = yGenomeCanonical(bpStart, coordHeight);
        const y2 = yGenomeCanonical(bpEnd, coordHeight);
        const x = left + col*colW + 2;
        const w = colW - 6;
        const y = Math.min(y1, y2);
        const h = Math.max(6, Math.abs(y2-y1));

        // Use WebGPU for fill if available, otherwise fall back to Canvas2D
        const devicePixelRatio = window.devicePixelRatio || 1;
        const useWebGPU = webgpuSupported && readsInstancedRenderer;
        
        if (useWebGPU) {
          // Add rectangle to WebGPU renderer
          readsInstancedRenderer.addRect(
            x * devicePixelRatio,
            y * devicePixelRatio,
            w * devicePixelRatio,
            h * devicePixelRatio,
            [120/255, 180/255, 255/255, alpha]
          );
        } else {
          // Fallback to Canvas2D
          ctx.fillStyle = `rgba(120,180,255,${alpha})`;
          ctx.beginPath();
          roundRect(ctx, x, y, w, h, 6);
          ctx.fill();
        }
        
        // Stroke always uses Canvas2D (minimal overhead for borders)
        ctx.strokeStyle = `rgba(120,180,255,${alpha + 0.15})`;
        ctx.beginPath();
        roundRect(ctx, x, y, w, h, 6);
        ctx.stroke();
      }

      // Draw actual reads if available (vertical mode)
      if (loadedReadsLayout && loadedReadsLayout.reads && loadedReadsLayout.reads.length > 0) {
        const maxCols = Math.floor((W - left - 12) / colW);
        let renderedCount = 0;
        let filteredByRow = 0;
        let filteredByViewport = 0;
        for (const read of loadedReadsLayout.reads) {
          if (read.row >= maxCols) {
            filteredByRow++;
            continue;
          }
          if (read.end < state.startBp || read.start > state.endBp) {
            filteredByViewport++;
            continue;
          }
          renderedCount++;
          
          // Color based on haplotype
          let color, alpha;
          if (read.haplotype === 1) {
            color = [255, 100, 100];
            alpha = 0.5;
          } else if (read.haplotype === 2) {
            color = [100, 100, 255];
            alpha = 0.5;
          } else {
            color = [150, 150, 150];
            alpha = 0.35;
          }
          if (!read.isForward) alpha *= 0.7;
          
          // Use reads container height for coordinate mapping
          const y1 = yGenomeCanonical(read.start, coordHeight);
          const y2 = yGenomeCanonical(read.end, coordHeight);
          const x = left + read.row * colW + 2;
          const w = colW - 4;
          const y = Math.min(y1, y2);
          const h = Math.max(4, Math.abs(y2 - y1));
          
          const devicePixelRatio = window.devicePixelRatio || 1;
          const useWebGPU = webgpuSupported && readsInstancedRenderer;
          
          if (useWebGPU) {
            readsInstancedRenderer.addRect(
              x * devicePixelRatio, y * devicePixelRatio,
              w * devicePixelRatio, h * devicePixelRatio,
              [color[0]/255, color[1]/255, color[2]/255, alpha]
            );
          } else {
            ctx.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${alpha})`;
            ctx.beginPath();
            roundRect(ctx, x, y, w, h, 3);
            ctx.fill();
          }
          
          // Draw insertion/deletion/diff markers (vertical mode)
          if (read.elements && read.elements.length > 0) {
            for (const elem of read.elements) {
              if (elem.start < state.startBp || elem.start > state.endBp) continue;
              const ey = yGenomeCanonical(elem.start, coordHeight);
              const ex = x;
              const ew = w;
              
              if (elem.type === 2) { // Insertion - purple tick
                ctx.fillStyle = 'rgba(200,100,255,0.9)';
                ctx.fillRect(ex, ey - 1, ew, 2);
              } else if (elem.type === 3) { // Deletion - black gap
                const ey2 = yGenomeCanonical(elem.end, coordHeight);
                const delY = Math.min(ey, ey2);
                const delH = Math.max(2, Math.abs(ey2 - ey));
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.fillRect(ex + ew/4, delY, ew/2, delH);
              } else if (elem.type === 1) { // Diff/mismatch - full base with nucleotide
                // Calculate actual base height (matching reference base calculation)
                const nextBp = elem.start + 1;
                const nextY = (nextBp <= state.endBp ? yGenomeCanonical(nextBp, coordHeight) : yGenomeCanonical(state.endBp, coordHeight));
                const actualBaseHeight = Math.max(2, Math.abs(nextY - ey));
                
                // Color based on nucleotide
                const nuc = elem.sequence ? elem.sequence.toUpperCase() : '?';
                const nucColors = { 'A': '#4CAF50', 'T': '#F44336', 'C': '#2196F3', 'G': '#FF9800' };
                const bgColor = nucColors[nuc] || '#9C27B0';
                
                // Draw background (use actual height, but ensure minimum for visibility)
                const drawHeight = Math.max(2, actualBaseHeight);
                ctx.fillStyle = bgColor;
                ctx.fillRect(ex + 1, ey - drawHeight/2, ew - 2, drawHeight);
                
                // Draw nucleotide letter only if there's enough space
                if (actualBaseHeight >= 8) {
                  ctx.save();
                  ctx.fillStyle = 'white';
                  ctx.font = `bold ${Math.min(10, ew - 4)}px monospace`;
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  // Rotate text -90 degrees for vertical mode
                  ctx.translate(ex + ew/2, ey);
                  ctx.rotate(-Math.PI / 2);
                  ctx.fillText(nuc, 0, 0);
                  ctx.restore();
                }
              }
            }
          }
        }
        
        // Log rendering statistics (vertical mode)
        if (renderedCount > 0 || filteredByRow > 0 || filteredByViewport > 0) {
          console.log(`Genomeshader: Rendered ${renderedCount} reads (filtered: ${filteredByRow} by row, ${filteredByViewport} by viewport, total: ${loadedReadsLayout.reads.length}, viewport: ${state.startBp}-${state.endBp}, maxCols: ${maxCols})`);
        }
      } else if (readsLoading) {
        ctx.fillStyle = cssVar("--muted");
        ctx.font = "14px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Loading...", W/2, H/2);
      } else {
        ctx.fillStyle = cssVar("--muted");
        ctx.font = "11px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.globalAlpha = 0.5;
        ctx.fillText("Load reads via console", W/2, H/2);
        ctx.globalAlpha = 1.0;
      }

      // variant guide lines (gray, blue when hovered)
      for (let idx = 0; idx < variants.length; idx++) {
        const v = variants[idx];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        const isHovered = state.hoveredVariantIndex === idx;
        ctx.strokeStyle = isHovered ? cssVar("--blue") : "rgba(127,127,127,0.3)";
        ctx.globalAlpha = isHovered ? 0.7 : 0.3;
        ctx.lineWidth = isHovered ? 2.5 : 1;
        const y = yGenomeCanonical(v.pos, coordHeight);
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(W-10, y);
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
    } else {
      // Draw row lines for all rows if reads are loaded
      ctx.strokeStyle = grid;
      ctx.lineWidth = 1;
      const top = 8;
      const rowH = 18;
      
      let totalRows = Math.floor((H - top - 12) / rowH);
      if (loadedReadsLayout && loadedReadsLayout.reads && loadedReadsLayout.reads.length > 0) {
        // Draw lines for all rows in the layout
        totalRows = loadedReadsLayout.rowCount || Math.max(...loadedReadsLayout.reads.map(r => r.row)) + 1;
        const scrollTop = reads.scrollTop || 0;
        
        // Only draw lines visible in viewport
        const startRow = Math.max(0, Math.floor(scrollTop / rowH) - 1);
        const endRow = Math.min(totalRows, Math.ceil((scrollTop + H) / rowH) + 1);
        
        for (let i = startRow; i < endRow; i++) {
          const y = top + i*rowH + rowH/2 - scrollTop;
          if (y >= -rowH && y <= H + rowH) {
            ctx.beginPath();
            ctx.moveTo(16, y);
            ctx.lineTo(W-16, y);
            ctx.stroke();
          }
        }
      } else {
        // Default: draw a few rows to suggest lanes
        const rows = Math.floor((H - top - 12) / rowH);
        for (let i=0; i<rows; i++) {
          const y = top + i*rowH + rowH/2;
          ctx.beginPath();
          ctx.moveTo(16, y);
          ctx.lineTo(W-16, y);
          ctx.stroke();
        }
      }

      // placeholder "reads" as rounded rects aligned in genome space
      function drawRead(bpStart, bpEnd, row, alpha=0.20) {
        const x1 = xGenomeCanonical(bpStart, W);
        const x2 = xGenomeCanonical(bpEnd, W);
        const y = top + row*rowH + 2;
        const h = rowH - 6;
        const x = x1;
        const w = Math.max(6, x2-x1);

        // Use WebGPU for fill if available, otherwise fall back to Canvas2D
        const devicePixelRatio = window.devicePixelRatio || 1;
        const useWebGPU = webgpuSupported && readsInstancedRenderer;
        
        if (useWebGPU) {
          // Add rectangle to WebGPU renderer
          readsInstancedRenderer.addRect(
            x * devicePixelRatio,
            y * devicePixelRatio,
            w * devicePixelRatio,
            h * devicePixelRatio,
            [120/255, 180/255, 255/255, alpha]
          );
        } else {
          // Fallback to Canvas2D
          ctx.fillStyle = `rgba(120,180,255,${alpha})`;
          ctx.beginPath();
          roundRect(ctx, x, y, w, h, 6);
          ctx.fill();
        }
        
        // Stroke always uses Canvas2D (minimal overhead for borders)
        ctx.strokeStyle = `rgba(120,180,255,${alpha + 0.15})`;
        ctx.beginPath();
        roundRect(ctx, x, y, w, h, 6);
        ctx.stroke();
      }

      // Draw actual reads if available, otherwise show placeholder
      if (loadedReadsLayout && loadedReadsLayout.reads && loadedReadsLayout.reads.length > 0) {
        // Get scroll position
        const scrollTop = reads.scrollTop || 0;
        
        // Render all reads (no row filtering)
        let renderedCount = 0;
        let filteredByViewport = 0;
        
        for (const read of loadedReadsLayout.reads) {
          // Only filter by viewport (genomic coordinates)
          if (read.end < state.startBp || read.start > state.endBp) {
            filteredByViewport++;
            continue;
          }
          
          renderedCount++;
          
          // Color based on haplotype
          let color, alpha;
          if (read.haplotype === 1) {
            color = [255, 100, 100]; // Red for hap1
            alpha = 0.5;
          } else if (read.haplotype === 2) {
            color = [100, 100, 255]; // Blue for hap2
            alpha = 0.5;
          } else {
            color = [150, 150, 150]; // Gray for unphased
            alpha = 0.35;
          }
          
          // Direction indicator (lighter for reverse)
          if (!read.isForward) alpha *= 0.7;
          
          const x1 = xGenomeCanonical(read.start, W);
          const x2 = xGenomeCanonical(read.end, W);
          // Account for scroll position when rendering
          const y = top + read.row * rowH + 2 - scrollTop;
          const h = rowH - 4;
          const x = Math.max(0, x1);
          const w = Math.max(4, Math.min(x2, W) - x);
          
          // Skip rendering if read is outside visible area (above or below viewport)
          if (y + h < 0 || y > H) continue;
          
          const devicePixelRatio = window.devicePixelRatio || 1;
          const useWebGPU = webgpuSupported && readsInstancedRenderer;
          
          if (useWebGPU) {
            readsInstancedRenderer.addRect(
              x * devicePixelRatio,
              y * devicePixelRatio,
              w * devicePixelRatio,
              h * devicePixelRatio,
              [color[0]/255, color[1]/255, color[2]/255, alpha]
            );
          } else {
            ctx.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${alpha})`;
            ctx.beginPath();
            roundRect(ctx, x, y, w, h, 3);
            ctx.fill();
          }
          
          // Draw direction arrow
          ctx.fillStyle = `rgba(255,255,255,0.6)`;
          const arrowSize = Math.min(6, w * 0.2);
          if (read.isForward) {
            // Arrow pointing right
            ctx.beginPath();
            ctx.moveTo(x + w - arrowSize - 2, y + h/2 - arrowSize/2);
            ctx.lineTo(x + w - 2, y + h/2);
            ctx.lineTo(x + w - arrowSize - 2, y + h/2 + arrowSize/2);
            ctx.fill();
          } else {
            // Arrow pointing left
            ctx.beginPath();
            ctx.moveTo(x + arrowSize + 2, y + h/2 - arrowSize/2);
            ctx.lineTo(x + 2, y + h/2);
            ctx.lineTo(x + arrowSize + 2, y + h/2 + arrowSize/2);
            ctx.fill();
          }
          
          // Draw insertion/deletion/diff markers
          for (const elem of read.elements) {
            if (elem.start < state.startBp || elem.start > state.endBp) continue;
            const ex = xGenomeCanonical(elem.start, W);
            const ey = y;
            const eh = h;
            
            if (elem.type === 2) { // Insertion - purple tick
              ctx.fillStyle = 'rgba(200,100,255,0.9)';
              ctx.fillRect(ex - 1, ey, 2, eh);
            } else if (elem.type === 3) { // Deletion - black gap
              const ex2 = xGenomeCanonical(elem.end, W);
              ctx.fillStyle = 'rgba(0,0,0,0.4)';
              ctx.fillRect(ex, ey + eh/4, ex2 - ex, eh/2);
            } else if (elem.type === 1) { // Diff/mismatch - full base with nucleotide
              // Calculate actual base width (matching reference base calculation)
              const nextBp = elem.start + 1;
              const nextX = nextBp <= state.endBp ? xGenomeCanonical(nextBp, W) : xGenomeCanonical(state.endBp, W);
              const actualBaseWidth = Math.max(2, Math.abs(nextX - ex));
              
              // Color based on nucleotide
              const nuc = elem.sequence ? elem.sequence.toUpperCase() : '?';
              const nucColors = { 'A': '#4CAF50', 'T': '#F44336', 'C': '#2196F3', 'G': '#FF9800' };
              const bgColor = nucColors[nuc] || '#9C27B0';
              
              // Draw background (use actual width, but ensure minimum for visibility)
              const drawWidth = Math.max(2, actualBaseWidth);
              ctx.fillStyle = bgColor;
              ctx.fillRect(ex, ey + 1, drawWidth, eh - 2);
              
              // Draw nucleotide letter only if there's enough space (matching reference base threshold)
              // Reference bases show letters when actualSize >= 8, so use same threshold here
              if (actualBaseWidth >= 8) {
                ctx.fillStyle = 'white';
                ctx.font = `bold ${Math.min(10, eh - 4)}px monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(nuc, ex + drawWidth/2, ey + eh/2);
              }
            }
          }
        }
        
        // Log rendering statistics
        if (renderedCount > 0 || filteredByViewport > 0) {
          console.log(`Genomeshader: Rendered ${renderedCount} reads (filtered: ${filteredByViewport} by viewport, total: ${loadedReadsLayout.reads.length}, rows: ${totalRows}, viewport: ${state.startBp}-${state.endBp})`);
        }
      } else if (readsLoading) {
        // Show loading indicator
        ctx.fillStyle = cssVar("--muted");
        ctx.font = "14px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Loading reads...", W/2, H/2);
      } else {
        // Show placeholder text
        ctx.fillStyle = cssVar("--muted");
        ctx.font = "12px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.globalAlpha = 0.5;
        ctx.fillText("Click 'Load Reads' or run genomeshader_fetchReads() to load", W/2, H/2);
        ctx.globalAlpha = 1.0;
      }

      // variant guide lines (gray, blue when hovered)
      for (let idx = 0; idx < variants.length; idx++) {
        const v = variants[idx];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        const isHovered = state.hoveredVariantIndex === idx;
        ctx.strokeStyle = isHovered ? cssVar("--blue") : "rgba(127,127,127,0.3)";
        ctx.globalAlpha = isHovered ? 0.7 : 0.3;
        ctx.lineWidth = isHovered ? 2.5 : 1;
        const x = xGenomeCanonical(v.pos, W);
        ctx.beginPath();
        ctx.moveTo(x, top);
        ctx.lineTo(x, H-10);
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
    }

    // connectors from Sankey columns down to Reads track (diagonal lines)
    // Disabled for now - makes display too busy
    /*
    const win = visibleVariantWindow();
    const trackLayoutForConnectors = getTrackLayout();
    const flowLayoutItem = trackLayoutForConnectors.find(l => l.track.id === "flow");
    const readsLayoutItem = trackLayoutForConnectors.find(l => l.track.id === "reads");
    
    if (flowLayoutItem && readsLayoutItem && !flowLayoutItem.track.collapsed && !readsLayoutItem.track.collapsed) {
      ctx.strokeStyle = cssVar("--blue");
      ctx.globalAlpha = 0.5;
      ctx.lineWidth = 1;
      
      // Draw diagonal lines from Sankey columns to variant positions in Reads track
      // Similar to how Locus connects to Sankey, but in reverse direction
      for (let i=0; i<win.length; i++) {
        const v = win[i];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        
        // Calculate column x position in Reads canvas coordinates
        // Use the same logic as xColumn but with Reads canvas width
        const margin = 60;
        const innerW = Math.max(10, W - 2*margin);
        let columnX;
        if (state.K <= 1) {
          columnX = margin;
        } else {
          columnX = margin + (i / (state.K - 1)) * innerW;
        }
        
        // Variant position x in Reads track (genomic coordinate mapping)
        const variantX = xGenomeCanonical(v.pos, W);
        
        // Draw diagonal line from column position to variant position
        ctx.beginPath();
        ctx.moveTo(columnX, 0); // top of reads canvas, at column x position
        ctx.lineTo(variantX, top); // connect to variant position at top of read lanes
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
    }
    */

    // Execute WebGPU render pass after read rectangles are added
    // Render to readsWebGPU canvas (separate from tracksWebGPU)
    const hasReadsInstances = readsInstancedRenderer && 
        (readsInstancedRenderer.rectInstances.length > 0 || readsInstancedRenderer.lineInstances.length > 0);
    if (webgpuSupported && readsInstancedRenderer && hasReadsInstances) {
      try {
        // Update projection matrix for current canvas size
        const devicePixelRatio = window.devicePixelRatio || 1;
        const width = readsWebGPU.clientWidth * devicePixelRatio;
        // Use total content height if reads are loaded in horizontal mode, otherwise use visible height
        let height = readsWebGPU.clientHeight * devicePixelRatio;
        if (!isVertical && loadedReadsLayout && loadedReadsLayout.reads && loadedReadsLayout.reads.length > 0) {
          // Horizontal mode with reads loaded - canvas height already set via grid layout above
          // Just update the internal canvas dimensions
          const top = 8;
          const rowH = 18;
          const totalRows = loadedReadsLayout.rowCount || Math.max(...loadedReadsLayout.reads.map(r => r.row)) + 1;
          const totalContentHeight = top + totalRows * rowH + 12;
          height = totalContentHeight * devicePixelRatio;
          readsWebGPU.height = height;
          // Style already set in the grid layout section above
        }
        
        if (readsWebGPU.width !== width || readsWebGPU.height !== height) {
          readsWebGPU.width = width;
          readsWebGPU.height = height;
          readsWebGPUCore.handleResize();
        }
        
        const encoder = readsWebGPUCore.createCommandEncoder();
        const texture = readsWebGPUCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear', // Clear canvas on each render
            storeOp: 'store',
          }],
        });
        
        readsInstancedRenderer.render(encoder, renderPass);
        renderPass.end();
        readsWebGPUCore.submit([encoder.finish()]);
      } catch (error) {
        console.error("Reads WebGPU render error:", error);
        // Fallback: clear instances and continue with Canvas2D only
        readsInstancedRenderer.clear();
      }
    } else if (webgpuSupported && readsInstancedRenderer) {
      // Clear WebGPU canvas if no instances to render
      try {
        const encoder = readsWebGPUCore.createCommandEncoder();
        const texture = readsWebGPUCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear',
            storeOp: 'store',
          }],
        });
        renderPass.end();
        readsWebGPUCore.submit([encoder.finish()]);
      } catch (error) {
        // Ignore errors when clearing
      }
    }
  }

  // Render a Smart track
  function renderSmartTrack(trackId) {
    const track = state.smartTracks.find(t => t.id === trackId);
    if (!track) return;
    
    const layout = getTrackLayout();
    const trackLayout = layout.find(l => l.track.id === trackId);
    if (!trackLayout || trackLayout.track.collapsed) {
      // Clear WebGPU renderer instances if collapsed
      const renderer = state.smartTrackRenderers.get(trackId);
      if (renderer && renderer.instancedRenderer) {
        renderer.instancedRenderer.clear();
      }
      return;
    }
    
    const renderer = state.smartTrackRenderers.get(trackId);
    if (!renderer) return;
    
    const { canvas, webgpuCanvas, container, instancedRenderer, webgpuCore } = renderer;
    
    // Position container based on layout
    const isVertical = isVerticalMode();
    if (isVertical) {
      container.style.left = `${trackLayout.contentLeft}px`;
      container.style.width = `${trackLayout.contentWidth}px`;
      container.style.top = "0";
      container.style.height = "100%";
    } else {
      container.style.top = `${trackLayout.contentTop}px`;
      container.style.left = "0";
      container.style.width = "100%";
      container.style.height = `${trackLayout.contentHeight}px`;
    }
    container.style.display = trackLayout.track.collapsed ? "none" : "block";
    
    if (!canvas || !webgpuCanvas) return;
    
    const dpr = window.devicePixelRatio || 1;
    const W = isVertical ? trackLayout.contentHeight : trackLayout.contentWidth;
    let H = isVertical ? trackLayout.contentWidth : trackLayout.contentHeight;
    
    // Calculate total content height if reads are loaded (horizontal mode)
    let totalContentHeight = H;
    if (!isVertical && track.readsLayout && track.readsLayout.reads && track.readsLayout.reads.length > 0) {
      const top = 8;
      const rowH = 18;
      const totalRows = track.readsLayout.rowCount || Math.max(...track.readsLayout.reads.map(r => r.row)) + 1;
      totalContentHeight = top + totalRows * rowH + 12;
      
      container.style.display = 'grid';
      container.style.gridTemplateRows = '1fr';
      container.style.gridTemplateColumns = '1fr';
      container.style.height = `${trackLayout.contentHeight}px`;
      container.style.overflowY = 'auto';
      container.style.overflowX = 'hidden';
      
      canvas.height = totalContentHeight * dpr;
      canvas.style.height = totalContentHeight + 'px';
      canvas.style.width = W + 'px';
      canvas.style.gridRow = '1';
      canvas.style.gridColumn = '1';
      canvas.style.position = 'static';
      canvas.width = W * dpr;
      
      webgpuCanvas.style.height = totalContentHeight + 'px';
      webgpuCanvas.style.width = W + 'px';
      webgpuCanvas.style.gridRow = '1';
      webgpuCanvas.style.gridColumn = '1';
      webgpuCanvas.style.position = 'static';
    } else {
      container.style.display = '';
      container.style.gridTemplateRows = '';
      container.style.gridTemplateColumns = '';
      canvas.style.gridRow = '';
      canvas.style.gridColumn = '';
      webgpuCanvas.style.gridRow = '';
      webgpuCanvas.style.gridColumn = '';
      resizeCanvasTo(container, canvas);
      const rect = container.getBoundingClientRect();
      if (rect.width > 0 && rect.height > 0) {
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
      }
    }
    
    const ctx = canvas.getContext("2d");
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.scale(dpr, dpr);
    
    // Clear WebGPU renderer instances
    if (instancedRenderer) {
      instancedRenderer.clear();
    }
    
    const colText = cssVar("--muted");
    const grid = cssVar("--grid2");
    
    const bgHeight = (!isVertical && track.readsLayout && track.readsLayout.reads && track.readsLayout.reads.length > 0) ? totalContentHeight : H;
    ctx.fillStyle = "rgba(127,127,127,0.02)";
    ctx.fillRect(0,0,W,bgHeight);
    
    if (isVertical) {
      const coordHeight = H;
      const left = 8;
      const colW = 18;
      const cols = Math.floor((W - left - 12) / colW);
      
      // Draw column lines
      ctx.strokeStyle = grid;
      ctx.lineWidth = 1;
      for (let i=0; i<cols; i++) {
        const x = left + i*colW + colW/2;
        ctx.beginPath();
        ctx.moveTo(x, 16);
        ctx.lineTo(x, H-16);
        ctx.stroke();
      }
      
      // Draw reads if available
      if (track.readsLayout && track.readsLayout.reads && track.readsLayout.reads.length > 0) {
        const maxCols = Math.floor((W - left - 12) / colW);
        for (const read of track.readsLayout.reads) {
          if (read.row >= maxCols) continue;
          if (read.end < state.startBp || read.start > state.endBp) continue;
          
          let color, alpha;
          if (read.haplotype === 1) {
            color = [255, 100, 100];
            alpha = 0.5;
          } else if (read.haplotype === 2) {
            color = [100, 100, 255];
            alpha = 0.5;
          } else {
            color = [150, 150, 150];
            alpha = 0.35;
          }
          if (!read.isForward) alpha *= 0.7;
          
          const y1 = yGenomeCanonical(read.start, coordHeight);
          const y2 = yGenomeCanonical(read.end, coordHeight);
          const x = left + read.row * colW + 2;
          const w = colW - 4;
          const y = Math.min(y1, y2);
          const h = Math.max(4, Math.abs(y2 - y1));
          
          if (instancedRenderer && webgpuSupported) {
            instancedRenderer.addRect(
              x * dpr, y * dpr,
              w * dpr, h * dpr,
              [color[0]/255, color[1]/255, color[2]/255, alpha]
            );
          } else {
            ctx.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${alpha})`;
            ctx.beginPath();
            roundRect(ctx, x, y, w, h, 3);
            ctx.fill();
          }
          
          // Draw insertion/deletion/diff markers (vertical mode)
          if (read.elements && read.elements.length > 0) {
            for (const elem of read.elements) {
              if (elem.start < state.startBp || elem.start > state.endBp) continue;
              const ey = yGenomeCanonical(elem.start, coordHeight);
              const ex = x;
              const ew = w;
              
              if (elem.type === 2) { // Insertion - purple tick
                ctx.fillStyle = 'rgba(200,100,255,0.9)';
                ctx.fillRect(ex, ey - 1, ew, 2);
              } else if (elem.type === 3) { // Deletion - black gap
                const ey2 = yGenomeCanonical(elem.end, coordHeight);
                const delY = Math.min(ey, ey2);
                const delH = Math.max(2, Math.abs(ey2 - ey));
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.fillRect(ex + ew/4, delY, ew/2, delH);
              } else if (elem.type === 1) { // Diff/mismatch - full base with nucleotide
                // Calculate actual base height
                const nextBp = elem.start + 1;
                const nextY = (nextBp <= state.endBp ? yGenomeCanonical(nextBp, coordHeight) : yGenomeCanonical(state.endBp, coordHeight));
                const actualBaseHeight = Math.max(2, Math.abs(nextY - ey));
                
                // Color based on nucleotide
                const nuc = elem.sequence ? elem.sequence.toUpperCase() : '?';
                const nucColors = { 'A': '#4CAF50', 'T': '#F44336', 'C': '#2196F3', 'G': '#FF9800' };
                const bgColor = nucColors[nuc] || '#9C27B0';
                
                // Draw background
                const drawHeight = Math.max(2, actualBaseHeight);
                ctx.fillStyle = bgColor;
                ctx.fillRect(ex + 1, ey - drawHeight/2, ew - 2, drawHeight);
                
                // Draw nucleotide letter only if there's enough space
                if (actualBaseHeight >= 8) {
                  ctx.save();
                  ctx.fillStyle = 'white';
                  ctx.font = `bold ${Math.min(10, ew - 4)}px monospace`;
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  // Rotate text -90 degrees for vertical mode
                  ctx.translate(ex + ew/2, ey);
                  ctx.rotate(-Math.PI / 2);
                  ctx.fillText(nuc, 0, 0);
                  ctx.restore();
                }
              }
            }
          }
        }
      } else if (track.loading) {
        ctx.fillStyle = cssVar("--muted");
        ctx.font = "14px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Loading...", W/2, H/2);
      }
      
      // Draw variant markers
      for (let idx = 0; idx < variants.length; idx++) {
        const v = variants[idx];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        const isHovered = state.hoveredVariantIndex === idx;
        ctx.strokeStyle = isHovered ? cssVar("--blue") : "rgba(127,127,127,0.3)";
        ctx.globalAlpha = isHovered ? 0.7 : 0.3;
        ctx.lineWidth = isHovered ? 2.5 : 1;
        const y = yGenomeCanonical(v.pos, coordHeight);
        ctx.beginPath();
        ctx.moveTo(left, y);
        ctx.lineTo(W-10, y);
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
    } else {
      // Horizontal mode
      const top = 8;
      const rowH = 18;
      
      let totalRows = Math.floor((H - top - 12) / rowH);
      if (track.readsLayout && track.readsLayout.reads && track.readsLayout.reads.length > 0) {
        totalRows = track.readsLayout.rowCount || Math.max(...track.readsLayout.reads.map(r => r.row)) + 1;
        const scrollTop = container.scrollTop || 0;
        
        const startRow = Math.max(0, Math.floor(scrollTop / rowH) - 1);
        const endRow = Math.min(totalRows, Math.ceil((scrollTop + H) / rowH) + 1);
        
        ctx.strokeStyle = grid;
        ctx.lineWidth = 1;
        for (let i = startRow; i < endRow; i++) {
          const y = top + i*rowH + rowH/2 - scrollTop;
          if (y >= -rowH && y <= totalContentHeight + rowH) {
            ctx.beginPath();
            ctx.moveTo(16, y);
            ctx.lineTo(W-16, y);
            ctx.stroke();
          }
        }
      } else {
        ctx.strokeStyle = grid;
        ctx.lineWidth = 1;
        const rows = Math.floor((H - top - 12) / rowH);
        for (let i=0; i<rows; i++) {
          const y = top + i*rowH + rowH/2;
          ctx.beginPath();
          ctx.moveTo(16, y);
          ctx.lineTo(W-16, y);
          ctx.stroke();
        }
      }
      
      // Draw reads if available
      if (track.readsLayout && track.readsLayout.reads && track.readsLayout.reads.length > 0) {
        const scrollTop = container.scrollTop || 0;
        for (const read of track.readsLayout.reads) {
          if (read.end < state.startBp || read.start > state.endBp) continue;
          
          let color, alpha;
          if (read.haplotype === 1) {
            color = [255, 100, 100];
            alpha = 0.5;
          } else if (read.haplotype === 2) {
            color = [100, 100, 255];
            alpha = 0.5;
          } else {
            color = [150, 150, 150];
            alpha = 0.35;
          }
          if (!read.isForward) alpha *= 0.7;
          
          const x1 = xGenomeCanonical(read.start, W);
          const x2 = xGenomeCanonical(read.end, W);
          const y = top + read.row * rowH + 2 - scrollTop;
          const h = rowH - 4;
          const x = Math.max(0, x1);
          const w = Math.max(4, Math.min(x2, W) - x);
          
          if (y + h < 0 || y > totalContentHeight) continue;
          
          if (instancedRenderer && webgpuSupported) {
            instancedRenderer.addRect(
              x * dpr, y * dpr,
              w * dpr, h * dpr,
              [color[0]/255, color[1]/255, color[2]/255, alpha]
            );
          } else {
            ctx.fillStyle = `rgba(${color[0]},${color[1]},${color[2]},${alpha})`;
            ctx.beginPath();
            roundRect(ctx, x, y, w, h, 3);
            ctx.fill();
          }
          
          // Draw direction arrow
          ctx.fillStyle = `rgba(255,255,255,0.6)`;
          const arrowSize = Math.min(6, w * 0.2);
          if (read.isForward) {
            // Arrow pointing right
            ctx.beginPath();
            ctx.moveTo(x + w - arrowSize - 2, y + h/2 - arrowSize/2);
            ctx.lineTo(x + w - 2, y + h/2);
            ctx.lineTo(x + w - arrowSize - 2, y + h/2 + arrowSize/2);
            ctx.fill();
          } else {
            // Arrow pointing left
            ctx.beginPath();
            ctx.moveTo(x + arrowSize + 2, y + h/2 - arrowSize/2);
            ctx.lineTo(x + 2, y + h/2);
            ctx.lineTo(x + arrowSize + 2, y + h/2 + arrowSize/2);
            ctx.fill();
          }
          
          // Draw insertion/deletion/diff markers (horizontal mode)
          if (read.elements && read.elements.length > 0) {
            for (const elem of read.elements) {
              if (elem.start < state.startBp || elem.start > state.endBp) continue;
              const ex = xGenomeCanonical(elem.start, W);
              const ey = y;
              const eh = h;
              
              if (elem.type === 2) { // Insertion - purple tick
                ctx.fillStyle = 'rgba(200,100,255,0.9)';
                ctx.fillRect(ex - 1, ey, 2, eh);
              } else if (elem.type === 3) { // Deletion - black gap
                const ex2 = xGenomeCanonical(elem.end, W);
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.fillRect(ex, ey + eh/4, ex2 - ex, eh/2);
              } else if (elem.type === 1) { // Diff/mismatch - full base with nucleotide
                // Calculate actual base width
                const nextBp = elem.start + 1;
                const nextX = nextBp <= state.endBp ? xGenomeCanonical(nextBp, W) : xGenomeCanonical(state.endBp, W);
                const actualBaseWidth = Math.max(2, Math.abs(nextX - ex));
                
                // Color based on nucleotide
                const nuc = elem.sequence ? elem.sequence.toUpperCase() : '?';
                const nucColors = { 'A': '#4CAF50', 'T': '#F44336', 'C': '#2196F3', 'G': '#FF9800' };
                const bgColor = nucColors[nuc] || '#9C27B0';
                
                // Draw background
                const drawWidth = Math.max(2, actualBaseWidth);
                ctx.fillStyle = bgColor;
                ctx.fillRect(ex, ey + 1, drawWidth, eh - 2);
                
                // Draw nucleotide letter only if there's enough space
                if (actualBaseWidth >= 8) {
                  ctx.fillStyle = 'white';
                  ctx.font = `bold ${Math.min(10, eh - 4)}px monospace`;
                  ctx.textAlign = 'center';
                  ctx.textBaseline = 'middle';
                  ctx.fillText(nuc, ex + drawWidth/2, ey + eh/2);
                }
              }
            }
          }
        }
      } else if (track.loading) {
        ctx.fillStyle = cssVar("--muted");
        ctx.font = "14px system-ui, sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Loading...", W/2, H/2);
      }
      
      // Draw variant markers
      for (let idx = 0; idx < variants.length; idx++) {
        const v = variants[idx];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        const isHovered = state.hoveredVariantIndex === idx;
        ctx.strokeStyle = isHovered ? cssVar("--blue") : "rgba(127,127,127,0.3)";
        ctx.globalAlpha = isHovered ? 0.7 : 0.3;
        ctx.lineWidth = isHovered ? 2.5 : 1;
        const x = xGenomeCanonical(v.pos, W);
        ctx.beginPath();
        ctx.moveTo(x, top);
        ctx.lineTo(x, totalContentHeight || H-10);
        ctx.stroke();
      }
      ctx.globalAlpha = 1.0;
    }
    
    // Execute WebGPU render pass
    if (webgpuSupported && instancedRenderer && 
        (instancedRenderer.rectInstances.length > 0 || instancedRenderer.lineInstances.length > 0)) {
      try {
        const width = webgpuCanvas.clientWidth * dpr;
        let height = webgpuCanvas.clientHeight * dpr;
        if (!isVertical && track.readsLayout && track.readsLayout.reads && track.readsLayout.reads.length > 0) {
          height = totalContentHeight * dpr;
          webgpuCanvas.height = height;
        }
        
        if (webgpuCanvas.width !== width || webgpuCanvas.height !== height) {
          webgpuCanvas.width = width;
          webgpuCanvas.height = height;
          webgpuCore.handleResize();
        }
        
        const encoder = webgpuCore.createCommandEncoder();
        const texture = webgpuCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear',
            storeOp: 'store',
          }],
        });
        
        instancedRenderer.render(encoder, renderPass);
        renderPass.end();
        webgpuCore.submit([encoder.finish()]);
      } catch (error) {
        console.error(`Smart track ${trackId} WebGPU render error:`, error);
        if (instancedRenderer) instancedRenderer.clear();
      }
    } else if (webgpuSupported && instancedRenderer) {
      // Clear WebGPU canvas if no instances
      try {
        const encoder = webgpuCore.createCommandEncoder();
        const texture = webgpuCore.getCurrentTexture();
        const renderPass = encoder.beginRenderPass({
          colorAttachments: [{
            view: texture.createView(),
            clearValue: { r: 0, g: 0, b: 0, a: 0 },
            loadOp: 'clear',
            storeOp: 'store',
          }],
        });
        renderPass.end();
        webgpuCore.submit([encoder.finish()]);
      } catch (error) {
        // Ignore errors when clearing
      }
    }
  }

  // -----------------------------
  // Track controls rendering
  // -----------------------------
  const trackControls = document.getElementById("trackControls");
  function renderTrackControls() {
    trackControls.innerHTML = "";
    const layout = getTrackLayout();
    const isVertical = isVerticalMode();

    for (const item of layout) {
      const track = item.track;
      const container = document.createElement("div");
      container.className = "track-control-container";
      
      if (isVertical) {
        container.style.position = "absolute";
        container.style.left = `${item.left}px`;
        container.style.width = `${item.width}px`;
        container.style.top = "0";
        container.style.height = "100%";
      } else {
        container.style.position = "absolute";
        container.style.left = "0";
        container.style.right = "0";
        container.style.top = `${item.top}px`;
        container.style.height = `${item.height}px`;
      }
      container.dataset.trackId = track.id;

      const controls = document.createElement("div");
      controls.className = "track-controls";
      controls.dataset.trackId = track.id;

      const collapseBtn = document.createElement("button");
      collapseBtn.className = "track-collapse-btn";
      if (isVertical) {
        collapseBtn.textContent = track.collapsed ? "▲" : "▶";
      } else {
        collapseBtn.textContent = track.collapsed ? "▶" : "▼";
      }
      collapseBtn.type = "button";
      collapseBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        e.preventDefault();
        track.collapsed = !track.collapsed;
        updateTracksHeight();
        renderAll();
      });

      const label = document.createElement("div");
      label.className = "track-label";
      
      // Check if this is a Smart track
      const isSmartTrack = track.id.startsWith("smart-track-");
      
      if (isSmartTrack) {
        // Make label editable for Smart tracks
        label.style.cursor = "text";
        label.contentEditable = false;
        label.title = "Click to edit label";
        
        // Create input field for editing (hidden initially)
        const labelInput = document.createElement("input");
        labelInput.type = "text";
        labelInput.className = "smart-track-label-input";
        labelInput.value = track.label;
        labelInput.style.display = "none";
        labelInput.style.fontSize = "12px";
        labelInput.style.fontWeight = "600";
        labelInput.style.color = "var(--muted)";
        labelInput.style.background = "transparent";
        labelInput.style.border = "1px solid var(--border2)";
        labelInput.style.borderRadius = "4px";
        labelInput.style.padding = "2px 4px";
        labelInput.style.width = "auto";
        labelInput.style.minWidth = "100px";
        labelInput.style.maxWidth = "200px";
        
        // Click handler to start editing
        label.addEventListener("click", (e) => {
          e.stopPropagation();
          label.style.display = "none";
          labelInput.style.display = "inline-block";
          labelInput.focus();
          labelInput.select();
        });
        
        // Save on blur or Enter
        const saveLabel = () => {
          const newLabel = labelInput.value.trim() || track.label;
          label.textContent = newLabel;
          label.style.display = "";
          labelInput.style.display = "none";
          editSmartTrackLabel(track.id, newLabel);
        };
        
        labelInput.addEventListener("blur", saveLabel);
        labelInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            saveLabel();
          } else if (e.key === "Escape") {
            e.preventDefault();
            labelInput.value = track.label;
            label.style.display = "";
            labelInput.style.display = "none";
          }
        });
        
        label.textContent = track.label;
        controls.appendChild(labelInput);
      } else {
        // For the Locus track, append the extent in parentheses
        if (track.id === "ruler") {
          const extent = Math.floor(state.endBp) - Math.floor(state.startBp);
          label.textContent = `${track.label} (${extent.toLocaleString()} bp)`;
        } else {
          label.textContent = track.label;
        }
      }

      // Add Smart track controls if needed
      if (isSmartTrack) {
        // Strategy dropdown
        const strategySelect = document.createElement("select");
        strategySelect.className = "smart-track-strategy-select";
        strategySelect.id = `smart-track-strategy-${track.id}`;
        strategySelect.name = `smart-track-strategy-${track.id}`;
        strategySelect.style.fontSize = "11px";
        strategySelect.style.padding = "2px 4px";
        strategySelect.style.border = "1px solid var(--border2)";
        strategySelect.style.borderRadius = "4px";
        strategySelect.style.background = "var(--panel)";
        strategySelect.style.color = "var(--text)";
        strategySelect.style.marginLeft = "6px";
        strategySelect.style.cursor = "pointer";
        
        const strategies = [
          { value: "best_evidence", label: "Best evidence" },
          { value: "most_diverse", label: "Most diverse" },
          { value: "compare_branches", label: "Compare branches" },
          { value: "carriers_controls", label: "Carriers + controls" },
          { value: "random", label: "Random" }
        ];
        
        strategies.forEach(s => {
          const option = document.createElement("option");
          option.value = s.value;
          option.textContent = s.label;
          if (s.value === track.strategy) {
            option.selected = true;
          }
          strategySelect.appendChild(option);
        });
        
        strategySelect.addEventListener("change", (e) => {
          e.stopPropagation();
          updateSmartTrackStrategy(track.id, e.target.value);
        });
        strategySelect.style.pointerEvents = "auto";
        strategySelect.style.zIndex = "20";
        
        // Reload button (reload current sample)
        const reloadBtn = document.createElement("button");
        reloadBtn.className = "smart-track-reload-btn";
        reloadBtn.textContent = "↻";
        reloadBtn.title = "Reload sample";
        reloadBtn.type = "button";
        reloadBtn.style.fontSize = "16px";
        reloadBtn.style.padding = "0";
        reloadBtn.style.border = "none";
        reloadBtn.style.borderRadius = "0";
        reloadBtn.style.background = "transparent";
        reloadBtn.style.color = "var(--muted)";
        reloadBtn.style.cursor = "pointer";
        reloadBtn.style.marginLeft = "6px";
        reloadBtn.style.width = "18px";
        reloadBtn.style.height = "18px";
        reloadBtn.style.display = "flex";
        reloadBtn.style.alignItems = "center";
        reloadBtn.style.justifyContent = "center";
        reloadBtn.style.lineHeight = "1";
        reloadBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          e.preventDefault();
          reloadSmartTrack(track.id);
        });
        reloadBtn.style.pointerEvents = "auto";
        reloadBtn.style.zIndex = "20";
        
        // Shuffle button (choose new sample)
        const shuffleBtn = document.createElement("button");
        shuffleBtn.className = "smart-track-shuffle-btn";
        shuffleBtn.textContent = "⇆";
        shuffleBtn.title = "Shuffle to new sample";
        shuffleBtn.type = "button";
        shuffleBtn.style.fontSize = "16px";
        shuffleBtn.style.padding = "0";
        shuffleBtn.style.border = "none";
        shuffleBtn.style.borderRadius = "0";
        shuffleBtn.style.background = "transparent";
        shuffleBtn.style.color = "var(--muted)";
        shuffleBtn.style.cursor = "pointer";
        shuffleBtn.style.marginLeft = "6px";
        shuffleBtn.style.width = "18px";
        shuffleBtn.style.height = "18px";
        shuffleBtn.style.display = "flex";
        shuffleBtn.style.alignItems = "center";
        shuffleBtn.style.justifyContent = "center";
        shuffleBtn.style.lineHeight = "1";
        shuffleBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          e.preventDefault();
          shuffleSmartTrack(track.id);
        });
        shuffleBtn.style.pointerEvents = "auto";
        shuffleBtn.style.zIndex = "20";
        
        // Close button
        const closeBtn = document.createElement("button");
        closeBtn.className = "smart-track-close-btn";
        closeBtn.textContent = "×";
        closeBtn.title = "Close track";
        closeBtn.type = "button";
        closeBtn.style.fontSize = "16px";
        closeBtn.style.padding = "0";
        closeBtn.style.border = "none";
        closeBtn.style.borderRadius = "0";
        closeBtn.style.background = "transparent";
        closeBtn.style.color = "var(--muted)";
        closeBtn.style.cursor = "pointer";
        closeBtn.style.marginLeft = "6px";
        closeBtn.style.width = "18px";
        closeBtn.style.height = "18px";
        closeBtn.style.display = "flex";
        closeBtn.style.alignItems = "center";
        closeBtn.style.justifyContent = "center";
        closeBtn.style.lineHeight = "1";
        closeBtn.style.pointerEvents = "auto";
        closeBtn.style.zIndex = "20";
        closeBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          e.preventDefault();
          // Verify track still exists before removing
          const trackExists = state.smartTracks.find(t => t.id === track.id);
          if (trackExists) {
            removeSmartTrack(track.id);
          }
        });
        
        // In vertical mode, reverse order: label on top, button on bottom
        if (isVertical) {
          controls.appendChild(label);
          controls.appendChild(strategySelect);
          controls.appendChild(reloadBtn);
          controls.appendChild(shuffleBtn);
          controls.appendChild(closeBtn);
          controls.appendChild(collapseBtn);
          container.appendChild(controls);
        } else {
          controls.appendChild(collapseBtn);
          controls.appendChild(label);
          controls.appendChild(strategySelect);
          controls.appendChild(reloadBtn);
          controls.appendChild(shuffleBtn);
          controls.appendChild(closeBtn);
          container.appendChild(controls);
        }
      } else {
        // In vertical mode, reverse order: label on top, button on bottom
        if (isVertical) {
          controls.appendChild(label);
          controls.appendChild(collapseBtn);
          container.appendChild(controls);
          // After appending, measure the label's width and adjust transform
          // With transform-origin: left center, the first character stays at bottom
          // We need to translate right by half width to center it horizontally
          setTimeout(() => {
            try {
              const width = label.offsetWidth || label.getBoundingClientRect().width;
              if (width > 0) {
                // After -90deg rotation:
                // - translateX moves vertically (negative = up, positive = down)
                // - translateY moves horizontally (negative = left, positive = right)
                // Use translateX(12px) to position vertically and translateY(0.0px) for horizontal
                label.style.transform = `rotate(-90deg) translateX(12px) translateY(0.0px)`;
              }
            } catch (e) {
              console.error('Error adjusting label transform:', e);
            }
          }, 10);
        } else {
          controls.appendChild(collapseBtn);
          controls.appendChild(label);
          container.appendChild(controls);
        }
      }

      if (!track.collapsed) {
        const resizeHandle = document.createElement("div");
        resizeHandle.className = "track-resize-handle";
        resizeHandle.dataset.trackId = track.id;
        container.appendChild(resizeHandle);
      }

      trackControls.appendChild(container);
    }
  }

  // -----------------------------
  // HUD + renderAll
  // -----------------------------
  let hudHideTimeout = null;

  function renderHUD() {
    const locusText = `${state.contig}:${Math.floor(state.startBp).toLocaleString()}-${Math.floor(state.endBp).toLocaleString()}`;
    hud.textContent = locusText;

    // In inline mode, show HUD and auto-hide after 3 seconds
    if (hostMode === 'inline') {
      hud.classList.add('visible');

      // Clear any existing timeout
      if (hudHideTimeout) {
        clearTimeout(hudHideTimeout);
      }

      // Set new timeout to hide HUD after 3 seconds
      hudHideTimeout = setTimeout(() => {
        hud.classList.remove('visible');
        hudHideTimeout = null;
      }, 3000);
    }
  }

  function updateTooltip() {
    if (state.hoveredRepeatTooltip) {
      tooltip.textContent = state.hoveredRepeatTooltip.text;
      tooltip.style.left = state.hoveredRepeatTooltip.x + 'px';
      tooltip.style.top = state.hoveredRepeatTooltip.y + 'px';
      tooltip.classList.add('visible');
    } else if (state.hoveredVariantLabelTooltip) {
      tooltip.textContent = state.hoveredVariantLabelTooltip.text;
      tooltip.style.left = state.hoveredVariantLabelTooltip.x + 'px';
      tooltip.style.top = state.hoveredVariantLabelTooltip.y + 'px';
      tooltip.classList.add('visible');
    } else {
      tooltip.classList.remove('visible');
    }
  }

  // Throttle utility for mousemove handlers (16ms = ~60fps)
  function throttle(func, delay) {
    let lastCall = 0;
    let timeoutId = null;
    return function(...args) {
      const now = Date.now();
      const timeSinceLastCall = now - lastCall;
      
      if (timeSinceLastCall >= delay) {
        lastCall = now;
        func.apply(this, args);
      } else {
        // Clear any pending timeout
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
        }
        // Schedule call for after delay
        timeoutId = setTimeout(() => {
          lastCall = Date.now();
          func.apply(this, args);
        }, delay - timeSinceLastCall);
      }
    };
  }

  // Debounce utility for ResizeObserver callbacks (100ms delay)
  function debounce(func, delay) {
    let timeoutId = null;
    return function(...args) {
      // Clear any pending timeout
      if (timeoutId !== null) {
        clearTimeout(timeoutId);
      }
      // Schedule call for after delay
      timeoutId = setTimeout(() => {
        func.apply(this, args);
      }, delay);
    };
  }

  // Update Locus track variant element hover styles
  function updateLocusTrackHover() {
    state.locusVariantElements.forEach((elements, idx) => {
      const isHovered = state.hoveredVariantIndex === idx;
      const strokeWidth = isHovered ? 2.5 : 1.2;
      const circleStrokeWidth = isHovered ? 2.2 : 1.4;
      const strokeColor = isHovered ? "var(--blue)" : "rgba(127,127,127,0.5)";
      
      if (elements.lineEl) {
        elements.lineEl.setAttribute("stroke", strokeColor);
        elements.lineEl.setAttribute("stroke-width", strokeWidth);
      }
      if (elements.circleEl) {
        elements.circleEl.setAttribute("stroke", strokeColor);
        elements.circleEl.setAttribute("stroke-width", circleStrokeWidth);
      }
    });
  }

  // Set up variant hover areas in canvas overlays
  function setupVariantHoverAreas() {
    if (!flowOverlay || !readsOverlay) return;
    
    const isVertical = isVerticalMode();
    const clearSvg = (svg) => { while (svg.firstChild) svg.removeChild(svg.firstChild); };
    
    // Shared click handler for variant selection
    const handleVariantRectClick = (e, variantId) => {
      e.stopPropagation();
      
      // Find variant by ID
      const variant = variants.find(v => String(v.id) === String(variantId));
      if (!variant) return;
      
      // Get all alleles for this variant
      const { labels } = getFormattedLabelsForVariant(variant);
      let order = state.variantAlleleOrder.get(variant.id);
      if (!order || order.length !== labels.length) {
        order = [...labels];
        state.variantAlleleOrder.set(variant.id, order);
      }
      
      // Create label keys for all alleles: "variantId:alleleIndex"
      const variantAlleleKeys = order.map((label, alleleIndex) => `${variant.id}:${alleleIndex}`);
      
      // Handle selection with Ctrl/Cmd for multi-select
      if (e.ctrlKey || e.metaKey) {
        // Multi-select: toggle all alleles for this variant
        const allSelected = variantAlleleKeys.every(key => state.selectedAlleles.has(key));
        if (allSelected) {
          // All are selected, deselect all
          variantAlleleKeys.forEach(key => state.selectedAlleles.delete(key));
        } else {
          // Not all are selected, select all
          variantAlleleKeys.forEach(key => state.selectedAlleles.add(key));
        }
      } else {
        // Single-select: replace selection with all alleles for this variant
        // If clicking on already-selected variant (all alleles selected), deselect it
        const allSelected = variantAlleleKeys.every(key => state.selectedAlleles.has(key));
        if (allSelected && state.selectedAlleles.size === variantAlleleKeys.length) {
          state.selectedAlleles.clear();
        } else {
          state.selectedAlleles.clear();
          variantAlleleKeys.forEach(key => state.selectedAlleles.add(key));
        }
      }
      
      renderFlowCanvas();
      if (window.updateSelectionDisplay) window.updateSelectionDisplay();
    };
    
    // Clear existing hover areas
    clearSvg(flowOverlay);
    clearSvg(readsOverlay);
    
    // Set overlay dimensions to match containers
    const flowW = flowWidthPx();
    const flowH = flowHeightPx();
    const readsW = readsWidthPx();
    const readsH = readsHeightPx();
    
    flowOverlay.setAttribute("width", flowW);
    flowOverlay.setAttribute("height", flowH);
    flowOverlay.setAttribute("viewBox", `0 0 ${flowW} ${flowH}`);
    
    readsOverlay.setAttribute("width", readsW);
    readsOverlay.setAttribute("height", readsH);
    readsOverlay.setAttribute("viewBox", `0 0 ${readsW} ${readsH}`);
    
    // Create hover areas for Reads track
    const top = 8;
    const left = 8;
    
    if (isVertical) {
      // Vertical mode: horizontal lines
      for (let idx = 0; idx < variants.length; idx++) {
        const v = variants[idx];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        const y = yGenomeCanonical(v.pos, readsH);
        
        // Create invisible hover rectangle
        const hoverRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        hoverRect.setAttribute("x", left);
        hoverRect.setAttribute("y", y - 8);
        hoverRect.setAttribute("width", Math.max(0, readsW - left - 10));
        hoverRect.setAttribute("height", 16);
        hoverRect.setAttribute("fill", "transparent");
        hoverRect.setAttribute("data-variant-id", v.id);
        hoverRect.style.cursor = "pointer";
        hoverRect.style.pointerEvents = "auto";
        hoverRect.addEventListener("click", (e) => handleVariantRectClick(e, v.id));
        readsOverlay.appendChild(hoverRect);
      }
    } else {
      // Horizontal mode: vertical lines
      for (let idx = 0; idx < variants.length; idx++) {
        const v = variants[idx];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        const x = xGenomeCanonical(v.pos, readsW);
        
        // Create invisible hover rectangle
        const hoverRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        hoverRect.setAttribute("x", x - 8);
        hoverRect.setAttribute("y", top);
        hoverRect.setAttribute("width", 16);
        hoverRect.setAttribute("height", Math.max(0, readsH - top - 10));
        hoverRect.setAttribute("fill", "transparent");
        hoverRect.setAttribute("data-variant-id", v.id);
        hoverRect.style.cursor = "pointer";
        hoverRect.style.pointerEvents = "auto";
        hoverRect.addEventListener("click", (e) => handleVariantRectClick(e, v.id));
        readsOverlay.appendChild(hoverRect);
      }
    }
    
    // Create hover areas for Variants/Haplotypes track
    const win = visibleVariantWindow();
    const variantMode = getVariantLayoutMode();
    
    if (isVertical) {
      const junctionX = 70;
      const left = 8;
      
      for (let i = 0; i < win.length; i++) {
        const v = win[i];
        const variantIdx = variants.findIndex(v2 => v2.id === v.id);
        if (variantIdx === -1) continue;
        
        const cy = variantMode === "genomic"
          ? yGenomeCanonical(v.pos, flowH)
          : yColumn(i, win.length);
        
        // Create hover rectangle for the column
        const hoverRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        hoverRect.setAttribute("x", junctionX);
        hoverRect.setAttribute("y", cy - 8);
        hoverRect.setAttribute("width", Math.max(0, flowW - junctionX - 10));
        hoverRect.setAttribute("height", 16);
        hoverRect.setAttribute("fill", "transparent");
        hoverRect.setAttribute("data-variant-id", v.id);
        hoverRect.style.cursor = "pointer";
        hoverRect.style.pointerEvents = "auto";
        hoverRect.addEventListener("click", (e) => handleVariantRectClick(e, v.id));
        flowOverlay.appendChild(hoverRect);
      }
    } else {
      const junctionY = 40;
      
      for (let i = 0; i < win.length; i++) {
        const v = win[i];
        const variantIdx = state.firstVariantIndex + i;
        if (variantIdx >= variants.length) continue;
        const variant = variants[variantIdx];
        
        const cx = variantMode === "genomic"
          ? xGenomeCanonical(v.pos, flowW)
          : xColumn(i, win.length);
        
        // Create hover rectangle for the column
        const hoverRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        hoverRect.setAttribute("x", cx - 8);
        hoverRect.setAttribute("y", junctionY);
        hoverRect.setAttribute("width", 16);
        hoverRect.setAttribute("height", Math.max(0, flowH - junctionY - 10));
        hoverRect.setAttribute("fill", "transparent");
        hoverRect.setAttribute("data-variant-id", variant.id);
        hoverRect.style.cursor = "pointer";
        hoverRect.style.pointerEvents = "auto";
        hoverRect.addEventListener("click", (e) => handleVariantRectClick(e, variant.id));
        flowOverlay.appendChild(hoverRect);
      }
    }
    
    // Set up event delegation for hover detection
    // Use a single handler for all hover areas
    const handleVariantHover = (e) => {
      const target = e.target;
      const variantId = target.getAttribute("data-variant-id");
      if (!variantId) return;
      
      // Find variant index by ID
      const variantIdx = variants.findIndex(v => String(v.id) === String(variantId));
      if (variantIdx === -1) return;
      
      if (state.hoveredVariantIndex !== variantIdx) {
        state.hoveredVariantIndex = variantIdx;
        renderHoverOnly();
      }
    };
    
    const handleVariantLeave = (e) => {
      const target = e.target;
      if (target.hasAttribute("data-variant-id")) {
        if (state.hoveredVariantIndex !== null) {
          state.hoveredVariantIndex = null;
          renderHoverOnly();
        }
      }
    };
    
    // Remove old listeners if they exist (for hover only, clicks are now on rectangles)
    if (flowOverlay._variantHoverHandler) {
      flowOverlay.removeEventListener("mouseenter", flowOverlay._variantHoverHandler, true);
      flowOverlay.removeEventListener("mouseleave", flowOverlay._variantHoverHandler, true);
    }
    if (readsOverlay._variantHoverHandler) {
      readsOverlay.removeEventListener("mouseenter", readsOverlay._variantHoverHandler, true);
      readsOverlay.removeEventListener("mouseleave", readsOverlay._variantHoverHandler, true);
    }
    
    // Add new listeners with capture phase to catch events on child elements (hover only)
    flowOverlay._variantHoverHandler = handleVariantHover;
    flowOverlay._variantLeaveHandler = handleVariantLeave;
    flowOverlay.addEventListener("mouseenter", handleVariantHover, true);
    flowOverlay.addEventListener("mouseleave", handleVariantLeave, true);
    
    readsOverlay._variantHoverHandler = handleVariantHover;
    readsOverlay._variantLeaveHandler = handleVariantLeave;
    readsOverlay.addEventListener("mouseenter", handleVariantHover, true);
    readsOverlay.addEventListener("mouseleave", handleVariantLeave, true);
  }

  // Selective rendering for hover-only state changes (no SVG rebuild)
  function renderHoverOnly() {
    // Only redraw canvas elements affected by hover state
    // Skip expensive SVG rebuilds and layout recalculations
    updateLocusTrackHover(); // Update Locus track SVG hover styles
    renderFlowCanvas();
    renderReadsCanvas();
    updateTooltip();
  }

  function renderAll() {
    updateDerived();
    updateTracksHeight();
    renderTracks();
    renderTrackControls();
    updateFlowAndReadsPosition();
    renderFlowCanvas();
    renderReadsCanvas();
    // Render all Smart tracks
    state.smartTracks.forEach(track => {
      renderSmartTrack(track.id);
    });
    renderHUD();
    updateTooltip();
    setupCanvasHover();
    setupVariantHoverAreas(); // Set up ID-based hover areas
    updateDocumentTitle();
  }

  // Hit testing for WebGPU-rendered repeats (only add listeners once)
  if (tracksWebGPU && !tracksWebGPU._tooltipListenersAdded) {
    tracksWebGPU._tooltipListenersAdded = true;
    const tracksWebGPUHoverHandler = (e) => {
      if (!webgpuSupported || repeatHitTestData.length === 0) return;
      
      const rect = tracksWebGPU.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const isVertical = isVerticalMode();
      
      // Get RepeatMasker track layout to restrict hit testing to track bounds
      const layout = getTrackLayout();
      const repeatsLayout = layout.find(l => l.track.id === "repeats");
      if (!repeatsLayout || repeatsLayout.track.collapsed) return;
      
      let repeatsY, repeatsH;
      if (isVertical) {
        repeatsY = 16;
        repeatsH = tracksWidthPx() - 32; // W - 32 in vertical mode
      } else {
        repeatsY = repeatsLayout.contentTop + 8;
        repeatsH = 22;
      }
      
      // Only do hit testing if mouse is within RepeatMasker track bounds
      if (isVertical) {
        // In vertical mode, check X coordinate (genomic axis is vertical)
        const repeatsX = repeatsLayout.contentLeft + 8;
        const repeatsW = 22;
        if (x < repeatsX || x > repeatsX + repeatsW) {
          state.hoveredRepeatTooltip = null;
          updateTooltip();
          return;
        }
      } else {
        // In horizontal mode, check Y coordinate
        if (y < repeatsY || y > repeatsY + repeatsH) {
          state.hoveredRepeatTooltip = null;
          updateTooltip();
          return;
        }
      }
      
      // Convert mouse coordinates to genome position
      let bp;
      if (isVertical) {
        const H = tracksHeightPx();
        bp = bpFromYGenome(y, H);
      } else {
        const W = tracksWidthPx();
        bp = bpFromXGenome(x, W);
      }
      
      // Find overlapping repeat (check against original coordinates)
      const hitRepeat = repeatHitTestData.find(r => 
        bp >= r.start && bp <= r.end
      );
      
      if (hitRepeat) {
        state.hoveredRepeatTooltip = {
          text: `${hitRepeat.cls} repeat\n${Math.floor(hitRepeat.start).toLocaleString()} - ${Math.floor(hitRepeat.end).toLocaleString()}`,
          x: e.clientX + 10,
          y: e.clientY + 10
        };
      } else {
        state.hoveredRepeatTooltip = null;
      }
      updateTooltip();
    };
    
    // Throttle mousemove handler to 16ms (60fps)
    const throttledTracksWebGPUHoverHandler = throttle(tracksWebGPUHoverHandler, 16);
    tracksWebGPU.addEventListener('mousemove', throttledTracksWebGPUHoverHandler);
    
    tracksWebGPU.addEventListener('mouseleave', () => {
      state.hoveredRepeatTooltip = null;
      updateTooltip();
    });
  }

  // Setup hover detection for canvas elements
  let flowHoverHandler = null;
  let flowLeaveHandler = null;
  let readsHoverHandler = null;
  let readsLeaveHandler = null;

  function setupCanvasHover() {
    // Remove existing listeners to avoid duplicates
    if (flowHoverHandler) {
      flow.removeEventListener("mousemove", flowHoverHandler);
      flow.removeEventListener("mouseleave", flowLeaveHandler);
    }
    // Note: readsHoverHandler is now handled by overlay-based ID detection
    // Keeping this for potential fallback, but overlay approach should be primary
    if (readsHoverHandler) {
      reads.removeEventListener("mousemove", readsHoverHandler);
      reads.removeEventListener("mouseleave", readsLeaveHandler);
      readsHoverHandler = null; // Disable old coordinate-based handler
      readsLeaveHandler = null;
    }

    // Flow canvas hover detection
    flowHoverHandler = (e) => {
      const rect = flow.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const isVertical = isVerticalMode();
      const variantMode = getVariantLayoutMode();
      const win = visibleVariantWindow();
      
      if (isVertical) {
        const junctionX = 40;
        const H = flowHeightPx();
        const sortedWin = [...win].sort((a, b) => a.pos - b.pos);
        
        // Check if mouse is over a variant label
        if (window._variantLabelPositions && window._variantLabelPositions.length > 0) {
          for (const labelPos of window._variantLabelPositions) {
            // In vertical mode, labels are rotated 90 degrees at x=14
            // Check if mouse is near the label position (y coordinate) and in the label area (x < 30)
            const labelY = labelPos.y;
            const labelHeight = labelPos.height; // This is the font size (12px)
            if (Math.abs(y - labelY) < labelHeight && x >= 0 && x <= 30) {
              // Show tooltip with all IDs (comma-delimited)
              if (labelPos.allIds && labelPos.allIds.length > 0) {
                state.hoveredVariantLabelTooltip = {
                  text: labelPos.allIds.join(', '),
                  x: e.clientX + 10,
                  y: e.clientY + 10
                };
                updateTooltip();
              } else {
                state.hoveredVariantLabelTooltip = null;
                updateTooltip();
              }
              return;
            }
          }
        }
        
        // Check if mouse is near a column line (horizontal in vertical mode)
        for (let i = 0; i < sortedWin.length; i++) {
          const v = sortedWin[i];
          // Position based on variant layout mode
          const cy = variantMode === "genomic"
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          
          if (Math.abs(y - cy) < 10 && x >= junctionX) {
            if (state.hoveredVariantIndex !== variantIdx) {
              state.hoveredVariantIndex = variantIdx;
              renderHoverOnly();
            }
            // Clear variant label tooltip when hovering column
            state.hoveredVariantLabelTooltip = null;
            updateTooltip();
            return;
          }
        }
        
        // Check if mouse is near a diagonal connector
        const x0 = 6;
        for (let i = 0; i < sortedWin.length; i++) {
          const v = sortedWin[i];
          if (v.pos < state.startBp || v.pos > state.endBp) continue;
          const vy = yGenomeCanonical(v.pos, H); // always genomic for ruler connection
          const cy = variantMode === "genomic"
            ? yGenomeCanonical(v.pos, H)
            : yColumn(i, sortedWin.length);
          const variantIdx = variants.findIndex(v2 => v2.id === v.id);
          
          const dist = Math.abs((x - x0) * (cy - vy) / (junctionX - x0) + vy - y);
          if (dist < 5 && x >= x0 && x <= junctionX) {
            if (state.hoveredVariantIndex !== variantIdx) {
              state.hoveredVariantIndex = variantIdx;
              renderHoverOnly();
            }
            // Clear variant label tooltip when hovering connector
            state.hoveredVariantLabelTooltip = null;
            updateTooltip();
            return;
          }
        }
      } else {
        const junctionY = 40;
        const W = flowWidthPx();
        
        // Check if mouse is over a variant label
        if (window._variantLabelPositions && window._variantLabelPositions.length > 0) {
          for (const labelPos of window._variantLabelPositions) {
            // In horizontal mode, labels are at the top (y=14)
            if (x >= labelPos.x && x <= labelPos.x + labelPos.width &&
                y >= labelPos.y && y <= labelPos.y + labelPos.height) {
              // Show tooltip with all IDs (comma-delimited)
              if (labelPos.allIds && labelPos.allIds.length > 0) {
                state.hoveredVariantLabelTooltip = {
                  text: labelPos.allIds.join(', '),
                  x: e.clientX + 10,
                  y: e.clientY + 10
                };
                updateTooltip();
              } else {
                state.hoveredVariantLabelTooltip = null;
                updateTooltip();
              }
              return;
            }
          }
        }
        
        // Check if mouse is near a column line
        for (let i = 0; i < win.length; i++) {
          // Position based on variant layout mode
          const cx = variantMode === "genomic"
            ? xGenomeCanonical(win[i].pos, W)
            : xColumn(i, win.length);
          const variantIdx = state.firstVariantIndex + i;
          
          if (Math.abs(x - cx) < 10 && y >= junctionY) {
            if (state.hoveredVariantIndex !== variantIdx) {
              state.hoveredVariantIndex = variantIdx;
              renderHoverOnly();
            }
            // Clear variant label tooltip when hovering column
            state.hoveredVariantLabelTooltip = null;
            updateTooltip();
            return;
          }
        }
        
        // Check if mouse is near a diagonal connector
        const y0 = 6;
        for (let i = 0; i < win.length; i++) {
          const v = win[i];
          if (v.pos < state.startBp || v.pos > state.endBp) continue;
          const vx = xGenomeCanonical(v.pos, W); // always genomic for ruler connection
          const cx = variantMode === "genomic"
            ? xGenomeCanonical(v.pos, W)
            : xColumn(i, win.length);
          const variantIdx = state.firstVariantIndex + i;
          
          const dist = Math.abs((y - y0) * (cx - vx) / (junctionY - y0) + vx - x);
          if (dist < 5 && y >= y0 && y <= junctionY) {
            if (state.hoveredVariantIndex !== variantIdx) {
              state.hoveredVariantIndex = variantIdx;
              renderHoverOnly();
            }
            return;
          }
        }
      }
      
      // No variant hovered
      if (state.hoveredVariantIndex !== null) {
        state.hoveredVariantIndex = null;
        renderHoverOnly();
      }
      // Clear variant label tooltip when not hovering anything
      if (state.hoveredVariantLabelTooltip !== null) {
        state.hoveredVariantLabelTooltip = null;
        updateTooltip();
      }
    };
    
    flowLeaveHandler = () => {
      if (state.hoveredVariantIndex !== null || state.hoveredAlleleNode !== null) {
        state.hoveredVariantIndex = null;
        state.hoveredAlleleNode = null;
        renderHoverOnly();
      }
      // Clear variant label tooltip when leaving flow canvas
      if (state.hoveredVariantLabelTooltip !== null) {
        state.hoveredVariantLabelTooltip = null;
        updateTooltip();
      }
    };
    
    flow.addEventListener("mousemove", flowHoverHandler);
    flow.addEventListener("mouseleave", flowLeaveHandler);
    
    // Variant label click-to-pin handler
    let variantLabelClickHandler = null;
    function setupVariantLabelClick() {
      if (variantLabelClickHandler) {
        flow.removeEventListener("click", variantLabelClickHandler);
        if (flowWebGPU) flowWebGPU.removeEventListener("click", variantLabelClickHandler);
      }
      
      variantLabelClickHandler = (e) => {
        // Only handle clicks if not dragging alleles
        if (state.alleleDragState) return;
        
        const rect = flow.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Check if we clicked on a variant label
        if (!window._variantLabelPositions || window._variantLabelPositions.length === 0) return;
        
        const isVertical = isVerticalMode();
        
        for (const labelPos of window._variantLabelPositions) {
          let clicked = false;
          if (isVertical) {
            // In vertical mode, labels are rotated 90 degrees at x=14
            // Check if click is near the label position (y coordinate) and in the label area (x < 30)
            const labelY = labelPos.y;
            const labelHeight = labelPos.height; // This is the font size (12px)
            if (Math.abs(y - labelY) < labelHeight && x >= 0 && x <= 30) {
              clicked = true;
            }
          } else {
            // In horizontal mode, labels are at the top (y=14)
            if (x >= labelPos.x && x <= labelPos.x + labelPos.width &&
                y >= labelPos.y && y <= labelPos.y + labelPos.height) {
              clicked = true;
            }
          }
          
          if (clicked) {
            // Toggle pinned state
            if (state.pinnedVariantLabels.has(labelPos.variantId)) {
              state.pinnedVariantLabels.delete(labelPos.variantId);
            } else {
              state.pinnedVariantLabels.add(labelPos.variantId);
            }
            renderFlowCanvas();
            e.stopPropagation();
            return;
          }
        }
      };
      
      flow.addEventListener("click", variantLabelClickHandler);
      if (flowWebGPU) flowWebGPU.addEventListener("click", variantLabelClickHandler);
    }
    
    setupVariantLabelClick();
    
    // Allele node drag-and-drop handlers
    let alleleMouseDownHandler = null;
    let alleleMouseMoveHandler = null;
    let alleleMouseUpHandler = null;
    
    function setupAlleleDragDrop() {
      // Remove existing listeners
      if (alleleMouseDownHandler) {
        const oldTarget = flowWebGPU || flow;
        oldTarget.removeEventListener("mousedown", alleleMouseDownHandler);
        document.removeEventListener("mousemove", alleleMouseMoveHandler);
        document.removeEventListener("mouseup", alleleMouseUpHandler);
      }
      
      alleleMouseDownHandler = (e) => {
        if (!window._alleleNodePositions || window._alleleNodePositions.length === 0) return;
        
        // Use flow container for coordinates (same coordinate system as flowCanvas)
        const rect = flow.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Find which node was clicked
        for (const node of window._alleleNodePositions) {
          if (x >= node.x && x <= node.x + node.w && 
              y >= node.y && y <= node.y + node.h) {
            e.preventDefault();
            e.stopPropagation();
            state.alleleDragState = {
              variantId: node.variantId,
              alleleIndex: node.alleleIndex,
              label: node.label,
              startX: x,
              startY: y,
              offsetX: 0,
              offsetY: 0,
              isClick: true // Track if this might be a click (not a drag)
            };
            flowCanvas.style.cursor = "grabbing";
            if (flowWebGPU) flowWebGPU.style.cursor = "grabbing";
            return;
          }
        }
      };
      
      alleleMouseMoveHandler = (e) => {
        const rect = flow.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (state.alleleDragState) {
          // Handle drag
          state.alleleDragState.offsetX = x - state.alleleDragState.startX;
          state.alleleDragState.offsetY = y - state.alleleDragState.startY;
          
          // If moved more than 5 pixels, it's a drag, not a click
          const dragDistance = Math.sqrt(
            Math.pow(state.alleleDragState.offsetX, 2) + 
            Math.pow(state.alleleDragState.offsetY, 2)
          );
          if (dragDistance > 5) {
            state.alleleDragState.isClick = false;
          }
        
        // Calculate drop position to show indicator
        const dragState = state.alleleDragState;
        const order = state.variantAlleleOrder.get(dragState.variantId);
        if (order) {
          const isVertical = isVerticalMode();
          const variantMode = getVariantLayoutMode();
          const win = visibleVariantWindow();
          const constants = window._alleleNodeConstants || { baseNodeW: 4, baseNodeH: 14, gap: 8, MIN_NODE_SIZE: 4 };
          const gap = constants.gap;
          const MIN_NODE_SIZE = constants.MIN_NODE_SIZE;
          const baseNodeW = constants.baseNodeW;
          const baseNodeH = constants.baseNodeH;
          
          // Find the variant to get its allele frequencies
          const v = isVertical 
            ? [...win].sort((a, b) => a.pos - b.pos).find(v => v.id === dragState.variantId)
            : win.find(v => v.id === dragState.variantId);
          
          // Declare newIndex in this scope so it's accessible after the if (v) block
          let newIndex = -1;
          
          if (v) {
            // Get track dimension for size calculation
            const layout = getTrackLayout();
            const flowLayout = layout.find(l => l.track.id === "flow");
            const trackDimension = isVertical 
              ? (flowLayout ? flowLayout.contentWidth : 300)
              : (flowLayout ? flowLayout.contentHeight : 300);
            
            // Calculate allele sizes for this variant
            const calculateAlleleSizesFn = window.calculateAlleleSizes;
            const alleleSizes = calculateAlleleSizesFn 
              ? calculateAlleleSizesFn(v, trackDimension, MIN_NODE_SIZE, gap, order.length)
              : {}; // Fallback to empty if function not available
            
            // Map labels to allele keys
            const formatAlleleLabelFn = window.formatAlleleLabel || function(allele) {
              if (!allele || allele === ".") return ". (no-call)";
              const length = allele.length;
              const lengthLabel = length === 1 ? "1 bp" : `${length} bp`;
              return `${allele} (${lengthLabel})`;
            };
            const noCallLabel = formatAlleleLabelFn(".");
            const refLabel = v.refAllele ? formatAlleleLabelFn(v.refAllele) : null;
            function getAlleleKey(label) {
              if (label === noCallLabel) return ".";
              if (label === refLabel) return "ref";
              if (v.altAlleles && Array.isArray(v.altAlleles)) {
                const altIndex = v.altAlleles.findIndex(alt => formatAlleleLabelFn(alt) === label);
                if (altIndex >= 0) return `a${altIndex + 1}`;
              }
              return ".";
            }
            
            // Calculate margin (same as in calculateAlleleSizes)
            const marginPercent = 0.1;
            const minMargin = 10;
            const margin = Math.max(minMargin, trackDimension * marginPercent);
            if (isVertical) {
              const left = 70;
              const W = flowWidthPx();
              const cy = variantMode === "genomic"
                ? yGenomeCanonical(v.pos, flowHeightPx())
                : yColumn(isVertical ? [...win].sort((a, b) => a.pos - b.pos).findIndex(v2 => v2.id === v.id) : win.findIndex(v2 => v2.id === v.id), isVertical ? [...win].sort((a, b) => a.pos - b.pos).length : win.length);
              
              // Calculate total width and horizontal offset for centering
              let totalNodesWidth = 0;
              for (let j = 0; j < order.length; j++) {
                const label = order[j];
                const alleleKey = getAlleleKey(label);
                const nodeW = alleleSizes[alleleKey] || baseNodeW;
                totalNodesWidth += nodeW;
                if (j < order.length - 1) {
                  totalNodesWidth += gap;
                }
              }
              const availableWidth = W - left - margin;
              const horizontalOffset = Math.max(0, (availableWidth - totalNodesWidth) / 2);
              
              // Calculate cumulative positions for variable-width nodes, starting with left + horizontal offset
              let currentX = left + horizontalOffset;
              for (let j = 0; j < order.length; j++) {
                const label = order[j];
                const alleleKey = getAlleleKey(label);
                const nodeW = alleleSizes[alleleKey] || baseNodeW;
                const nodeCenterX = currentX + nodeW / 2;
                
                if (Math.abs(x - nodeCenterX) < (nodeW + gap) / 2 && 
                    Math.abs(y - cy) < baseNodeH / 2) {
                  newIndex = j;
                  break;
                }
                currentX += nodeW + gap;
              }
              
              // If no match found, check if mouse is beyond the last node
              if (newIndex === -1 && Math.abs(y - cy) < baseNodeH / 2) {
                let lastX = left + horizontalOffset;
                for (let j = 0; j < order.length; j++) {
                  const label = order[j];
                  const alleleKey = getAlleleKey(label);
                  const nodeW = alleleSizes[alleleKey] || baseNodeW;
                  lastX += nodeW + (j < order.length - 1 ? gap : 0);
                }
                if (x > lastX - (baseNodeW + gap) / 2 && x < lastX + baseNodeW + gap) {
                  newIndex = order.length - 1;
                }
              }
            } else {
              const cx = variantMode === "genomic"
                ? xGenomeCanonical(v.pos, flowWidthPx())
                : xColumn(win.findIndex(v2 => v2.id === v.id), win.length);
              const top = 20;
              const H = flowHeightPx();
              
              // Calculate total height and vertical offset for centering
              let totalNodesHeight = 0;
              for (let j = 0; j < order.length; j++) {
                const label = order[j];
                const alleleKey = getAlleleKey(label);
                const nodeH = alleleSizes[alleleKey] || baseNodeH;
                totalNodesHeight += nodeH;
                if (j < order.length - 1) {
                  totalNodesHeight += gap;
                }
              }
              const availableHeight = H - top - margin;
              const verticalOffset = Math.max(0, (availableHeight - totalNodesHeight) / 2);
              
              // Calculate cumulative positions for variable-height nodes, starting with top + vertical offset
              let currentY = top + verticalOffset;
              for (let j = 0; j < order.length; j++) {
                const label = order[j];
                const alleleKey = getAlleleKey(label);
                const nodeH = alleleSizes[alleleKey] || baseNodeH;
                const nodeCenterY = currentY + nodeH / 2;
                
                if (Math.abs(x - cx) < baseNodeW / 2 && 
                    Math.abs(y - nodeCenterY) < (nodeH + gap) / 2) {
                  newIndex = j;
                  break;
                }
                currentY += nodeH + gap;
              }
              
              // If no match found, check if mouse is below the last node
              if (newIndex === -1 && Math.abs(x - cx) < baseNodeW / 2) {
                let lastY = top + verticalOffset;
                for (let j = 0; j < order.length; j++) {
                  const label = order[j];
                  const alleleKey = getAlleleKey(label);
                  const nodeH = alleleSizes[alleleKey] || baseNodeH;
                  lastY += nodeH + (j < order.length - 1 ? gap : 0);
                }
                if (y > lastY - (baseNodeH + gap) / 2 && y < lastY + baseNodeH + gap) {
                  newIndex = order.length - 1;
                }
              }
            }
          }
          
          // Store drop index for rendering indicator
          state.alleleDragState.dropIndex = newIndex >= 0 ? newIndex : null;
        } else {
          state.alleleDragState.dropIndex = null;
        }
        
        renderFlowCanvas();
        } else {
          // Handle hover detection when not dragging
          if (!window._alleleNodePositions || window._alleleNodePositions.length === 0) {
            if (state.hoveredAlleleNode) {
              state.hoveredAlleleNode = null;
              renderFlowCanvas();
            }
            return;
          }
          
          // Find which node is hovered
          let hoveredNode = null;
          for (const node of window._alleleNodePositions) {
            if (x >= node.x && x <= node.x + node.w && 
                y >= node.y && y <= node.y + node.h) {
              hoveredNode = { variantId: node.variantId, alleleIndex: node.alleleIndex };
              break;
            }
          }
          
          // Update hover state if changed
          const currentHover = state.hoveredAlleleNode;
          if ((hoveredNode && (!currentHover || currentHover.variantId !== hoveredNode.variantId || currentHover.alleleIndex !== hoveredNode.alleleIndex)) ||
              (!hoveredNode && currentHover)) {
            state.hoveredAlleleNode = hoveredNode;
            renderFlowCanvas();
          }
        }
      };
      
      alleleMouseUpHandler = (e) => {
        if (!state.alleleDragState) return;
        
        const rect = flow.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const dragState = state.alleleDragState;
        
        // Check if this was a click (not a drag)
        if (dragState.isClick) {
          const labelKey = `${dragState.variantId}:${dragState.alleleIndex}`;
          
          // Handle selection with Ctrl/Cmd for multi-select
          if (e.ctrlKey || e.metaKey) {
            // Multi-select: toggle this allele in selection
            if (state.selectedAlleles.has(labelKey)) {
              state.selectedAlleles.delete(labelKey);
            } else {
              state.selectedAlleles.add(labelKey);
            }
          } else {
            // Single-select: replace selection with this allele
            // If clicking on already-selected single allele, deselect it
            if (state.selectedAlleles.size === 1 && state.selectedAlleles.has(labelKey)) {
              state.selectedAlleles.clear();
            } else {
              state.selectedAlleles.clear();
              state.selectedAlleles.add(labelKey);
            }
          }
          
          state.alleleDragState = null;
          flowCanvas.style.cursor = "";
          if (flowWebGPU) flowWebGPU.style.cursor = "";
          renderFlowCanvas();
          if (window.updateSelectionDisplay) window.updateSelectionDisplay();
          return;
        }
        
        // Otherwise, handle as a drag/drop
        const order = state.variantAlleleOrder.get(dragState.variantId);
        if (!order) {
          state.alleleDragState = null;
          flowCanvas.style.cursor = "";
          if (flowWebGPU) flowWebGPU.style.cursor = "";
          renderFlowCanvas();
          return;
        }
        
        const isVertical = isVerticalMode();
        const variantMode = getVariantLayoutMode();
        const win = visibleVariantWindow();
        const constants = window._alleleNodeConstants || { baseNodeW: 4, baseNodeH: 14, gap: 8, MIN_NODE_SIZE: 4 };
        const nodeW = constants.baseNodeW;
        const nodeH = constants.baseNodeH;
        const gap = constants.gap;
        
        let newIndex = -1;
        if (isVertical) {
          const sortedWin = [...win].sort((a, b) => a.pos - b.pos);
          const v = sortedWin.find(v => v.id === dragState.variantId);
          if (!v) {
            state.alleleDragState = null;
            flowCanvas.style.cursor = "";
            if (flowWebGPU) flowWebGPU.style.cursor = "";
            renderFlowCanvas();
            return;
          }
          const left = 70;
          const cy = variantMode === "genomic"
            ? yGenomeCanonical(v.pos, flowHeightPx())
            : yColumn(sortedWin.findIndex(v2 => v2.id === v.id), sortedWin.length);
          
          // Check if dropped near a node position
          for (let j = 0; j < order.length; j++) {
            const nodeX = left + j * (nodeW + gap);
            if (Math.abs(x - nodeX) < (nodeW + gap) / 2 && 
                Math.abs(y - cy) < nodeH / 2) {
              newIndex = j;
              break;
            }
          }
          
          // If no match found, check if mouse is beyond the last node (for dropping at last position)
          if (newIndex === -1 && Math.abs(y - cy) < nodeH / 2) {
            const lastNodeX = left + (order.length - 1) * (nodeW + gap);
            // Check if mouse is to the right of the last node (within reasonable distance)
            if (x > lastNodeX - (nodeW + gap) / 2 && x < lastNodeX + nodeW + gap + (nodeW + gap) / 2) {
              newIndex = order.length - 1;
            }
          }
        } else {
          const v = win.find(v => v.id === dragState.variantId);
          if (!v) {
            state.alleleDragState = null;
            flowCanvas.style.cursor = "";
            if (flowWebGPU) flowWebGPU.style.cursor = "";
            renderFlowCanvas();
            return;
          }
          const cx = variantMode === "genomic"
            ? xGenomeCanonical(v.pos, flowWidthPx())
            : xColumn(win.findIndex(v2 => v2.id === v.id), win.length);
          const top = 20;
          
          // Check if dropped near a node position
          for (let j = 0; j < order.length; j++) {
            const nodeY = top + j * (nodeH + gap);
            if (Math.abs(x - cx) < nodeW / 2 && 
                Math.abs(y - nodeY) < (nodeH + gap) / 2) {
              newIndex = j;
              break;
            }
          }
          
          // If no match found, check if mouse is below the last node (for dropping at last position)
          if (newIndex === -1 && Math.abs(x - cx) < nodeW / 2) {
            const lastNodeY = top + (order.length - 1) * (nodeH + gap);
            // Check if mouse is below the last node (within reasonable distance)
            if (y > lastNodeY - (nodeH + gap) / 2 && y < lastNodeY + nodeH + gap + (nodeH + gap) / 2) {
              newIndex = order.length - 1;
            }
          }
        }
        
        // Reorder if dropped at a valid position
        if (newIndex >= 0 && newIndex !== order.indexOf(dragState.label)) {
          const currentIndex = order.indexOf(dragState.label);
          order.splice(currentIndex, 1);
          order.splice(newIndex, 0, dragState.label);
          state.variantAlleleOrder.set(dragState.variantId, order);
        }
        
        state.alleleDragState = null;
        flowCanvas.style.cursor = "";
        if (flowWebGPU) flowWebGPU.style.cursor = "";
        renderFlowCanvas();
      };
      
      // Attach to flowWebGPU canvas (which is on top) or flow container
      // Both flowCanvas and flowWebGPU are inside flow, so coordinates are relative to flow
      const targetElement = flowWebGPU || flow;
      targetElement.addEventListener("mousedown", alleleMouseDownHandler, { passive: false });
      document.addEventListener("mousemove", alleleMouseMoveHandler);
      document.addEventListener("mouseup", alleleMouseUpHandler);
    }
    
    setupAlleleDragDrop();
    
    // -----------------------------
    // Sample Selection Strategy UI
    // -----------------------------
    
    // Get information about selected alleles for loading reads
    function getSelectedAlleleInfo() {
      const selectedInfo = [];
      for (const key of state.selectedAlleles) {
        const [variantId, alleleIndexStr] = key.split(':');
        const alleleIndex = parseInt(alleleIndexStr, 10);
        
        // Find the variant
        const variant = variants.find(v => v.id === variantId);
        if (!variant) continue;
        
        // Find the node position info to get the label
        const nodeInfo = window._alleleNodePositions?.find(n => 
          n.variantId === variantId && n.alleleIndex === alleleIndex
        );
        
        selectedInfo.push({
          variantId,
          alleleIndex,
          label: nodeInfo?.label || `Allele ${alleleIndex}`,
          variant
        });
      }
      return selectedInfo;
    }
    
    // Update context indicator (shows what's selected)
    function updateSampleContext() {
      const currentRoot = getCurrentRoot();
      const contextEl = byId(currentRoot, 'sampleContext');
      
      if (!contextEl) return;
      
      if (state.selectedAlleles.size === 0) {
        contextEl.style.display = 'none';
        return;
      }
      
      // Count selected alleles
      const alleleCount = state.selectedAlleles.size;
      
      // Show allele count directly in the context div
      contextEl.textContent = `${alleleCount} ${alleleCount === 1 ? 'allele' : 'alleles'} selected`;
      contextEl.style.display = 'block';
    }
    
    // Update strategy section state (enable/disable controls)
    function updateSampleStrategySection() {
      const hasSelection = state.selectedAlleles.size > 0;
      const currentRoot = getCurrentRoot();
      const strategySectionEl = byId(currentRoot, 'sampleStrategySection');
      const strategyEl = byId(currentRoot, 'sampleStrategy');
      const sliderEl = byId(currentRoot, 'sampleCountSlider');
      const inputEl = byId(currentRoot, 'sampleCountInput');
      const replaceBtn = byId(currentRoot, 'loadSamplesReplace');
      const addBtn = byId(currentRoot, 'loadSamplesAdd');
      
      // Show/hide entire strategy section based on selection
      if (strategySectionEl) {
        strategySectionEl.style.display = hasSelection ? 'block' : 'none';
      }
      
      // Enable/disable controls based on selection
      const disabled = !hasSelection;
      if (strategyEl) strategyEl.disabled = disabled;
      if (sliderEl) sliderEl.disabled = disabled;
      if (inputEl) inputEl.disabled = disabled;
      if (replaceBtn) replaceBtn.disabled = disabled;
      if (addBtn) addBtn.disabled = disabled;
      
      // Update "Compare branches" option enablement
      if (strategyEl) {
        const compareOption = strategyEl.querySelector('option[value="compare_branches"]');
        if (compareOption) {
          // Enable only when 2+ branches selected
          compareOption.disabled = state.selectedAlleles.size < 2;
        }
      }
      
      // Update preview
      updateSamplePreview();
    }
    
    // Update sample preview
    function updateSamplePreview() {
      const currentRoot = getCurrentRoot();
      const previewEl = byId(currentRoot, 'samplePreview');
      const previewListEl = byId(currentRoot, 'samplePreviewList');
      const candidates = state.sampleSelection.candidateSamples;
      
      if (!previewEl || !previewListEl) return;
      
      if (candidates.length === 0) {
        previewEl.style.display = 'none';
        return;
      }
      
      // Show first 5 samples + count of remaining
      const displayCount = Math.min(5, candidates.length);
      const remaining = candidates.length - displayCount;
      
      let text = candidates.slice(0, displayCount).join(', ');
      if (remaining > 0) {
        text += `, +${remaining} more`;
      }
      
      previewListEl.textContent = text;
      previewEl.style.display = 'block';
    }
    
    // Recompute candidate samples based on strategy and selection
    function recomputeCandidateSamples() {
      // TODO: Implement actual sample selection logic
      // For now, just placeholder
      state.sampleSelection.candidateSamples = [];
      updateSamplePreview();
    }
    
    // Strategy change handler
    function onStrategyChange() {
      const currentRoot = getCurrentRoot();
      const strategyEl = byId(currentRoot, 'sampleStrategy');
      if (strategyEl) {
        state.sampleSelection.strategy = strategyEl.value;
      }
      recomputeCandidateSamples();
    }
    
    // Setup sample search with autocomplete
    function setupSampleSearch() {
      const currentRoot = getCurrentRoot();
      const searchInput = byId(currentRoot, 'sampleSearchInput');
      const resultsEl = byId(currentRoot, 'sampleSearchResults');
      
      if (!searchInput || !resultsEl) return;
      
      let searchTimeout = null;
      
      searchInput.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim().toLowerCase();
        
        if (query.length === 0) {
          resultsEl.style.display = 'none';
          return;
        }
        
        searchTimeout = setTimeout(() => {
          // Filter sample IDs by prefix/substring match
          const matches = state.sampleSelection.allSampleIds
            .filter(id => id.toLowerCase().includes(query))
            .slice(0, 8); // Top 8 matches
          
          if (matches.length === 0) {
            resultsEl.style.display = 'none';
            return;
          }
          
          // Render results
          resultsEl.innerHTML = '';
          matches.forEach(sampleId => {
            const resultEl = document.createElement('div');
            resultEl.className = 'sampleSearchResult';
            resultEl.textContent = sampleId;
            resultEl.addEventListener('click', () => {
              // TODO: Load reads for this sample
              console.log('Load sample:', sampleId);
              searchInput.value = '';
              resultsEl.style.display = 'none';
            });
            resultsEl.appendChild(resultEl);
          });
          
          resultsEl.style.display = 'block';
        }, 150); // Debounce search
      });
      
      // Hide results when clicking outside
      document.addEventListener('click', (e) => {
        if (!searchInput.contains(e.target) && !resultsEl.contains(e.target)) {
          resultsEl.style.display = 'none';
        }
      });
      
      // Handle Enter key
      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const firstResult = resultsEl.querySelector('.sampleSearchResult');
          if (firstResult) {
            firstResult.click();
          }
        }
      });
    }
    
    // Main update function for selection display
    function updateSelectionDisplay() {
      updateSampleContext();
      updateSampleStrategySection();
      recomputeCandidateSamples();
    }
    
    // Setup sample selection strategy controls
    const strategyEl = byId(root, 'sampleStrategy');
    const sliderEl = byId(root, 'sampleCountSlider');
    const sampleCountInputEl = byId(root, 'sampleCountInput');
    const combineAndBtn = byId(root, 'combineAnd');
    const combineOrBtn = byId(root, 'combineOr');
    const replaceBtn = byId(root, 'loadSamplesReplace');
    const addBtn = byId(root, 'loadSamplesAdd');
    
    // Strategy dropdown
    if (strategyEl) {
      strategyEl.addEventListener('change', onStrategyChange);
    }
    
    // Sample count sync between slider and input
    if (sliderEl) {
      sliderEl.addEventListener('input', (e) => {
        if (sampleCountInputEl) sampleCountInputEl.value = e.target.value;
        state.sampleSelection.numSamples = parseInt(e.target.value);
        recomputeCandidateSamples();
      });
    }
    
    if (sampleCountInputEl) {
      sampleCountInputEl.addEventListener('change', (e) => {
        const value = Math.max(1, Math.min(20, parseInt(e.target.value) || 1));
        if (sliderEl) sliderEl.value = value;
        sampleCountInputEl.value = value;
        state.sampleSelection.numSamples = value;
        recomputeCandidateSamples();
      });
    }
    
    // Combine mode toggle
    if (combineAndBtn) {
      combineAndBtn.addEventListener('click', () => {
        state.sampleSelection.combineMode = 'AND';
        combineAndBtn.classList.add('active');
        if (combineOrBtn) {
          combineOrBtn.classList.remove('active');
          combineOrBtn.style.color = 'var(--muted)';
        }
        combineAndBtn.style.color = 'white';
        updateSampleContext();
        recomputeCandidateSamples();
      });
    }
    
    if (combineOrBtn) {
      combineOrBtn.addEventListener('click', () => {
        state.sampleSelection.combineMode = 'OR';
        combineOrBtn.classList.add('active');
        if (combineAndBtn) {
          combineAndBtn.classList.remove('active');
          combineAndBtn.style.color = 'var(--muted)';
        }
        combineOrBtn.style.color = 'white';
        updateSampleContext();
        recomputeCandidateSamples();
      });
    }
    
    // Load buttons
    if (replaceBtn && !replaceBtn._listenerAttached) {
      replaceBtn._listenerAttached = true;
      replaceBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        // Use button's disabled state as the loading flag
        if (replaceBtn.disabled) {
          return; // Prevent multiple simultaneous loads
        }
        
        if (state.selectedAlleles.size === 0) {
          console.warn('No alleles selected');
          return;
        }
        
        replaceBtn.disabled = true;
        
        const strategy = state.sampleSelection.strategy;
        const candidates = state.sampleSelection.candidateSamples;
        const selectedAlleles = Array.from(state.selectedAlleles);
        const numSamples = state.sampleSelection.numSamples || 1;
        
        // Remove all existing Smart tracks
        const smartTrackIds = state.smartTracks.map(t => t.id);
        smartTrackIds.forEach(id => removeSmartTrack(id));
        
        // Create Smart tracks based on numSamples
        const trackPromises = [];
        for (let i = 0; i < numSamples; i++) {
          const track = createSmartTrack(strategy, selectedAlleles);
          
          // Get sample ID from candidates (cycle through if fewer candidates than requested)
          let sampleId = null;
          if (candidates && candidates.length > 0) {
            sampleId = candidates[i % candidates.length];
          }
          
          // Fetch reads
          trackPromises.push(
            fetchReadsForSmartTrack(track.id, strategy, track.selectedAlleles, sampleId)
              .catch(err => {
                console.error('Failed to load reads for Smart track:', err);
              })
          );
        }
        
        // Re-enable button after all tracks are created (reads may still be loading)
        Promise.all(trackPromises).finally(() => {
          replaceBtn.disabled = false;
        });
      });
    }
    
    if (addBtn && !addBtn._listenerAttached) {
      addBtn._listenerAttached = true;
      addBtn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        // Use button's disabled state as the loading flag
        if (addBtn.disabled) {
          return; // Prevent multiple simultaneous loads
        }
        
        if (state.selectedAlleles.size === 0) {
          console.warn('No alleles selected');
          return;
        }
        
        addBtn.disabled = true;
        
        const strategy = state.sampleSelection.strategy;
        const candidates = state.sampleSelection.candidateSamples;
        const selectedAlleles = Array.from(state.selectedAlleles);
        const numSamples = state.sampleSelection.numSamples || 1;
        
        // Create Smart tracks based on numSamples (add, don't replace)
        const trackPromises = [];
        for (let i = 0; i < numSamples; i++) {
          const track = createSmartTrack(strategy, selectedAlleles);
          
          // Get sample ID from candidates (cycle through if fewer candidates than requested)
          let sampleId = null;
          if (candidates && candidates.length > 0) {
            sampleId = candidates[i % candidates.length];
          }
          
          // Fetch reads
          trackPromises.push(
            fetchReadsForSmartTrack(track.id, strategy, track.selectedAlleles, sampleId)
              .catch(err => {
                console.error('Failed to load reads for Smart track:', err);
              })
          );
        }
        
        // Re-enable button after all tracks are created (reads may still be loading)
        Promise.all(trackPromises).finally(() => {
          addBtn.disabled = false;
        });
      });
    }
    
    // Setup search
    setupSampleSearch();
    
    // Initial update
    updateSelectionDisplay();
    
    // Export updateSelectionDisplay so it can be called after selection changes
    window.updateSelectionDisplay = updateSelectionDisplay;

    // Reads canvas hover detection
    readsHoverHandler = (e) => {
      const rect = reads.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const isVertical = isVerticalMode();
      
      // Convert mouse position to genomic position for more accurate matching
      // This is especially important when zoomed in, as pixel distances can be misleading
      let mouseBp;
      if (isVertical) {
        const H = readsHeightPx();
        mouseBp = bpFromYGenome(y, H);
      } else {
        const W = readsWidthPx();
        mouseBp = bpFromXGenome(x, W);
      }
      
      // Find the variant closest to the mouse position in genomic coordinates
      let closestIdx = null;
      let closestBpDist = Infinity;
      const span = state.endBp - state.startBp;
      // Use a genomic distance threshold: 0.5% of view span, but at least 1bp and at most 50bp
      const maxBpDist = Math.max(1, Math.min(50, span * 0.005));
      
      for (let idx = 0; idx < variants.length; idx++) {
        const v = variants[idx];
        if (v.pos < state.startBp || v.pos > state.endBp) continue;
        
        const bpDist = Math.abs(v.pos - mouseBp);
        if (bpDist < maxBpDist && bpDist < closestBpDist) {
          closestBpDist = bpDist;
          closestIdx = idx;
        }
      }
      
      // Update hover state if we found a variant
      if (closestIdx !== null) {
        if (state.hoveredVariantIndex !== closestIdx) {
          state.hoveredVariantIndex = closestIdx;
          renderHoverOnly();
        }
      } else {
        // No variant hovered
        if (state.hoveredVariantIndex !== null) {
          state.hoveredVariantIndex = null;
          renderHoverOnly();
        }
      }
    };
    
    readsLeaveHandler = () => {
      if (state.hoveredVariantIndex !== null) {
        state.hoveredVariantIndex = null;
        renderHoverOnly();
      }
    };
    
    // Throttle mousemove handler to 16ms (60fps)
    const throttledReadsHoverHandler = throttle(readsHoverHandler, 16);
    reads.addEventListener("mousemove", throttledReadsHoverHandler);
    reads.addEventListener("mouseleave", readsLeaveHandler);
    
    // Re-render on scroll to update visible reads
    reads.addEventListener("scroll", () => {
      renderReadsCanvas();
    });
    
    // Allow wheel events to scroll the reads container (don't let main handler prevent it)
    const readsWheelHandler = (e) => {
      // Only handle if reads container is scrollable
      if (reads.scrollHeight > reads.clientHeight) {
        // Allow native scrolling - don't prevent default
        // The scroll will happen naturally, and we'll re-render via scroll event
        return;
      }
    };
    reads.addEventListener("wheel", readsWheelHandler, { passive: true });
    if (readsCanvas) {
      readsCanvas.addEventListener("wheel", readsWheelHandler, { passive: true });
    }
    if (readsWebGPU) {
      readsWebGPU.addEventListener("wheel", readsWheelHandler, { passive: true });
    }
  }

  function updateFlowAndReadsPosition() {
    const layout = getTrackLayout();
    const isVertical = isVerticalMode();
    
    const flowLayout = layout.find(l => l.track.id === "flow");
    if (flowLayout) {
      if (isVertical) {
        flow.style.left = `${flowLayout.contentLeft}px`;
        flow.style.width = flowLayout.track.collapsed ? "0px" : `${flowLayout.contentWidth}px`;
        flow.style.top = "0";
        flow.style.height = "100%";
      } else {
        flow.style.top = `${flowLayout.contentTop}px`;
        flow.style.height = flowLayout.track.collapsed ? "0px" : `${flowLayout.contentHeight}px`;
        flow.style.left = "0";
        flow.style.width = "100%";
      }
      flow.style.display = flowLayout.track.collapsed ? "none" : "block";
    }
    
    const readsLayout = layout.find(l => l.track.id === "reads");
    if (readsLayout) {
      if (isVertical) {
        reads.style.left = `${readsLayout.contentLeft}px`;
        // Extend Reads track to the right edge of the main container
        const mainWidth = rectW(main);
        reads.style.width = readsLayout.track.collapsed ? "0px" : `${mainWidth - readsLayout.contentLeft}px`;
        // In vertical mode, tracks are side-by-side, so top should be 0 and height spans full container
        reads.style.top = "0";
        const mainHeight = rectH(main);
        reads.style.height = readsLayout.track.collapsed ? "0px" : `${mainHeight}px`;
      } else {
        reads.style.top = `${readsLayout.contentTop}px`;
        reads.style.left = "0";
        reads.style.width = "100%";
        // Height and overflow are managed by renderReadsCanvas when reads are loaded
        if (!loadedReadsLayout || !loadedReadsLayout.reads || loadedReadsLayout.reads.length === 0) {
          reads.style.height = readsLayout.track.collapsed ? "0px" : `${readsLayout.contentHeight}px`;
        }
      }
      reads.style.display = readsLayout.track.collapsed ? "none" : "block";
    }
    
    // Update Smart track container positions (actual rendering is done in renderSmartTrack)
    // This is just for initial positioning
    state.smartTracks.forEach(track => {
      const trackLayout = layout.find(l => l.track.id === track.id);
      if (trackLayout) {
        const renderer = state.smartTrackRenderers.get(track.id);
        if (renderer && renderer.container) {
          // Position is handled in renderSmartTrack, but we ensure container exists
        }
      }
    });
  }

  // -----------------------------
  // Pan + Zoom helpers
  // -----------------------------
  function clampSpan(span) {
    const MIN_SPAN = 50;
    const MAX_SPAN = 5_000_000;
    return Math.max(MIN_SPAN, Math.min(MAX_SPAN, span));
  }

  function zoomByFactor(factor, anchorBp) {
    const oldSpan = state.endBp - state.startBp;
    const newSpan = clampSpan(oldSpan / factor);

    const leftFrac = (anchorBp - state.startBp) / oldSpan;
    const newStart = anchorBp - leftFrac * newSpan;

    state.startBp = newStart;
    state.endBp = newStart + newSpan;

    // Clamp to chromosome boundaries
    clampToChromosomeBounds();

    renderAll();
  }

  function panByPixels(dxPx, dyPx) {
    const isVertical = isVerticalMode();
    const deltaPx = isVertical ? (dyPx !== undefined ? dyPx : 0) : (dxPx !== undefined ? dxPx : 0);
    const deltaBp = deltaPx / state.pxPerBp;
    // In vertical mode: down = lower locus (increase), up = higher locus (decrease)
    // In horizontal mode: right = higher locus (increase), left = lower locus (decrease)
    if (isVertical) {
      state.startBp += deltaBp;
      state.endBp   += deltaBp;
    } else {
      state.startBp -= deltaBp;
      state.endBp   -= deltaBp;
    }

    // Clamp to chromosome boundaries
    clampToChromosomeBounds();

    // Placeholder heuristic for shifting the variant window
    const win = visibleVariantWindow();
    if (win.length > 0) {
      const first = win[0].pos;
      while (state.firstVariantIndex > 0 && first > state.endBp) state.firstVariantIndex--;
      while (state.firstVariantIndex + 1 < variants.length &&
             first < state.startBp - (state.endBp-state.startBp)*0.25) {
        state.firstVariantIndex++;
        if (state.firstVariantIndex + state.K > variants.length) break;
      }
      state.firstVariantIndex = Math.max(0, Math.min(state.firstVariantIndex, Math.max(0, variants.length - state.K)));
    }

    renderAll();
  }

  function anchorBpFromClientX(clientX) {
    const rect = tracksSvg.getBoundingClientRect();
    const xInPane = clientX - rect.left;
    return bpFromXGenome(xInPane, tracksWidthPx());
  }
  function anchorBpFromClientY(clientY) {
    const rect = tracksSvg.getBoundingClientRect();
    const yInPane = clientY - rect.top;
    return bpFromYGenome(yInPane, tracksHeightPx());
  }
  function anchorBpFromClient(clientX, clientY) {
    const isVertical = isVerticalMode();
    if (isVertical) {
      return anchorBpFromClientY(clientY);
    } else {
      return anchorBpFromClientX(clientX);
    }
  }

  // -----------------------------
  // Interaction (right pane)
  // -----------------------------
  
  // Bind wheel, pointer, and dblclick events to main element
  // Returns a destroy function to clean up listeners
  function bindInteractions(root, state, main) {
    if (!main) {
      return { destroy() {} };
    }

    // Wheel: pan/zoom gestures
    // Use composedPath() as primary gate to ensure event is over viewport
    function shouldHandleWheel(e) {
      const path = e.composedPath ? e.composedPath() : [];
      return path.includes(main); // main is the viewport element that should pan/zoom
    }

    const onWheel = (e) => {
      // Extra safety: ignore wheel not originating inside this viewer
      const path = e.composedPath ? e.composedPath() : [];
      if (!path.includes(main)) return;

      // Allow scrolling in reads container - don't intercept wheel events there
      const readsEl = byId(root, "reads");
      if (readsEl) {
        // Check if event target is within reads container (including canvas children)
        const target = e.target;
        if (readsEl.contains(target) || path.includes(readsEl)) {
          // Check if reads container is scrollable and has overflow
          if (readsEl.scrollHeight > readsEl.clientHeight) {
            // Allow native scrolling - don't prevent default
            return;
          }
        }
      }

      const isPinchZoom = e.ctrlKey === true || e.metaKey === true;
      const isVertical = isVerticalMode();
      const dx = e.deltaX;
      const dy = e.deltaY;

      if (isPinchZoom) {
        // Handle pinch-to-zoom (trackpad gesture with ctrl/meta)
        e.preventDefault();
        e.stopPropagation(); // Prevent bubbling to window/document
        const zoomIntensity = 0.0018;
        // Use vertical delta for pinch zoom (standard trackpad convention)
        const factor = Math.exp(-dy * zoomIntensity);
        const anchorBp = isVertical 
          ? anchorBpFromClientY(e.clientY)
          : anchorBpFromClientX(e.clientX);
        zoomByFactor(factor, anchorBp);
        return;
      }
      
      if (isVertical) {
        // In vertical mode: vertical wheel = pan, horizontal wheel = zoom
        const wantPan = e.shiftKey || Math.abs(dy) > Math.abs(dx);
        
        if (wantPan) {
          e.preventDefault();
          e.stopPropagation(); // Prevent bubbling to window/document
          const panDy = e.shiftKey ? dx : dy;
          panByPixels(0, panDy);
          return;
        }

        e.preventDefault();
        e.stopPropagation(); // Prevent bubbling to window/document
        const zoomIntensity = 0.0018;
        const factor = Math.exp(-dx * zoomIntensity);

        const anchorBp = anchorBpFromClientY(e.clientY);
        zoomByFactor(factor, anchorBp);
      } else {
        // In horizontal mode: horizontal wheel = pan, vertical wheel = zoom
        const wantPan = e.shiftKey || Math.abs(dx) > Math.abs(dy);

        if (wantPan) {
          e.preventDefault();
          e.stopPropagation(); // Prevent bubbling to window/document
          const panDx = e.shiftKey ? dy : dx;
          panByPixels(panDx, 0);
          return;
        }

        e.preventDefault();
        e.stopPropagation(); // Prevent bubbling to window/document
        const zoomIntensity = 0.0018;
        const factor = Math.exp(-dy * zoomIntensity);

        const anchorBp = anchorBpFromClientX(e.clientX);
        zoomByFactor(factor, anchorBp);
      }
    };

    const onPointerDown = (e) => {
      // Don't start drag if clicking on a variant (for insertion expansion)
      // Check if clicking on SVG elements that are variants
      const target = e.target;
      if (target && target.tagName && (target.tagName === "line" || target.tagName === "circle" || target.tagName === "rect")) {
        // Check if this is a variant element (has blue stroke or is in the variant area)
        const stroke = target.getAttribute ? target.getAttribute("stroke") : null;
        if (stroke && (stroke === "var(--blue)" || stroke === cssVar("--blue") || stroke.includes("blue"))) {
          // This might be a variant - don't start dragging, let click handler work
          return;
        }
        // Also check if it's the invisible click area for insertions
        if (target.getAttribute && target.getAttribute("fill") === "transparent" && target.getAttribute("width") === "10") {
          return;
        }
      }
      
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      main.setPointerCapture(e.pointerId);

      if (state.pointers.size === 1) {
        state.dragging = true;
        state.lastX = e.clientX;
        state.lastY = e.clientY;
      } else {
        state.dragging = false;
      }
    };

    const onPointerMove = (e) => {
      if (!state.pointers.has(e.pointerId)) return;
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (state.pointers.size === 2) {
        const pts = Array.from(state.pointers.values());
        const dx = pts[0].x - pts[1].x;
        const dy = pts[0].y - pts[1].y;
        const dist = Math.hypot(dx, dy);

        if (state.pinchStartDist == null) {
          state.pinchStartDist = dist;
          state.pinchStartSpan = (state.endBp - state.startBp);

          const midX = (pts[0].x + pts[1].x) / 2;
          const midY = (pts[0].y + pts[1].y) / 2;
          state.pinchAnchorBp = anchorBpFromClient(midX, midY);
        } else {
          const scale = dist / state.pinchStartDist; // >1 apart => zoom in
          const oldSpan = state.pinchStartSpan;
          const newSpan = clampSpan(oldSpan / scale);

          const anchorBp = state.pinchAnchorBp ?? (state.startBp + (state.endBp-state.startBp)/2);
          const leftFrac = (anchorBp - state.startBp) / (state.endBp - state.startBp);
          const newStart = anchorBp - leftFrac * newSpan;

          state.startBp = newStart;
          state.endBp = newStart + newSpan;

          // Clamp to chromosome boundaries
          clampToChromosomeBounds();

          renderAll();
        }
        return;
      }

      if (state.dragging) {
        const isVertical = isVerticalMode();
        const dx = e.clientX - state.lastX;
        const dy = e.clientY - state.lastY;
        state.lastX = e.clientX;
        state.lastY = e.clientY;
        if (isVertical) {
          panByPixels(0, -dy);
        } else {
          panByPixels(-dx, 0);
        }
      }
    };

    function endPointer(e) {
      state.pointers.delete(e.pointerId);
      if (state.pointers.size < 2) {
        state.pinchStartDist = null;
        state.pinchStartSpan = null;
        state.pinchAnchorBp = null;
      }
      if (state.pointers.size === 0) state.dragging = false;
    }

    const onPointerUp = endPointer;
    const onPointerCancel = endPointer;

    const onDblClick = (e) => {
      const anchorBp = anchorBpFromClient(e.clientX, e.clientY);
      zoomByFactor(1.6, anchorBp);
    };

    // Attach event listeners
    main.addEventListener("wheel", onWheel, { passive: false });
    main.addEventListener("pointerdown", onPointerDown);
    main.addEventListener("pointermove", onPointerMove);
    main.addEventListener("pointerup", onPointerUp);
    main.addEventListener("pointercancel", onPointerCancel);
    main.addEventListener("dblclick", onDblClick);

    // Return destroy function
    return {
      destroy() {
        main.removeEventListener("wheel", onWheel, { passive: false });
        main.removeEventListener("pointerdown", onPointerDown);
        main.removeEventListener("pointermove", onPointerMove);
        main.removeEventListener("pointerup", onPointerUp);
        main.removeEventListener("pointercancel", onPointerCancel);
        main.removeEventListener("dblclick", onDblClick);
      }
    };
  }

  // Remove any wheel listeners on window/document that could cause global behavior
  // Note: getEventListeners is a DevTools-only function, so this only works when DevTools is open
  function removeGlobalWheelListeners() {
    if (typeof getEventListeners === 'function') {
      try {
        const windowWheel = getEventListeners(window).wheel;
        const docWheel = getEventListeners(document).wheel;
        if (windowWheel && windowWheel.length > 0) {
          windowWheel.forEach(listener => {
            try {
              window.removeEventListener("wheel", listener.listener, listener.useCapture);
            } catch (e) {
              console.warn("[gs] Failed to remove window wheel listener:", e);
            }
          });
        }
        if (docWheel && docWheel.length > 0) {
          docWheel.forEach(listener => {
            try {
              document.removeEventListener("wheel", listener.listener, listener.useCapture);
            } catch (e) {
              console.warn("[gs] Failed to remove document wheel listener:", e);
            }
          });
        }
      } catch (e) {
        console.warn("[gs] Error checking for global wheel listeners:", e);
      }
    }
  }
  
  // Remove global wheel listeners before binding our scoped ones
  removeGlobalWheelListeners();

  // Bind interactions and store destroy function
  interactionBinding = bindInteractions(root, state, main);

  // -----------------------------
  // Track interactions (drag, resize)
  // -----------------------------
  if (trackControls) {
  trackControls.addEventListener("pointerdown", (e) => {
    // Don't start drag if clicking on buttons or interactive elements
    if (e.target.closest(".track-collapse-btn") ||
        e.target.closest(".smart-track-close-btn") ||
        e.target.closest(".smart-track-reload-btn") ||
        e.target.closest(".smart-track-shuffle-btn") ||
        e.target.closest(".smart-track-strategy-select") ||
        e.target.closest(".smart-track-label-input") ||
        e.target.closest("button") ||
        e.target.closest("select") ||
        e.target.closest("input")) {
      e.stopPropagation();
      return;
    }
    
    const controls = e.target.closest(".track-controls");
    const resizeHandle = e.target.closest(".track-resize-handle");
    
    if (resizeHandle) {
      // Start resizing
      e.stopPropagation();
      const trackId = resizeHandle.dataset.trackId;
      const track = state.tracks.find(t => t.id === trackId);
      if (!track) return;
      
      e.preventDefault();
      const isVertical = isVerticalMode();
      state.trackResizeState = {
        trackId,
        startX: e.clientX,
        startY: e.clientY,
        startHeight: track.height
      };
      trackControls.setPointerCapture(e.pointerId);
    } else if (controls) {
      // Start dragging for reorder
      e.stopPropagation();
      const trackId = controls.dataset.trackId;
      e.preventDefault();
      const isVertical = isVerticalMode();
      state.trackDragState = {
        trackId,
        startX: e.clientX,
        startY: e.clientY,
        offsetX: 0,
        offsetY: 0
      };
      trackControls.setPointerCapture(e.pointerId);
    }
  });

  trackControls.addEventListener("pointermove", (e) => {
    if (state.trackResizeState) {
      // Resizing
      const track = state.tracks.find(t => t.id === state.trackResizeState.trackId);
      if (!track) return;
      
      e.preventDefault();
      const isVertical = isVerticalMode();
      let delta;
      if (isVertical) {
        // In vertical mode, resize based on horizontal movement
        delta = e.clientX - state.trackResizeState.startX;
      } else {
        // In horizontal mode, resize based on vertical movement
        delta = e.clientY - state.trackResizeState.startY;
      }
      const newHeight = Math.max(track.minHeight, state.trackResizeState.startHeight + delta);
      track.height = newHeight;
      updateTracksHeight();
      renderAll();
    } else if (state.trackDragState) {
      // Dragging for reorder
      e.preventDefault();
      const isVertical = isVerticalMode();
      const dx = e.clientX - state.trackDragState.startX;
      const dy = e.clientY - state.trackDragState.startY;
      
      if (isVertical) {
        state.trackDragState.offsetX = dx;
      } else {
        state.trackDragState.offsetY = dy;
      }
      
      // Visual feedback: move the dragged track
      const layout = getTrackLayout();
      const draggedItem = layout.find(l => l.track.id === state.trackDragState.trackId);
      if (draggedItem) {
        const container = trackControls.querySelector(`[data-track-id="${state.trackDragState.trackId}"]`);
        if (container) {
          if (isVertical) {
            container.style.transform = `translateX(${dx}px)`;
          } else {
            container.style.transform = `translateY(${dy}px)`;
          }
          container.style.zIndex = "100";
          container.style.opacity = "0.8";
        }
      }
    }
  });

  function endTrackInteraction(e) {
    // Only process if we have an active interaction
    if (!state.trackResizeState && !state.trackDragState) return;
    
    // Release pointer capture
    if (e.target.releasePointerCapture) {
      try {
        e.target.releasePointerCapture(e.pointerId);
      } catch (err) {
        // Ignore if already released
      }
    }
    
    if (state.trackResizeState) {
      state.trackResizeState = null;
    } else if (state.trackDragState) {
      // Handle reordering
      const layout = getTrackLayout();
      const draggedItem = layout.find(l => l.track.id === state.trackDragState.trackId);
      if (draggedItem) {
        const container = trackControls.querySelector(`[data-track-id="${state.trackDragState.trackId}"]`);
        if (container) {
          container.style.transform = "";
          container.style.zIndex = "";
          container.style.opacity = "";
        }
        
        // Find new position based on orientation
        const isVertical = isVerticalMode();
        let newIndex = 0;
        if (isVertical) {
          const newX = draggedItem.left + state.trackDragState.offsetX;
          for (let i = 0; i < layout.length; i++) {
            if (newX > layout[i].left + layout[i].width / 2) {
              newIndex = i + 1;
            }
          }
        } else {
          const newY = draggedItem.top + state.trackDragState.offsetY;
          for (let i = 0; i < layout.length; i++) {
            if (newY > layout[i].top + layout[i].height / 2) {
              newIndex = i + 1;
            }
          }
        }
        newIndex = Math.max(0, Math.min(newIndex, layout.length - 1));
        
        // Reorder tracks
        const currentIndex = state.tracks.findIndex(t => t.id === state.trackDragState.trackId);
        if (currentIndex !== newIndex && currentIndex !== -1) {
          const [track] = state.tracks.splice(currentIndex, 1);
          state.tracks.splice(newIndex, 0, track);
          renderAll();
        } else {
          // Just re-render to reset visual state
          renderAll();
        }
      }
      state.trackDragState = null;
    }
  }

  trackControls.addEventListener("pointerup", endTrackInteraction);
  trackControls.addEventListener("pointercancel", endTrackInteraction);
  
  // Also listen on document to catch pointerup events that might occur outside
  document.addEventListener("pointerup", (e) => {
    if (state.trackResizeState || state.trackDragState) {
      endTrackInteraction(e);
    }
  });
  document.addEventListener("pointercancel", (e) => {
    if (state.trackResizeState || state.trackDragState) {
      endTrackInteraction(e);
    }
  });
  }

  // Resize - debounced to batch resize events (100ms delay)
  new ResizeObserver(debounce(() => {
    // Handle WebGPU canvas resize
    if (webgpuCore && webgpuSupported) {
      try {
        webgpuCore.handleResize();
      } catch (error) {
        console.error("WebGPU resize error:", error);
      }
    }
    renderAll();
  }, 100)).observe(flow);
  new ResizeObserver(debounce(() => renderAll(), 100)).observe(reads);
  new ResizeObserver(debounce(() => {
    // Handle WebGPU canvas resize when tracks container resizes
    if (webgpuCore && webgpuSupported) {
      try {
        webgpuCore.handleResize();
      } catch (error) {
        console.error("WebGPU resize error:", error);
      }
    }
    renderAll();
  }, 100)).observe(tracksSvg);
  window.addEventListener("resize", () => {
    // Handle WebGPU canvas resize
    if (webgpuCore && webgpuSupported) {
      try {
        webgpuCore.handleResize();
      } catch (error) {
        console.error("WebGPU resize error:", error);
      }
    }
    renderAll();
  });

  renderAll();
</script>
</body>
</html>